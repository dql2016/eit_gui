<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of inv_solve_abs_pdipm</title>
  <meta name="keywords" content="inv_solve_abs_pdipm">
  <meta name="description" content="INV_SOLVE_ABS_PDIPM  inverse solver for absolute data using Primal/Dual interior point method">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">inverse</a> &gt; inv_solve_abs_pdipm.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/solvers/inverse&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>inv_solve_abs_pdipm
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>INV_SOLVE_ABS_PDIPM  inverse solver for absolute data using Primal/Dual interior point method</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function img=inv_solve_abs_pdipm( inv_model, data); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> INV_SOLVE_ABS_PDIPM  inverse solver for absolute data using Primal/Dual interior point method
 img= inv_solve_abs_pdipm( inv_model, data);
 img        =&gt; output image (or vector of images)
 inv_model  =&gt; inverse model struct
 data       =&gt; vector of eit data

  inv_model.inv_solve_abs_pdipm.norm_data  1 or 2 (DEFAULT 2)
  inv_model.inv_solve_abs_pdipm.norm_prior 1 or 2 (DEFAULT 2)
  inv_model.inv_solve_abs_pdipm.beta     (default 1e-6)

 Parameters:
  max_iter =  inv_model.parameters.max_iterations (default 10)
      Max number of iterations before stopping
  min change = inv_model.parameters.min_change   (default 0)
      Min Change in objective fcn (norm(y-Jx)^2 + hp*TV(x)) before stopping
 beta is the parameter that smooths the TV functional</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="../../../eidors/solvers/calc_R_prior.html" class="code" title="function R_prior = calc_R_prior( inv_model, varargin )">calc_R_prior</a>	R = calc_R_prior( inv_model, varargin )</li><li><a href="../../../eidors/solvers/calc_difference_data.html" class="code" title="function dva = calc_difference_data( data1, data2, fwd_model)">calc_difference_data</a>	CALC_DIFFERENCE_DATA: calculate difference data between</li><li><a href="../../../eidors/solvers/calc_hyperparameter.html" class="code" title="function hyperparameter = calc_hyperparameter( inv_model )">calc_hyperparameter</a>	CALC_HYPERPARAMETER: calculate hyperparameter value</li><li><a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>	CALC_JACOBIAN: calculate jacobian from an inv_model</li><li><a href="../../../eidors/solvers/calc_jacobian_bkgnd.html" class="code" title="function img_bkgnd = calc_jacobian_bkgnd( inv_model )">calc_jacobian_bkgnd</a>	CALC_JACOBIAN_BKGND: calculate background image around</li><li><a href="../../../eidors/solvers/calc_meas_icov.html" class="code" title="function meas_icov = calc_meas_icov( inv_model )">calc_meas_icov</a>	meas_icov = calc_meas_icov( inv_model )</li><li><a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>	FWD_SOLVE: calculate data from a fwd_model object and an image</li><li><a href="line_optimize.html" class="code" title="function [img fmin res] = line_optimize(imgk, dx, data0, opt)">line_optimize</a>	LINE_OPTIMIZE Cheap line optimizer</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/deprecated/pdipm_abs.html" class="code" title="function img=pdipm_abs( varargin )">pdipm_abs</a>	PDIPM_ABS  inverse solver for absolute data using Primal/Dual interior point method</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function img= pdipm_2_2(  img,W,L,d, pp);</a></li><li><a href="#_sub2" class="code">function img= pdipm_1_2( img,W,L,d, pp);</a></li><li><a href="#_sub3" class="code">function img= pdipm_2_1(img,W,L,d, pp);</a></li><li><a href="#_sub4" class="code">function img= pdipm_1_1( img,W,L,d, pp);</a></li><li><a href="#_sub5" class="code">function dx = x_update( x, dx)</a></li><li><a href="#_sub6" class="code">function pp = manage_beta(pp);</a></li><li><a href="#_sub7" class="code">function pp= process_parameters(imdl);</a></li><li><a href="#_sub8" class="code">function  img = line_optimize(imgk, dx, data1);</a></li><li><a href="#_sub9" class="code">function img = homogeneous_estimate( imdl, data );</a></li><li><a href="#_sub10" class="code">function data = data_vector( data, imdl );</a></li><li><a href="#_sub11" class="code">function dv = sim_diff( img, data1);</a></li><li><a href="#_sub12" class="code">function loop_display(i)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function img=inv_solve_abs_pdipm( inv_model, data);</a>
0002 <span class="comment">% INV_SOLVE_ABS_PDIPM  inverse solver for absolute data using Primal/Dual interior point method</span>
0003 <span class="comment">% img= inv_solve_abs_pdipm( inv_model, data);</span>
0004 <span class="comment">% img        =&gt; output image (or vector of images)</span>
0005 <span class="comment">% inv_model  =&gt; inverse model struct</span>
0006 <span class="comment">% data       =&gt; vector of eit data</span>
0007 <span class="comment">%</span>
0008 <span class="comment">%  inv_model.inv_solve_abs_pdipm.norm_data  1 or 2 (DEFAULT 2)</span>
0009 <span class="comment">%  inv_model.inv_solve_abs_pdipm.norm_prior 1 or 2 (DEFAULT 2)</span>
0010 <span class="comment">%  inv_model.inv_solve_abs_pdipm.beta     (default 1e-6)</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% Parameters:</span>
0013 <span class="comment">%  max_iter =  inv_model.parameters.max_iterations (default 10)</span>
0014 <span class="comment">%      Max number of iterations before stopping</span>
0015 <span class="comment">%  min change = inv_model.parameters.min_change   (default 0)</span>
0016 <span class="comment">%      Min Change in objective fcn (norm(y-Jx)^2 + hp*TV(x)) before stopping</span>
0017 <span class="comment">% beta is the parameter that smooths the TV functional</span>
0018 
0019 <span class="comment">% (C) 2010 Andrea Borsic + Andy Adler. License: GPL v2 or v3</span>
0020 <span class="comment">% $Id: inv_solve_abs_pdipm.m 5081 2015-06-01 21:20:16Z michaelcrabb30 $</span>
0021 
0022 
0023 pp= <a href="#_sub7" class="code" title="subfunction pp= process_parameters(imdl);">process_parameters</a>(inv_model);
0024 
0025 img_bkgnd = <a href="#_sub9" class="code" title="subfunction img = homogeneous_estimate( imdl, data );">homogeneous_estimate</a>( inv_model, data );
0026 
0027 alpha=<a href="../../../eidors/solvers/calc_hyperparameter.html" class="code" title="function hyperparameter = calc_hyperparameter( inv_model )">calc_hyperparameter</a>( inv_model );
0028 L= <a href="../../../eidors/solvers/calc_R_prior.html" class="code" title="function R_prior = calc_R_prior( inv_model, varargin )">calc_R_prior</a>( inv_model );
0029 W= <a href="../../../eidors/solvers/calc_meas_icov.html" class="code" title="function meas_icov = calc_meas_icov( inv_model )">calc_meas_icov</a>( inv_model );
0030 
0031 img= feval(pp.fn, img_bkgnd, W,alpha*L,data, pp);
0032 
0033 img.name = sprintf(<span class="string">'inv_solve_abs_pdipm-nd%d-ni%d'</span>,pp.norm_data,pp.norm_image);
0034 
0035 <span class="comment">% This is the Gauss-Newton algorithm</span>
0036 <span class="comment">%   for the linear case it is: s= (J'*W*J + L'*L)\J'*W*d;</span>
0037 <a name="_sub1" href="#_subfunctions" class="code">function img= pdipm_2_2(  img,W,L,d, pp);</a>
0038    img0 = img;
0039    hp2RtR = L'*L;
0040    <span class="keyword">for</span> i = 1:pp.max_iter
0041      dv = <a href="#_sub11" class="code" title="subfunction dv = sim_diff( img, data1);">sim_diff</a>( img, d);
0042      J = <a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>( img );
0043 
0044      RDs = hp2RtR*(img0.elem_data - img.elem_data);
0045      ds = (J'*W*J + hp2RtR)\(J'*dv + RDs);
0046 
0047      img = <a href="line_optimize.html" class="code" title="function [img fmin res] = line_optimize(imgk, dx, data0, opt)">line_optimize</a>(img, ds, d);
0048 
0049      pp = <a href="#_sub6" class="code" title="subfunction pp = manage_beta(pp);">manage_beta</a>(pp);
0050      <a href="#_sub12" class="code" title="subfunction loop_display(i)">loop_display</a>(i)
0051    <span class="keyword">end</span>
0052 
0053 <a name="_sub2" href="#_subfunctions" class="code">function img= pdipm_1_2( img,W,L,d, pp);</a>
0054    [M]   = size(W,1); <span class="comment">% M measurements</span>
0055    [jnk,N] = size(L); <span class="comment">% E edges, N parameters</span>
0056    x= zeros( M, 1 ); <span class="comment">% dual var - start with zeros</span>
0057 
0058    <span class="keyword">for</span> loop = 1:pp.max_iter
0059       <span class="comment">% Jacobian</span>
0060       J = <a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>( img );
0061       dv = -<a href="#_sub11" class="code" title="subfunction dv = sim_diff( img, data1);">sim_diff</a>(img, d);
0062       s = img.elem_data;
0063 
0064       <span class="comment">% Define variables</span>
0065       f = dv;                  F= spdiags(f,0,M,M);
0066                                X= spdiags(x,0,M,M);
0067       e = sqrt(f.^2 + pp.beta);E= spdiags(e,0,M,M);
0068 
0069       <span class="comment">% Define derivatives</span>
0070       dFc_ds = (speye(M,M) - X*inv(E)*F)*J;
0071       dFc_dx = -E;
0072       dFf_ds = L'*L;
0073       dFf_dx = J'*W;
0074 
0075       dsdx = -[dFc_ds, dFc_dx; dFf_ds, dFf_dx] \ <span class="keyword">...</span>
0076               [ f-E*x; J'*W*x + L'*L*s ];
0077 
0078       ds = dsdx(1:N);
0079       img = <a href="line_optimize.html" class="code" title="function [img fmin res] = line_optimize(imgk, dx, data0, opt)">line_optimize</a>(img, ds, d);
0080 
0081       dx = <a href="#_sub5" class="code" title="subfunction dx = x_update( x, dx)">x_update</a>(x, dsdx(N+(1:M)));
0082       x= x + dx;
0083  
0084       pp = <a href="#_sub6" class="code" title="subfunction pp = manage_beta(pp);">manage_beta</a>(pp);
0085       <a href="#_sub12" class="code" title="subfunction loop_display(i)">loop_display</a>(i)
0086    <span class="keyword">end</span>
0087 
0088 <a name="_sub3" href="#_subfunctions" class="code">function img= pdipm_2_1(img,W,L,d, pp);</a>
0089    [M]   = size(W,1); <span class="comment">% M measurements</span>
0090    [G,N] = size(L); <span class="comment">% E edges, N parameters</span>
0091    x= zeros( G, 1 ); <span class="comment">% dual var - start with zeros</span>
0092 
0093    <span class="keyword">for</span> loop = 1:pp.max_iter
0094       <span class="comment">% Jacobian</span>
0095       J = <a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>( img );
0096       dv = -<a href="#_sub11" class="code" title="subfunction dv = sim_diff( img, data1);">sim_diff</a>(img, d);
0097       
0098       <span class="comment">% Define variables</span>
0099       f = L*img.elem_data;     F= spdiags(f,0,G,G);
0100                                X= spdiags(x,0,G,G);
0101       e = sqrt(f.^2 + pp.beta);E= spdiags(e,0,G,G);
0102 
0103       <span class="comment">% Define derivatives</span>
0104       dFc_ds = (speye(G,G) - X*inv(E)*F)*L;
0105       dFc_dx = -E;
0106       dFf_ds = J'*J;
0107       dFf_dx = L';
0108 
0109       dsdx = -[dFc_ds, dFc_dx; dFf_ds, dFf_dx] \ <span class="keyword">...</span>
0110               [ f-E*x; J'*dv + L'*x ];
0111 
0112       ds = dsdx(1:N);
0113       img = <a href="line_optimize.html" class="code" title="function [img fmin res] = line_optimize(imgk, dx, data0, opt)">line_optimize</a>(img, ds, d);
0114 
0115       dx = <a href="#_sub5" class="code" title="subfunction dx = x_update( x, dx)">x_update</a>(x, dsdx(N+(1:G)));
0116       x= x + dx;
0117 
0118       pp = <a href="#_sub6" class="code" title="subfunction pp = manage_beta(pp);">manage_beta</a>(pp);
0119       <a href="#_sub12" class="code" title="subfunction loop_display(i)">loop_display</a>(i)
0120    <span class="keyword">end</span>
0121 
0122 <span class="comment">%   img0 = img;</span>
0123 <span class="comment">%   hp2RtR = L'*L;</span>
0124 <span class="comment">%   for i = 1:pp.max_iter</span>
0125 <span class="comment">%     vsim = fwd_solve( img );</span>
0126 <span class="comment">%     dv = calc_difference_data( vsim , d, img.fwd_model);</span>
0127 <span class="comment">%     J = calc_jacobian( img );</span>
0128 <span class="comment">%</span>
0129 <span class="comment">%     RDx = hp2RtR*(img0.elem_data - img.elem_data);</span>
0130 <span class="comment">%     dx = (J'*W*J + hp2RtR)\(J'*dv + RDx);</span>
0131 <span class="comment">%</span>
0132 <span class="comment">%     img = line_optimize(img, dx, d);</span>
0133 <span class="comment">%</span>
0134 <span class="comment">%     loop_display(i)</span>
0135 <span class="comment">%   end</span>
0136 
0137 <a name="_sub4" href="#_subfunctions" class="code">function img= pdipm_1_1( img,W,L,d, pp);</a>
0138    [M]   = size(W,1); <span class="comment">% M measurements</span>
0139    [D,N] = size(L); <span class="comment">% E edges, N parameters</span>
0140    s= img.elem_data;
0141    y= zeros( D, 1 ); <span class="comment">% dual var - start with zeros</span>
0142    x= zeros( M, 1 ); <span class="comment">% dual var - start with zeros</span>
0143 
0144    <span class="keyword">for</span> loop = 1:pp.max_iter
0145       <span class="comment">% Jacobian</span>
0146       J = <a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>( img );
0147       dv = -<a href="#_sub11" class="code" title="subfunction dv = sim_diff( img, data1);">sim_diff</a>(img, d);
0148 
0149       <span class="comment">% Define variables</span>
0150       g = L*img.elem_data;     G= spdiags(g,0,D,D);
0151       s = sqrt(g.^2 + pp.beta);S= spdiags(s,0,D,D);
0152                                Y= spdiags(y,0,D,D);
0153 
0154       f = dv;                  F= spdiags(f,0,M,M);
0155       e = sqrt(f.^2 + pp.beta);E= spdiags(e,0,M,M);
0156                                X= spdiags(x,0,M,M);
0157 
0158       <span class="comment">% Define derivatives</span>
0159       As1 = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(N,N);
0160       As2 = (speye(M,M) - X/E*F) * J; <span class="comment">% As2 = (speye(M,M) - X*inv(E)*F) * J;</span>
0161       As3 = (speye(D,D) - Y/S*G) * L; <span class="comment">% As3 = (speye(D,D) - Y*inv(S)*G) * L;</span>
0162       Ax1 = J'*W;
0163       Ax2 = -E;
0164       Ax3 = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(D,M);
0165       Ay1 = L';
0166       Ay2 = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(M,D);
0167       Ay3 = -S;
0168       B1  = J'*W*x + L'*y;
0169       B2  = f - E*x;
0170       B3  = g - S*y;
0171 
0172 <span class="comment">%     DD = -[As1,Ax1,Ay1; ...</span>
0173 <span class="comment">%            As2,Ax2,Ay2; ...</span>
0174 <span class="comment">%            As3,Ax3,Ay3] \ [B1;B2;B3];</span>
0175 
0176 <span class="comment">%     dm = DD(1:N); dx = DD(N+(1:M)); dy = DD(N+M+(1:D));</span>
0177 
0178       JtWiE = J'*W/E; LtiS = L'/S;
0179       dm= -(JtWiE*As2 + LtiS*As3)\(JtWiE*f + LtiS*g);
0180       dx= E\(B2 + As2*dm);
0181       dy= S\(B3 + As3*dm);
0182 
0183       img = <a href="line_optimize.html" class="code" title="function [img fmin res] = line_optimize(imgk, dx, data0, opt)">line_optimize</a>(img, dm, d);
0184 
0185       dx = <a href="#_sub5" class="code" title="subfunction dx = x_update( x, dx)">x_update</a>(x, dx);
0186       x= x + dx;
0187 
0188       dy = <a href="#_sub5" class="code" title="subfunction dx = x_update( x, dx)">x_update</a>(y, dy);
0189       y= y + dy;
0190 
0191       <a href="#_sub12" class="code" title="subfunction loop_display(i)">loop_display</a>(i)
0192       pp = <a href="#_sub6" class="code" title="subfunction pp = manage_beta(pp);">manage_beta</a>(pp);
0193    <span class="keyword">end</span>
0194 
0195 <span class="comment">% abs(x + dx) must be &lt;= 1</span>
0196 <a name="_sub5" href="#_subfunctions" class="code">function dx = x_update( x, dx)</a>
0197    dx(dx==0) = eps; <span class="comment">% can't have zeros</span>
0198    sx = sign(dx);
0199    <span class="comment">% space to limits in direction of x</span>
0200    clr = sx - x;
0201    <span class="comment">% how much to multiply by to get to limits</span>
0202    fac = clr./dx;
0203    <span class="comment">% choose min amount to get to limits</span>
0204    dx = dx*min(fac);
0205 
0206 <a name="_sub6" href="#_subfunctions" class="code">function pp = manage_beta(pp);</a>
0207    pp.beta = pp.beta * pp.beta_reduce;
0208    <span class="keyword">if</span> pp.beta &lt; pp.beta_minimum;
0209       pp.beta = pp.beta_minimum;
0210    <span class="keyword">end</span>
0211 
0212 <a name="_sub7" href="#_subfunctions" class="code">function pp= process_parameters(imdl);</a>
0213    <span class="keyword">try</span>    pp.max_iter = imdl.parameters.max_iterations;
0214    <span class="keyword">catch</span>  pp.max_iter = 10;
0215    <span class="keyword">end</span>
0216 
0217    <span class="keyword">try</span>    pp.min_change = imdl.parameters.min_change;
0218    <span class="keyword">catch</span>  pp.min_change = 0;
0219    <span class="keyword">end</span>
0220 
0221    <span class="keyword">try</span>    pp.beta = imdl.inv_solve_abs_pdipm.beta; 
0222    <span class="keyword">catch</span>  pp.beta = 1e-6;
0223    <span class="keyword">end</span>
0224 
0225    pp.beta_reduce = 0.2;
0226    pp.beta_minimum= 1e-16;
0227 
0228    <span class="keyword">try</span>    pp.norm_data = imdl.inv_solve_abs_pdipm.norm_data;
0229    <span class="keyword">catch</span>  pp.norm_data = 2;
0230    <span class="keyword">end</span>
0231 
0232    <span class="keyword">try</span>    pp.norm_image = imdl.inv_solve_abs_pdipm.norm_image;
0233    <span class="keyword">catch</span>  pp.norm_image = 2;
0234    <span class="keyword">end</span>
0235 
0236    <span class="keyword">if</span>     pp.norm_data==2 &amp;&amp; pp.norm_image==2;
0237       pp.fn = @<a href="#_sub1" class="code" title="subfunction img= pdipm_2_2(  img,W,L,d, pp);">pdipm_2_2</a>;
0238    <span class="keyword">elseif</span> pp.norm_data==2 &amp;&amp; pp.norm_image==1;
0239       pp.fn = @<a href="#_sub3" class="code" title="subfunction img= pdipm_2_1(img,W,L,d, pp);">pdipm_2_1</a>;
0240    <span class="keyword">elseif</span> pp.norm_data==1 &amp;&amp; pp.norm_image==2;
0241       pp.fn = @<a href="#_sub2" class="code" title="subfunction img= pdipm_1_2( img,W,L,d, pp);">pdipm_1_2</a>;
0242    <span class="keyword">elseif</span> pp.norm_data==1 &amp;&amp; pp.norm_image==1;
0243       pp.fn = @<a href="#_sub4" class="code" title="subfunction img= pdipm_1_1( img,W,L,d, pp);">pdipm_1_1</a>;
0244    <span class="keyword">else</span>
0245       error(<span class="string">'norm_data and norm_image should be 1 or 2'</span>);
0246    <span class="keyword">end</span>
0247 
0248 
0249 
0250 <span class="comment">% Fit a parabola to the linefit and pick the best point</span>
0251 <span class="comment">% This is faster than doing an exhaustive search</span>
0252 <a name="_sub8" href="#_subfunctions" class="code">function  img = line_optimize(imgk, dx, data1);</a>
0253   flist = [ 0.1,  0.5, 1.0];
0254   clim = mean(imgk.elem_data)/10; <span class="comment">% prevent zero and negative conductivity</span>
0255   img = imgk;
0256   <span class="keyword">for</span> i = 1:length(flist);
0257      img.elem_data = imgk.elem_data + flist(i)*dx;
0258      img.elem_data(img.elem_data &lt;= clim ) = clim;
0259      dv = <a href="#_sub11" class="code" title="subfunction dv = sim_diff( img, data1);">sim_diff</a>( img, data1);
0260      mlist(i) = norm(dv);
0261   <span class="keyword">end</span>
0262   pf = polyfit(flist, mlist, 2);
0263   fmin = -pf(2)/pf(1)/2; <span class="comment">% poly minimum</span>
0264   fmin(fmin&gt;1) = 1; fmin(fmin&lt;0) = 0;
0265 
0266   img.elem_data = imgk.elem_data + flist(i)*dx;
0267   img.elem_data(img.elem_data &lt;= clim ) = clim;
0268 
0269 <a name="_sub9" href="#_subfunctions" class="code">function img = homogeneous_estimate( imdl, data );</a>
0270    img = <a href="../../../eidors/solvers/calc_jacobian_bkgnd.html" class="code" title="function img_bkgnd = calc_jacobian_bkgnd( inv_model )">calc_jacobian_bkgnd</a>( imdl );
0271    vs = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(img);
0272    data = <a href="#_sub10" class="code" title="subfunction data = data_vector( data, imdl );">data_vector</a>( data, imdl );
0273 
0274    pf = polyfit(data,vs.meas,1);
0275 
0276    img.elem_data = img.elem_data*pf(1);
0277 
0278 <a name="_sub10" href="#_subfunctions" class="code">function data = data_vector( data, imdl );</a>
0279    <span class="keyword">if</span> isstruct(data)
0280       data = data.meas;
0281    <span class="keyword">else</span>
0282      meas_select = [];
0283      <span class="keyword">try</span>
0284         meas_select = imdl.fwd_model.meas_select;
0285      <span class="keyword">end</span>
0286      <span class="keyword">if</span> length(data) == length(meas_select)
0287         data = data(meas_select);
0288      <span class="keyword">end</span>
0289    <span class="keyword">end</span>
0290 
0291 <a name="_sub11" href="#_subfunctions" class="code">function dv = sim_diff( img, data1);</a>
0292   vsim = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>( img );
0293   dv = <a href="../../../eidors/solvers/calc_difference_data.html" class="code" title="function dva = calc_difference_data( data1, data2, fwd_model)">calc_difference_data</a>( vsim , data1, img.fwd_model);
0294 
0295 <a name="_sub12" href="#_subfunctions" class="code">function loop_display(i)</a>
0296    fprintf(<span class="string">'+'</span>);</pre></div>
<hr><address>Generated on Fri 01-Jun-2018 15:59:55 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>