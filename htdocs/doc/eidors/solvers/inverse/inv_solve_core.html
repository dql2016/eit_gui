<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of inv_solve_core</title>
  <meta name="keywords" content="inv_solve_core">
  <meta name="description" content="INV_SOLVE_CORE Solver using a generic iterative algorithm">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">inverse</a> &gt; inv_solve_core.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/solvers/inverse&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>inv_solve_core
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>INV_SOLVE_CORE Solver using a generic iterative algorithm</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function img= inv_solve_core( inv_model, data0, data1); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">INV_SOLVE_CORE Solver using a generic iterative algorithm
 img        =&gt; output image (or vector of images)
 inv_model  =&gt; inverse model struct
 data0      =&gt; EIT data
 data0, data1 =&gt; difference EIT data

 This function is parametrized and uses function pointers where possible to
 allow its use as a general iterative solver framework. There are a large
 number of parameters and functions contained here. Sensible defaults are
 used throughout. You do not need to set every parameter.

 The solver operates as an absolute Gauss-Newton iterative solver by default.
 Wrapper functions are available to call this function in its various forms.
 Look forward to the &quot;See also&quot; section at the end of this help.

 Argument matrices to the internal functions (measurement inverse covariance,
 for example) are only calculated if required. Functions that are supplied to
 this <a href="inv_solve_core.html" class="code" title="function img= inv_solve_core( inv_model, data0, data1);">INV_SOLVE_CORE</a> must be able to survive being probed: they will have
 each parameter set to either 0 or 1 to determine if the function is sensitive
 to that argument. This works cleanly for most matrix multiplication based
 functions but for more abstract code, some handling of this behaviour may
 need to be implemented.

 In the following parameters, r_k is the current residual, r_{k-1} is the
 previous iteration's residual. k is the iteration count.

 Parameters denoted with a ** to the right of their default values are
 deprecated legacy parameters, some of which formerly existed under
 'inv_model.parameters.*'.

 Parameters (inv_model.<a href="inv_solve_core.html" class="code" title="function img= inv_solve_core( inv_model, data0, data1);">inv_solve_core</a>.*):
   verbose (show progress)                (default 1)
      0: quiet
    &gt;=1: print iteration count and residual
    &gt;=2: print details as the algorithm progresses
    &gt;=3: plot residuals versus iteration count
    &gt;=4: plot result at each iteration, see show_fem
    &gt;=5: plot line search per iteration
   plot_residuals                         (default 0)
    plot residuals without verbose output
   fig_prefix                       (default: &lt;none&gt;)
    figure file prefix; figures not saved if &lt;none&gt;
   fwd_solutions                          (default 0)
    0: ignore
    1: count fwd_solve(), generally the most
       computationally expensive component of
       the iterations
   residual_func =             (default @GN_residual)
    NOTE: @meas_residual exists to maintain
    compatibility with some older code
   max_iterations                        (default 10)  **
   ntol (estimate of machine precision) (default eps)
   tol (stop iter if r_k &lt; tol)           (default 0)
   dtol                              (default -0.01%)
    stop iter if (r_k - r_{k-1})/r_1 &lt; dtol AND
                 k &gt;= dtol_iter
   dtol_iter                              (default 0)
    apply dtol stopping criteria if k &gt;= dtol_iter
   min_value                           (default -inf)  **
   max_value                           (default +inf)  **
   line_optimize_func                (default &lt;none&gt;)  ** TODO
     [next,fmin,res]=f(org,dx,data0,opt);
     opt=line_optimize.* + objective_func
     Deprecated, use line_search_func instead.
   <a href="line_optimize.html" class="code" title="function [img fmin res] = line_optimize(imgk, dx, data0, opt)">line_optimize</a>.perturb
                   (default line_search_args.perturb)  ** TODO
     Deprecated, use line_search_args.perturb instead.
   update_func                         (default TODO)  ** TODO
     [img,opt]=f(org,next,dx,fmin,res,opt)
     Deprecated, use &lt;TODO&gt; instead.
   update_method                   (default cholesky)
     Method to use for solving dx: 'pcg' or 'cholesky'
     If 'cholesky', will fall back to 'pcg' if
     out-of-memory. Matlab has trouble detecting the
     out-of-memory condition on many machines, and is
     likely to just grind to a halt swapping. Beware.
   do_starting_estimate                   (default 1)  ** TODO
     Deprecated, use &lt;TODO&gt; instead.
   line_search_func       (default @line_search_onm2)
   line_search_dv_func      (default @update_dv_core)
   line_search_de_func      (default @update_de_core)
   line_search_args.perturb
                     (default [0 1/16 1/8 1/4 1/2 1])
    line search for alpha by these steps along sx
   line_search_args.plot                  (default 0)
   c2f_background                         (default 0)
    if &gt; 0, this is additional elem_data
    if a c2f map exists, the default is to decide
    based on an estimate of c2f overlap whether a
    background value is required. If a background is
    required, it is added as the last element of that
    type.
   c2f_background_fixed                   (default 1)
    hold the background estimate fixed or allow it
    to vary as any other elem_data
   elem_fixed                            (default [])
    meas_select already handles selecting from the
    valid measurements. we want the same for the
    elem_data, so we only work on modifying the
    legal values.
    Note that c2f_background's elements are added to
    this list if c2f_background_fixed == 1.
   prior_data             (default to jacobian_bkgnd)
    Sets the priors of type elem_prior. May be
    scalar, per elem_prior, or match the working
    length of each elem_data type. Note that for priors
    using the c2f a background element may be added
    to the end of that range when required; see
    c2f_background.
   elem_len                (default to all elem_data)
    A cell array list of how many of each
    elem_working there are in elem_data.
      prior_data = { 32.1, 10*ones(10,1) };
      elem_prior = {'conductivity', 'movement'};
      elem_len = { 20001, 10 };
   elem_prior                (default 'conductivity')
    Input 'prior_data' type; immediately converted to
    'elem_working' type before first iteration.
   elem_working              (default 'conductivity')
   elem_output               (default 'conductivity')
    The working and output units for 'elem_data'.
    Valid types are 'conductivity' and 'resistivity'
    as plain units or with the prefix 'log_' or
    'log10_'. Conversions are handled internally.
    Scaling factors are applied to the Jacobian
    (calculated in units of 'conductivity') as
    appropriate.
    If elem_working == elem_output, then no
    conversions take place.
    For multiple types, use cell array.
    ex: elem_output = {'log_resistivity', 'movement'}
   meas_input                     (default 'voltage')
   meas_working                   (default 'voltage')
    Similarly to elem_working/output, conversion
    between 'voltage' and 'apparent_resistivity' and
    their log/log10 variants are handled internally.
    If meas_input == meas_working no conversions take
    place. The normalization factor 'N' is calculated
    if 'apparent_resistivity' is used.
   update_img_func             (default: pass-through)
    Called prior to calc_jacobian and update_dv.
    Elements are converted to their &quot;base types&quot;
    before this function is called. For example,
    'log_resistivity' becomes 'conductivity'.
    It is a hook to allow additional updates to the
    model before the Jacobian, or a new set of
    measurements are calculated via fwd_solve.
   return_working_variables               (default: 0)
    If 1, return the last working variables to the user
     img.inv_solve_{type}.J   Jacobian
     img.inv_solve_{type}.dx  descent direction
     img.inv_solve_{type}.sx  search direction
     img.inv_solve_{type}.alpha  line search result
     img.inv_solve_{type}.beta   conjugation parameter
     img.inv_solve_{type}.r   as:
       [ residual, measurement misfit, element misfit ]
       with one row per iteration
   show_fem                       (default: @show_fem)
    Function with which to plot each iteration's
    current parameters.

   Signature for residual_func
    [r,m,e] = f(dv, de, W, hps2RtR, hpt2LLt)
   where
    r   - the residual = m + e
    m   - measurement error
    e   - prior misfit
    dv  - change in voltage
    de  - change in image elements
    W   - measurement inverse covariance matrix
    hps2  - spatial hyperparameter squared, see CALC_HYPERPARAMETER
    RtR   - regularization matrix squared --&gt; hps2RtR = hps2*RtR
    hpt2  - temporal hyperparameter squared
    LLt   - temporal regularization matrix squared --&gt; hpt2LLt = hpt2*LLt

   Signature for line_optimize_func
    [alpha, img, dv, opt] = f(img, sx, data0, img0, N, W, hps2RtR, hpt2LLt, dv, opt)
   where:
    alpha - line search result
    img   - the current image
            (optional, recalculated if not available)
    sx    - the search direction to which alpha should be applied
    data0 - the true measurements     (dv = N*data - N*data0)
    img0  - the image background (de = img - img0)
    N     - a measurement normalization factor, N*dv
    W     - measurement inverse covariance matrix
    hps2  - spatial hyperparameter squared, see CALC_HYPERPARAMETER
    RtR   - regularization matrix squared --&gt; hps2RtR = hps2*RtR
    hpt2  - temporal hyperparameter squared
    LLt   - temporal regularization matrix squared --&gt; hpt2LLt = hpt2*LLt
    dv    - change in voltage
            (optional, recalculated if not available)
    opt   - additional arguments, updated at each call

   Signature for line_search_dv_func
    [dv, opt] = update_dv_core(img, data0, N, opt)
   where:
    dv    - change in voltage
    opt   - additional arguments, updated at each call
    data  - the estimated measurements
    img   - the current image
    data0 - the true measurements
    N     - a measurement normalization factor, N*dv

   Signature for line_search_de_func
    de = f(img, img0, opt)
   where:
    de    - change in image elements
    img   - the current image
    img0  - the image background (de = img - img0)
    opt   - additional arguments

   Signature for calc_jacobian_scaling_func
    S = f(x)
   where:
    S - to be used to scale the Jacobian
    x - current img.elem_data in units of 'conductivity'

   Signature for  update_img_func
    img2 = f(img1, opt)
   where
    img1 - an input image, the current working image
    img2 - a (potentially) modified version to be used
    for the fwd_solve/Jacobian calculations

 NOTE that the default line search is very crude. For
 my test problems it seems to amount to an expensive grid
 search. Much more efficient line search algorithms exist
 and some fragments already are coded elsewhere in the
 EIDORS code-base.

 See also: INV_SOLVE_ABS_GN, INV_SOLVE_ABS_GN_LOGC,
           INV_SOLVE_ABS_CG, INV_SOLVE_ABS_CG_LOGC,
           <a href="line_search_o2.html" class="code" title="function  [alpha, img, dv, opt] = line_search_o2(imgk, dx, data1, img1, N, W, hps2RtR, hpt2LLt, dv0, opt)">LINE_SEARCH_O2</a>, <a href="line_search_onm2.html" class="code" title="function  [alpha, img, dv, opt] = line_search_onm2(imgk, dx, data1, img1, N, W, hps2RtR, hpt2LLt, dv0, opt, retry, pf_max)">LINE_SEARCH_ONM2</a>

 (C) 2010-2016 Alistair Boyle, Nolwenn Lesparre, Andy Adler, Bartłomiej Grychtol.
 License: GPL version 2 or version 3</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/algorithms/left_divide.html" class="code" title="function [V] = left_divide(E,I,tol,~,V)">left_divide</a>	[V] = LEFT_DIVIDE(E,I,tol,pp,V);</li><li><a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="../../../eidors/graphics/matlab/show_fem_move.html" class="code" title="function [hf,hh] = show_fem_move( img, move, scale, options )">show_fem_move</a>	SHOW_FEM_MOVE   Plot EIT finite element model (FEM) and movement</li><li><a href="../../../eidors/models/data_mapper.html" class="code" title="function img = data_mapper(img, reverse)">data_mapper</a>	DATA_MAPPER maps img.params data to elem or node data</li><li><a href="../../../eidors/models/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>	INTERP_MESH: calculate interpolation points onto mdl elements</li><li><a href="../../../eidors/models/mk_approx_c2f.html" class="code" title="function [mapping, outside] = mk_approx_c2f( f_mdl, c_mdl );">mk_approx_c2f</a>	MK_APPROX_C2F: create a mapping matrix from coarse to fine FEM</li><li><a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="../../../eidors/models/mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>	imdl = mk_geophysics_model(str, ne, [option])</li><li><a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="../../../eidors/models/simulate_movement.html" class="code" title="function [vh,vi,xyzr,c2f]= simulate_movement( img, xyzr, value );">simulate_movement</a>	SIMULATE_MOVEMENT simulate small conductivity perturbations</li><li><a href="../../../eidors/models/supported_params.html" class="code" title="function list = supported_params">supported_params</a>	</li><li><a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>	SPDIAG Sparse diagonal matrices and diagonals of a matrix.</li><li><a href="../../../eidors/solvers/calc_LLt_prior.html" class="code" title="function LLt_prior = calc_LLt_prior( data0, inv_model )">calc_LLt_prior</a>	LLt = calc_LLt_prior( data0, inv_model )</li><li><a href="../../../eidors/solvers/calc_RtR_prior.html" class="code" title="function RtR_prior = calc_RtR_prior( inv_model )">calc_RtR_prior</a>	RtR = calc_RtR_prior( inv_model )</li><li><a href="../../../eidors/solvers/calc_difference_data.html" class="code" title="function dva = calc_difference_data( data1, data2, fwd_model)">calc_difference_data</a>	CALC_DIFFERENCE_DATA: calculate difference data between</li><li><a href="../../../eidors/solvers/calc_hyperparameter.html" class="code" title="function hyperparameter = calc_hyperparameter( inv_model )">calc_hyperparameter</a>	CALC_HYPERPARAMETER: calculate hyperparameter value</li><li><a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>	CALC_JACOBIAN: calculate jacobian from an inv_model</li><li><a href="../../../eidors/solvers/calc_meas_icov.html" class="code" title="function meas_icov = calc_meas_icov( inv_model )">calc_meas_icov</a>	meas_icov = calc_meas_icov( inv_model )</li><li><a href="../../../eidors/solvers/forward/fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>	FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</li><li><a href="../../../eidors/solvers/forward/jacobian_adjoint.html" class="code" title="function J= jacobian_adjoint( fwd_model, img)">jacobian_adjoint</a>	JACOBIAN_ADJOINT: J= jacobian_adjoint( img )</li><li><a href="../../../eidors/solvers/forward/jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>	JACOBIAN_MOVEMENT   Computes the Jacobian matrix for conductivity and</li><li><a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>	FWD_SOLVE: calculate data from a fwd_model object and an image</li><li><a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>	INV_SOLVE: calculate imag from an inv_model and data</li><li><a href="inv_solve_core.html" class="code" title="function img= inv_solve_core( inv_model, data0, data1);">inv_solve_core</a>	INV_SOLVE_CORE Solver using a generic iterative algorithm</li><li><a href="line_search_onm2.html" class="code" title="function  [alpha, img, dv, opt] = line_search_onm2(imgk, dx, data1, img1, N, W, hps2RtR, hpt2LLt, dv0, opt, retry, pf_max)">line_search_onm2</a>	function  [alpha, img, dv, opt] = line_search_onm2(imgk, dx, data1, img1, N, W, hps2RtR, hpt2LLt, dv0, opt)</li><li><a href="prior_movement.html" class="code" title="function Reg= prior_movement( inv_model );">prior_movement</a>	PRIOR_MOVEMENT calculate image prior</li><li><a href="../../../eidors/tools/eidors_default.html" class="code" title="function varargout = eidors_default(varargin)">eidors_default</a>	EIDORS_DEFAULT Default function handler.</li><li><a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/deprecated/inv_solve_abs_core.html" class="code" title="function img= inv_solve_abs_core(imdl,varargin);">inv_solve_abs_core</a>	inv_solve_abs_core is deprecated in favour of inv_solve_core</li><li><a href="inv_solve_cg.html" class="code" title="function img= inv_solve_cg( inv_model, data1, data2);">inv_solve_cg</a>	function img= inv_solve_cg( inv_model, data1);</li><li><a href="inv_solve_core.html" class="code" title="function img= inv_solve_core( inv_model, data0, data1);">inv_solve_core</a>	INV_SOLVE_CORE Solver using a generic iterative algorithm</li><li><a href="inv_solve_gn.html" class="code" title="function img= inv_solve_gn( inv_model, data1, data2);">inv_solve_gn</a>	function img= inv_solve_gn( inv_model, data1);</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function show_meas_err(dvall, data0, k, N, W, opt)</a></li><li><a href="#_sub2" class="code">function n_frames = count_data_frames(data1)</a></li><li><a href="#_sub3" class="code">function img = init_elem_data(img, opt)</a></li><li><a href="#_sub4" class="code">function W = init_meas_icov(inv_model, opt)</a></li><li><a href="#_sub5" class="code">function [N, dN] = init_normalization(fmdl, data0, opt)</a></li><li><a href="#_sub6" class="code">function [stop, k, r, img] = update_residual(dv, img, de, W, hps2RtR, hpt2LLt, k, r, alpha, sx, opt)</a></li><li><a href="#_sub7" class="code">function beta = update_beta(dx_k, dx_km1, sx_km1, opt);</a></li><li><a href="#_sub8" class="code">function sx = update_sx(dx, beta, sx_km1, opt);</a></li><li><a href="#_sub9" class="code">function hps2RtR = update_hps2RtR(inv_model, J, k, img, opt)</a></li><li><a href="#_sub10" class="code">function hpt2LLt = update_hpt2LLt(inv_model, data0, k, opt)</a></li><li><a href="#_sub11" class="code">function plot_dx_and_svd_elem(J, W, hps2RtR, k, sx, dx, img, opt)</a></li><li><a href="#_sub12" class="code">function plot_svd(J, W, hps2RtR, k, hp)</a></li><li><a href="#_sub13" class="code">function RtR = calc_RtR_prior_wrapper(inv_model, img, opt)</a></li><li><a href="#_sub14" class="code">function [J, opt] = update_jacobian(img, dN, k, opt)</a></li><li><a href="#_sub15" class="code">function S = dx_dlogx(x);</a></li><li><a href="#_sub16" class="code">function S = dx_dlog10x(x);</a></li><li><a href="#_sub17" class="code">function S = dx_dy(x);</a></li><li><a href="#_sub18" class="code">function S = dx_dlogy(x);</a></li><li><a href="#_sub19" class="code">function S = dx_dlog10y(x);</a></li><li><a href="#_sub20" class="code">function dN = da_dv(v,vh)</a></li><li><a href="#_sub21" class="code">function dN = dloga_dv(v,vh)</a></li><li><a href="#_sub22" class="code">function dN = dlog10a_dv(v,vh)</a></li><li><a href="#_sub23" class="code">function dN = dv_dv(v,vh)</a></li><li><a href="#_sub24" class="code">function dN = dlogv_dv(v,vh)</a></li><li><a href="#_sub25" class="code">function dN = dlog10v_dv(v,vh)</a></li><li><a href="#_sub26" class="code">function [alpha, img, dv, opt] = update_alpha(img, sx, data0, img0, N, W, hps2RtR, hpt2LLt, k, dv, opt)</a></li><li><a href="#_sub27" class="code">function err_if_inf_or_nan(x, str);</a></li><li><a href="#_sub28" class="code">function [img, dv] = update_img_using_limits(img, img0, data0, N, dv, opt)</a></li><li><a href="#_sub29" class="code">function  de = update_de(de, img, img0, opt)</a></li><li><a href="#_sub30" class="code">function [dv, opt] = update_dv(dv, img, data0, N, opt, reason)</a></li><li><a href="#_sub31" class="code">function data = map_meas_struct(data, N, out)</a></li><li><a href="#_sub32" class="code">function [dv, opt, err] = update_dv_core(img, data0, N, opt)</a></li><li><a href="#_sub33" class="code">function show_fem_iter(k, img, inv_model, stop, opt)</a></li><li><a href="#_sub34" class="code">function [ residual meas elem ] = GN_residual(dv, de, W, hps2RtR, hpt2LLt)</a></li><li><a href="#_sub35" class="code">function residual = meas_residual(dv, de, W, hps2RtR)</a></li><li><a href="#_sub36" class="code">function opt = parse_options(imdl,n_frames)</a></li><li><a href="#_sub37" class="code">function check_matrix_sizes(J, W, hps2RtR, hpt2LLt, dv, de, opt)</a></li><li><a href="#_sub38" class="code">function dx = update_dx(J, W, hps2RtR, hpt2LLt, dv, de, opt)</a></li><li><a href="#_sub39" class="code">function dx = GN_update(J, W, hps2RtR, hpt2LLt, dv, de, opt)</a></li><li><a href="#_sub40" class="code">function args = function_depends_upon(func, argn)</a></li><li><a href="#_sub41" class="code">function out = null_func(in, varargin);</a></li><li><a href="#_sub42" class="code">function [out, x, y, z] = ret1_func(varargin);</a></li><li><a href="#_sub43" class="code">function [inv_model, opt] = append_c2f_background(inv_model, opt)</a></li><li><a href="#_sub44" class="code">function [img, opt] = strip_c2f_background(img, opt, indent)</a></li><li><a href="#_sub45" class="code">function b = has_params(s)</a></li><li><a href="#_sub46" class="code">function out = map_img_base_types(img)</a></li><li><a href="#_sub47" class="code">function type = to_base_types(type)</a></li><li><a href="#_sub48" class="code">function img = map_img(img, out);</a></li><li><a href="#_sub49" class="code">function x = map_data(x, in, out)</a></li><li><a href="#_sub50" class="code">function b = map_meas(b, N, in, out)</a></li><li><a href="#_sub51" class="code">function x=range(y)</a></li><li><a href="#_sub52" class="code">function pass=do_unit_test(solver)</a></li><li><a href="#_sub53" class="code">function [imdl, vh, imgi, vi] = unit_test_imdl()</a></li><li><a href="#_sub54" class="code">function do_unit_test_diff()</a></li><li><a href="#_sub55" class="code">function do_unit_test_sub</a></li><li><a href="#_sub56" class="code">function test_map_data(data, in, out, expected)</a></li><li><a href="#_sub57" class="code">function test_map_meas(data, N, in, out, expected)</a></li><li><a href="#_sub58" class="code">function do_unit_test_rec1(solver)</a></li><li><a href="#_sub59" class="code">function do_unit_test_rec_mv(solver)</a></li><li><a href="#_sub60" class="code">function Jm = jacobian_movement_only (fwd_model, img);</a></li><li><a href="#_sub61" class="code">function RtR = prior_movement_only(imdl);</a></li><li><a href="#_sub62" class="code">function do_unit_test_rec2(solver)</a></li><li><a href="#_sub63" class="code">function do_unit_test_diffseq(solver)</a></li><li><a href="#_sub64" class="code">function do_unit_test_absseq(solver)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function img= inv_solve_core( inv_model, data0, data1);</a>
0002 <span class="comment">%INV_SOLVE_CORE Solver using a generic iterative algorithm</span>
0003 <span class="comment">% img        =&gt; output image (or vector of images)</span>
0004 <span class="comment">% inv_model  =&gt; inverse model struct</span>
0005 <span class="comment">% data0      =&gt; EIT data</span>
0006 <span class="comment">% data0, data1 =&gt; difference EIT data</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% This function is parametrized and uses function pointers where possible to</span>
0009 <span class="comment">% allow its use as a general iterative solver framework. There are a large</span>
0010 <span class="comment">% number of parameters and functions contained here. Sensible defaults are</span>
0011 <span class="comment">% used throughout. You do not need to set every parameter.</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% The solver operates as an absolute Gauss-Newton iterative solver by default.</span>
0014 <span class="comment">% Wrapper functions are available to call this function in its various forms.</span>
0015 <span class="comment">% Look forward to the &quot;See also&quot; section at the end of this help.</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% Argument matrices to the internal functions (measurement inverse covariance,</span>
0018 <span class="comment">% for example) are only calculated if required. Functions that are supplied to</span>
0019 <span class="comment">% this INV_SOLVE_CORE must be able to survive being probed: they will have</span>
0020 <span class="comment">% each parameter set to either 0 or 1 to determine if the function is sensitive</span>
0021 <span class="comment">% to that argument. This works cleanly for most matrix multiplication based</span>
0022 <span class="comment">% functions but for more abstract code, some handling of this behaviour may</span>
0023 <span class="comment">% need to be implemented.</span>
0024 <span class="comment">%</span>
0025 <span class="comment">% In the following parameters, r_k is the current residual, r_{k-1} is the</span>
0026 <span class="comment">% previous iteration's residual. k is the iteration count.</span>
0027 <span class="comment">%</span>
0028 <span class="comment">% Parameters denoted with a ** to the right of their default values are</span>
0029 <span class="comment">% deprecated legacy parameters, some of which formerly existed under</span>
0030 <span class="comment">% 'inv_model.parameters.*'.</span>
0031 <span class="comment">%</span>
0032 <span class="comment">% Parameters (inv_model.inv_solve_core.*):</span>
0033 <span class="comment">%   verbose (show progress)                (default 1)</span>
0034 <span class="comment">%      0: quiet</span>
0035 <span class="comment">%    &gt;=1: print iteration count and residual</span>
0036 <span class="comment">%    &gt;=2: print details as the algorithm progresses</span>
0037 <span class="comment">%    &gt;=3: plot residuals versus iteration count</span>
0038 <span class="comment">%    &gt;=4: plot result at each iteration, see show_fem</span>
0039 <span class="comment">%    &gt;=5: plot line search per iteration</span>
0040 <span class="comment">%   plot_residuals                         (default 0)</span>
0041 <span class="comment">%    plot residuals without verbose output</span>
0042 <span class="comment">%   fig_prefix                       (default: &lt;none&gt;)</span>
0043 <span class="comment">%    figure file prefix; figures not saved if &lt;none&gt;</span>
0044 <span class="comment">%   fwd_solutions                          (default 0)</span>
0045 <span class="comment">%    0: ignore</span>
0046 <span class="comment">%    1: count fwd_solve(), generally the most</span>
0047 <span class="comment">%       computationally expensive component of</span>
0048 <span class="comment">%       the iterations</span>
0049 <span class="comment">%   residual_func =             (default @GN_residual)</span>
0050 <span class="comment">%    NOTE: @meas_residual exists to maintain</span>
0051 <span class="comment">%    compatibility with some older code</span>
0052 <span class="comment">%   max_iterations                        (default 10)  **</span>
0053 <span class="comment">%   ntol (estimate of machine precision) (default eps)</span>
0054 <span class="comment">%   tol (stop iter if r_k &lt; tol)           (default 0)</span>
0055 <span class="comment">%   dtol                              (default -0.01%)</span>
0056 <span class="comment">%    stop iter if (r_k - r_{k-1})/r_1 &lt; dtol AND</span>
0057 <span class="comment">%                 k &gt;= dtol_iter</span>
0058 <span class="comment">%   dtol_iter                              (default 0)</span>
0059 <span class="comment">%    apply dtol stopping criteria if k &gt;= dtol_iter</span>
0060 <span class="comment">%   min_value                           (default -inf)  **</span>
0061 <span class="comment">%   max_value                           (default +inf)  **</span>
0062 <span class="comment">%   line_optimize_func                (default &lt;none&gt;)  ** TODO</span>
0063 <span class="comment">%     [next,fmin,res]=f(org,dx,data0,opt);</span>
0064 <span class="comment">%     opt=line_optimize.* + objective_func</span>
0065 <span class="comment">%     Deprecated, use line_search_func instead.</span>
0066 <span class="comment">%   line_optimize.perturb</span>
0067 <span class="comment">%                   (default line_search_args.perturb)  ** TODO</span>
0068 <span class="comment">%     Deprecated, use line_search_args.perturb instead.</span>
0069 <span class="comment">%   update_func                         (default TODO)  ** TODO</span>
0070 <span class="comment">%     [img,opt]=f(org,next,dx,fmin,res,opt)</span>
0071 <span class="comment">%     Deprecated, use &lt;TODO&gt; instead.</span>
0072 <span class="comment">%   update_method                   (default cholesky)</span>
0073 <span class="comment">%     Method to use for solving dx: 'pcg' or 'cholesky'</span>
0074 <span class="comment">%     If 'cholesky', will fall back to 'pcg' if</span>
0075 <span class="comment">%     out-of-memory. Matlab has trouble detecting the</span>
0076 <span class="comment">%     out-of-memory condition on many machines, and is</span>
0077 <span class="comment">%     likely to just grind to a halt swapping. Beware.</span>
0078 <span class="comment">%   do_starting_estimate                   (default 1)  ** TODO</span>
0079 <span class="comment">%     Deprecated, use &lt;TODO&gt; instead.</span>
0080 <span class="comment">%   line_search_func       (default @line_search_onm2)</span>
0081 <span class="comment">%   line_search_dv_func      (default @update_dv_core)</span>
0082 <span class="comment">%   line_search_de_func      (default @update_de_core)</span>
0083 <span class="comment">%   line_search_args.perturb</span>
0084 <span class="comment">%                     (default [0 1/16 1/8 1/4 1/2 1])</span>
0085 <span class="comment">%    line search for alpha by these steps along sx</span>
0086 <span class="comment">%   line_search_args.plot                  (default 0)</span>
0087 <span class="comment">%   c2f_background                         (default 0)</span>
0088 <span class="comment">%    if &gt; 0, this is additional elem_data</span>
0089 <span class="comment">%    if a c2f map exists, the default is to decide</span>
0090 <span class="comment">%    based on an estimate of c2f overlap whether a</span>
0091 <span class="comment">%    background value is required. If a background is</span>
0092 <span class="comment">%    required, it is added as the last element of that</span>
0093 <span class="comment">%    type.</span>
0094 <span class="comment">%   c2f_background_fixed                   (default 1)</span>
0095 <span class="comment">%    hold the background estimate fixed or allow it</span>
0096 <span class="comment">%    to vary as any other elem_data</span>
0097 <span class="comment">%   elem_fixed                            (default [])</span>
0098 <span class="comment">%    meas_select already handles selecting from the</span>
0099 <span class="comment">%    valid measurements. we want the same for the</span>
0100 <span class="comment">%    elem_data, so we only work on modifying the</span>
0101 <span class="comment">%    legal values.</span>
0102 <span class="comment">%    Note that c2f_background's elements are added to</span>
0103 <span class="comment">%    this list if c2f_background_fixed == 1.</span>
0104 <span class="comment">%   prior_data             (default to jacobian_bkgnd)</span>
0105 <span class="comment">%    Sets the priors of type elem_prior. May be</span>
0106 <span class="comment">%    scalar, per elem_prior, or match the working</span>
0107 <span class="comment">%    length of each elem_data type. Note that for priors</span>
0108 <span class="comment">%    using the c2f a background element may be added</span>
0109 <span class="comment">%    to the end of that range when required; see</span>
0110 <span class="comment">%    c2f_background.</span>
0111 <span class="comment">%   elem_len                (default to all elem_data)</span>
0112 <span class="comment">%    A cell array list of how many of each</span>
0113 <span class="comment">%    elem_working there are in elem_data.</span>
0114 <span class="comment">%      prior_data = { 32.1, 10*ones(10,1) };</span>
0115 <span class="comment">%      elem_prior = {'conductivity', 'movement'};</span>
0116 <span class="comment">%      elem_len = { 20001, 10 };</span>
0117 <span class="comment">%   elem_prior                (default 'conductivity')</span>
0118 <span class="comment">%    Input 'prior_data' type; immediately converted to</span>
0119 <span class="comment">%    'elem_working' type before first iteration.</span>
0120 <span class="comment">%   elem_working              (default 'conductivity')</span>
0121 <span class="comment">%   elem_output               (default 'conductivity')</span>
0122 <span class="comment">%    The working and output units for 'elem_data'.</span>
0123 <span class="comment">%    Valid types are 'conductivity' and 'resistivity'</span>
0124 <span class="comment">%    as plain units or with the prefix 'log_' or</span>
0125 <span class="comment">%    'log10_'. Conversions are handled internally.</span>
0126 <span class="comment">%    Scaling factors are applied to the Jacobian</span>
0127 <span class="comment">%    (calculated in units of 'conductivity') as</span>
0128 <span class="comment">%    appropriate.</span>
0129 <span class="comment">%    If elem_working == elem_output, then no</span>
0130 <span class="comment">%    conversions take place.</span>
0131 <span class="comment">%    For multiple types, use cell array.</span>
0132 <span class="comment">%    ex: elem_output = {'log_resistivity', 'movement'}</span>
0133 <span class="comment">%   meas_input                     (default 'voltage')</span>
0134 <span class="comment">%   meas_working                   (default 'voltage')</span>
0135 <span class="comment">%    Similarly to elem_working/output, conversion</span>
0136 <span class="comment">%    between 'voltage' and 'apparent_resistivity' and</span>
0137 <span class="comment">%    their log/log10 variants are handled internally.</span>
0138 <span class="comment">%    If meas_input == meas_working no conversions take</span>
0139 <span class="comment">%    place. The normalization factor 'N' is calculated</span>
0140 <span class="comment">%    if 'apparent_resistivity' is used.</span>
0141 <span class="comment">%   update_img_func             (default: pass-through)</span>
0142 <span class="comment">%    Called prior to calc_jacobian and update_dv.</span>
0143 <span class="comment">%    Elements are converted to their &quot;base types&quot;</span>
0144 <span class="comment">%    before this function is called. For example,</span>
0145 <span class="comment">%    'log_resistivity' becomes 'conductivity'.</span>
0146 <span class="comment">%    It is a hook to allow additional updates to the</span>
0147 <span class="comment">%    model before the Jacobian, or a new set of</span>
0148 <span class="comment">%    measurements are calculated via fwd_solve.</span>
0149 <span class="comment">%   return_working_variables               (default: 0)</span>
0150 <span class="comment">%    If 1, return the last working variables to the user</span>
0151 <span class="comment">%     img.inv_solve_{type}.J   Jacobian</span>
0152 <span class="comment">%     img.inv_solve_{type}.dx  descent direction</span>
0153 <span class="comment">%     img.inv_solve_{type}.sx  search direction</span>
0154 <span class="comment">%     img.inv_solve_{type}.alpha  line search result</span>
0155 <span class="comment">%     img.inv_solve_{type}.beta   conjugation parameter</span>
0156 <span class="comment">%     img.inv_solve_{type}.r   as:</span>
0157 <span class="comment">%       [ residual, measurement misfit, element misfit ]</span>
0158 <span class="comment">%       with one row per iteration</span>
0159 <span class="comment">%   show_fem                       (default: @show_fem)</span>
0160 <span class="comment">%    Function with which to plot each iteration's</span>
0161 <span class="comment">%    current parameters.</span>
0162 <span class="comment">%</span>
0163 <span class="comment">%   Signature for residual_func</span>
0164 <span class="comment">%    [r,m,e] = f(dv, de, W, hps2RtR, hpt2LLt)</span>
0165 <span class="comment">%   where</span>
0166 <span class="comment">%    r   - the residual = m + e</span>
0167 <span class="comment">%    m   - measurement error</span>
0168 <span class="comment">%    e   - prior misfit</span>
0169 <span class="comment">%    dv  - change in voltage</span>
0170 <span class="comment">%    de  - change in image elements</span>
0171 <span class="comment">%    W   - measurement inverse covariance matrix</span>
0172 <span class="comment">%    hps2  - spatial hyperparameter squared, see CALC_HYPERPARAMETER</span>
0173 <span class="comment">%    RtR   - regularization matrix squared --&gt; hps2RtR = hps2*RtR</span>
0174 <span class="comment">%    hpt2  - temporal hyperparameter squared</span>
0175 <span class="comment">%    LLt   - temporal regularization matrix squared --&gt; hpt2LLt = hpt2*LLt</span>
0176 <span class="comment">%</span>
0177 <span class="comment">%   Signature for line_optimize_func</span>
0178 <span class="comment">%    [alpha, img, dv, opt] = f(img, sx, data0, img0, N, W, hps2RtR, hpt2LLt, dv, opt)</span>
0179 <span class="comment">%   where:</span>
0180 <span class="comment">%    alpha - line search result</span>
0181 <span class="comment">%    img   - the current image</span>
0182 <span class="comment">%            (optional, recalculated if not available)</span>
0183 <span class="comment">%    sx    - the search direction to which alpha should be applied</span>
0184 <span class="comment">%    data0 - the true measurements     (dv = N*data - N*data0)</span>
0185 <span class="comment">%    img0  - the image background (de = img - img0)</span>
0186 <span class="comment">%    N     - a measurement normalization factor, N*dv</span>
0187 <span class="comment">%    W     - measurement inverse covariance matrix</span>
0188 <span class="comment">%    hps2  - spatial hyperparameter squared, see CALC_HYPERPARAMETER</span>
0189 <span class="comment">%    RtR   - regularization matrix squared --&gt; hps2RtR = hps2*RtR</span>
0190 <span class="comment">%    hpt2  - temporal hyperparameter squared</span>
0191 <span class="comment">%    LLt   - temporal regularization matrix squared --&gt; hpt2LLt = hpt2*LLt</span>
0192 <span class="comment">%    dv    - change in voltage</span>
0193 <span class="comment">%            (optional, recalculated if not available)</span>
0194 <span class="comment">%    opt   - additional arguments, updated at each call</span>
0195 <span class="comment">%</span>
0196 <span class="comment">%   Signature for line_search_dv_func</span>
0197 <span class="comment">%    [dv, opt] = update_dv_core(img, data0, N, opt)</span>
0198 <span class="comment">%   where:</span>
0199 <span class="comment">%    dv    - change in voltage</span>
0200 <span class="comment">%    opt   - additional arguments, updated at each call</span>
0201 <span class="comment">%    data  - the estimated measurements</span>
0202 <span class="comment">%    img   - the current image</span>
0203 <span class="comment">%    data0 - the true measurements</span>
0204 <span class="comment">%    N     - a measurement normalization factor, N*dv</span>
0205 <span class="comment">%</span>
0206 <span class="comment">%   Signature for line_search_de_func</span>
0207 <span class="comment">%    de = f(img, img0, opt)</span>
0208 <span class="comment">%   where:</span>
0209 <span class="comment">%    de    - change in image elements</span>
0210 <span class="comment">%    img   - the current image</span>
0211 <span class="comment">%    img0  - the image background (de = img - img0)</span>
0212 <span class="comment">%    opt   - additional arguments</span>
0213 <span class="comment">%</span>
0214 <span class="comment">%   Signature for calc_jacobian_scaling_func</span>
0215 <span class="comment">%    S = f(x)</span>
0216 <span class="comment">%   where:</span>
0217 <span class="comment">%    S - to be used to scale the Jacobian</span>
0218 <span class="comment">%    x - current img.elem_data in units of 'conductivity'</span>
0219 <span class="comment">%</span>
0220 <span class="comment">%   Signature for  update_img_func</span>
0221 <span class="comment">%    img2 = f(img1, opt)</span>
0222 <span class="comment">%   where</span>
0223 <span class="comment">%    img1 - an input image, the current working image</span>
0224 <span class="comment">%    img2 - a (potentially) modified version to be used</span>
0225 <span class="comment">%    for the fwd_solve/Jacobian calculations</span>
0226 <span class="comment">%</span>
0227 <span class="comment">% NOTE that the default line search is very crude. For</span>
0228 <span class="comment">% my test problems it seems to amount to an expensive grid</span>
0229 <span class="comment">% search. Much more efficient line search algorithms exist</span>
0230 <span class="comment">% and some fragments already are coded elsewhere in the</span>
0231 <span class="comment">% EIDORS code-base.</span>
0232 <span class="comment">%</span>
0233 <span class="comment">% See also: INV_SOLVE_ABS_GN, INV_SOLVE_ABS_GN_LOGC,</span>
0234 <span class="comment">%           INV_SOLVE_ABS_CG, INV_SOLVE_ABS_CG_LOGC,</span>
0235 <span class="comment">%           LINE_SEARCH_O2, LINE_SEARCH_ONM2</span>
0236 <span class="comment">%</span>
0237 <span class="comment">% (C) 2010-2016 Alistair Boyle, Nolwenn Lesparre, Andy Adler, Bartłomiej Grychtol.</span>
0238 <span class="comment">% License: GPL version 2 or version 3</span>
0239 
0240 <span class="comment">% $Id: inv_solve_core.m 5746 2018-04-27 20:56:25Z alistair_boyle $</span>
0241 
0242 <span class="comment">%--------------------------</span>
0243 <span class="comment">% UNIT_TEST?</span>
0244 <span class="keyword">if</span> ischar(inv_model) &amp;&amp; strcmp(inv_model,<span class="string">'UNIT_TEST'</span>) &amp;&amp; (nargin == 1); <a href="#_sub52" class="code" title="subfunction pass=do_unit_test(solver)">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0245 <span class="keyword">if</span> ischar(inv_model) &amp;&amp; strcmp(inv_model,<span class="string">'UNIT_TEST'</span>) &amp;&amp; (nargin == 2); <a href="#_sub52" class="code" title="subfunction pass=do_unit_test(solver)">do_unit_test</a>(data0); <span class="keyword">return</span>; <span class="keyword">end</span>
0246 
0247 <span class="comment">%--------------------------</span>
0248 <span class="keyword">if</span> nargin == 3 <span class="comment">% difference reconstruction</span>
0249    n_frames = max(<a href="#_sub2" class="code" title="subfunction n_frames = count_data_frames(data1)">count_data_frames</a>(data0),<a href="#_sub2" class="code" title="subfunction n_frames = count_data_frames(data1)">count_data_frames</a>(data1));
0250 <span class="keyword">else</span> <span class="comment">% absolute reconstruction</span>
0251    n_frames = <a href="#_sub2" class="code" title="subfunction n_frames = count_data_frames(data1)">count_data_frames</a>(data0);
0252 <span class="keyword">end</span>
0253 opt = <a href="#_sub36" class="code" title="subfunction opt = parse_options(imdl,n_frames)">parse_options</a>(inv_model, n_frames);
0254 <span class="comment">%if opt.do_starting_estimate</span>
0255 <span class="comment">%    img = initial_estimate( inv_model, data0 ); % TODO</span>
0256 <span class="comment">%%%    AB-&gt;NL this is Nolwenn's homogeneous estimate...</span>
0257 <span class="comment">%%%    calc_background_resistivity is my version of this code</span>
0258 <span class="comment">%%%    that is working for my data set</span>
0259 <span class="comment">%else</span>
0260 [inv_model, opt] = <a href="#_sub43" class="code" title="subfunction [inv_model, opt] = append_c2f_background(inv_model, opt)">append_c2f_background</a>(inv_model, opt);
0261 <span class="comment">% calc_jacobian_bkgnd, used by mk_image does not understand</span>
0262 <span class="comment">% the course-to-fine mapping and explodes when it is fed a</span>
0263 <span class="comment">% prior based on the coarse model. Here we give that</span>
0264 <span class="comment">% function something it can swallow, then create then plug</span>
0265 <span class="comment">% in the correct prior afterwards.</span>
0266 <span class="keyword">if</span> isfield(inv_model, <span class="string">'jacobian_bkgnd'</span>)
0267   inv_model = rmfield(inv_model,<span class="string">'jacobian_bkgnd'</span>);
0268 <span class="keyword">end</span>
0269 inv_model.jacobian_bkgnd.value = 1;
0270 img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( inv_model );
0271 img.inv_model = inv_model; <span class="comment">% stash the inverse model</span>
0272 img = <a href="../../../eidors/models/data_mapper.html" class="code" title="function img = data_mapper(img, reverse)">data_mapper</a>(img); <span class="comment">% move data from whatever 'params' to img.elem_data</span>
0273 
0274 <span class="comment">% insert the prior data</span>
0275 img = <a href="#_sub3" class="code" title="subfunction img = init_elem_data(img, opt)">init_elem_data</a>(img, opt);
0276 
0277 <span class="comment">% map data and measurements to working types</span>
0278 <span class="comment">%  convert elem_data</span>
0279 img = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, opt.elem_working);
0280 
0281 <span class="comment">% solve for difference data?</span>
0282 <span class="keyword">if</span> nargin == 3
0283    assert(all(~strcmp(opt.meas_working, {<span class="string">'apparent_resistivity'</span>,<span class="string">'log_apparent_resistivity'</span>, <span class="string">'log10_apparent_resitivity'</span>})), <span class="keyword">...</span>
0284           [<span class="string">'meas_working = '''</span> opt.meas_working <span class="string">''' not yet supported for difference solutions'</span>]);
0285    <span class="keyword">for</span> i = 1:length(opt.elem_output)
0286       assert(any(strcmp(opt.elem_output{i}, {<span class="string">'conductivity'</span>,<span class="string">'resistivity'</span>,<span class="string">'movement'</span>})), <span class="keyword">...</span>
0287              [<span class="string">'elem_output = {'</span> strjoin(opt.elem_output,<span class="string">', '</span>) <span class="string">'} but difference solver log normal outputs are not supported'</span>]);
0288    <span class="keyword">end</span>
0289    <span class="comment">% dv = (meas1 - meas0) + meas@backgnd</span>
0290    nil = struct;
0291    <span class="keyword">if</span> isstruct(data0)
0292       nil.meas = data0(1).meas(:,1)*0;
0293    <span class="keyword">else</span>
0294       nil.meas = data0(:,1)*0;
0295    <span class="keyword">end</span>
0296    nil.type = <span class="string">'data'</span>;
0297    nil.current_params = opt.meas_input;
0298    [dv, opt, err] = <a href="#_sub32" class="code" title="subfunction [dv, opt, err] = update_dv_core(img, data0, N, opt)">update_dv_core</a>(img, nil, 1, opt);
0299    <span class="comment">% This: data0 = calc_difference_data( data0, data1, inv_model.fwd_model) + dv*ones(1,n_frames);</span>
0300    <span class="comment">% but efficient and don't depend on n_frames:</span>
0301    data0 = bsxfun(@plus,<a href="../../../eidors/solvers/calc_difference_data.html" class="code" title="function dva = calc_difference_data( data1, data2, fwd_model)">calc_difference_data</a>( data0, data1, inv_model.fwd_model ), dv);
0302    <span class="comment">% back to our regularly scheduled progam</span>
0303    assert(strcmp(inv_model.reconst_type, <span class="string">'difference'</span>), <span class="keyword">...</span>
0304           [<span class="string">'expected inv_model.reconst_type = ''difference'' not '</span> inv_model.reconst_type]);
0305 <span class="keyword">else</span>
0306    assert(strcmp(inv_model.reconst_type, <span class="string">'absolute'</span>), <span class="keyword">...</span>
0307           [<span class="string">'expected inv_model.reconst_type = ''absolute'' not '</span> inv_model.reconst_type]);
0308 <span class="keyword">end</span>
0309 
0310 <span class="comment">%  convert measurement data</span>
0311 <span class="keyword">if</span> ~isstruct(data0)
0312    d = data0;
0313    data0 = struct;
0314    data0.meas = d;
0315    data0.type = <span class="string">'data'</span>;
0316 <span class="keyword">end</span>
0317 data0.current_params = opt.meas_input;
0318 
0319 <span class="comment">% precalculate some of our matrices if required</span>
0320 W  = <a href="#_sub4" class="code" title="subfunction W = init_meas_icov(inv_model, opt)">init_meas_icov</a>(inv_model, opt);
0321 [N, dN] = <a href="#_sub5" class="code" title="subfunction [N, dN] = init_normalization(fmdl, data0, opt)">init_normalization</a>(inv_model.fwd_model, data0, opt);
0322 
0323 <span class="comment">% now get on with</span>
0324 img0 = img;
0325 hps2RtR = 0; alpha = 0; k = 0; sx = 0; r = 0; stop = 0; <span class="comment">% general init</span>
0326 hpt2LLt = <a href="#_sub10" class="code" title="subfunction hpt2LLt = update_hpt2LLt(inv_model, data0, k, opt)">update_hpt2LLt</a>(inv_model, data0, k, opt);
0327 residuals = zeros(opt.max_iterations,3); <span class="comment">% for residuals plots</span>
0328 dxp = 0; <span class="comment">% previous step's slope was... nothing</span>
0329 [dv, opt] = <a href="#_sub30" class="code" title="subfunction [dv, opt] = update_dv(dv, img, data0, N, opt, reason)">update_dv</a>([], img, data0, N, opt);
0330 de = <a href="#_sub29" class="code" title="subfunction  de = update_de(de, img, img0, opt)">update_de</a>([], img, img0, opt);
0331 <span class="keyword">if</span> opt.verbose &gt;= 5 <span class="comment">% we only save the measurements at each iteration if we are being verbose</span>
0332   dvall = ones(size(data0.meas,1),opt.max_iterations+1)*NaN;
0333 <span class="keyword">end</span>
0334 <span class="keyword">while</span> 1
0335   <span class="keyword">if</span> opt.verbose &gt;= 1
0336      <span class="keyword">if</span> k == 0
0337         fprintf(<span class="string">'  inv_solve_core: start up\n'</span>);
0338      <span class="keyword">else</span>
0339         fprintf(<span class="string">'  inv_solve_core: iteration %d (residual = %g)\n'</span>, k, r(k,1));
0340      <span class="keyword">end</span>
0341   <span class="keyword">end</span>
0342 
0343   <span class="comment">% calculate the Jacobian</span>
0344   <span class="comment">%  - Jacobian before RtR because it is needed for Noser prior</span>
0345   [J, opt] = <a href="#_sub14" class="code" title="subfunction [J, opt] = update_jacobian(img, dN, k, opt)">update_jacobian</a>(img, dN, k, opt);
0346 
0347   <span class="comment">% update RtR, if required (depends on prior)</span>
0348   hps2RtR = <a href="#_sub9" class="code" title="subfunction hps2RtR = update_hps2RtR(inv_model, J, k, img, opt)">update_hps2RtR</a>(inv_model, J, k, img, opt);
0349 
0350   <span class="comment">% determine the next search direction sx</span>
0351   <span class="comment">%  dx is specific to the algorithm, generally &quot;downhill&quot;</span>
0352   dx = <a href="#_sub38" class="code" title="subfunction dx = update_dx(J, W, hps2RtR, hpt2LLt, dv, de, opt)">update_dx</a>(J, W, hps2RtR, hpt2LLt, dv, de, opt);
0353   <span class="comment">% choose beta, beta=0 unless doing Conjugate Gradient</span>
0354   beta = <a href="#_sub7" class="code" title="subfunction beta = update_beta(dx_k, dx_km1, sx_km1, opt);">update_beta</a>(dx, dxp, sx, opt);
0355   beta_all(k+1)=beta; <span class="comment">% save for debug</span>
0356   <span class="comment">% sx_k = dx_k + beta * sx_{k-1}</span>
0357   sx = <a href="#_sub8" class="code" title="subfunction sx = update_sx(dx, beta, sx_km1, opt);">update_sx</a>(dx, beta, sx, opt);
0358   <span class="keyword">if</span> k ~= 0
0359      dxp = dx; <span class="comment">% saved for next iteration if using beta</span>
0360   <span class="keyword">end</span>
0361 
0362   <span class="comment">% plot dx and SVD of Jacobian (before and after regularization)</span>
0363   <a href="#_sub11" class="code" title="subfunction plot_dx_and_svd_elem(J, W, hps2RtR, k, sx, dx, img, opt)">plot_dx_and_svd_elem</a>(J, W, hps2RtR, k, sx, dx, img, opt);
0364 
0365   <span class="comment">% line search for alpha, leaving the final selection as img</span>
0366   <span class="comment">% x_n = img.elem_data</span>
0367   <span class="comment">% x_{n+1} = x_n + \alpha sx</span>
0368   <span class="comment">% img.elem_data = x_{n+1}</span>
0369   [alpha, img, dv, opt] = <a href="#_sub26" class="code" title="subfunction [alpha, img, dv, opt] = update_alpha(img, sx, data0, img0, N, W, hps2RtR, hpt2LLt, k, dv, opt)">update_alpha</a>(img, sx, data0, img0, N, W, hps2RtR, hpt2LLt, k, dv, opt);
0370   alpha_all(k+1) = alpha;
0371   <span class="comment">% fix max/min values for x, clears dx if limits are hit, where</span>
0372   <span class="comment">% a cleared dv will trigger a recalculation of dv at the next update_dv()</span>
0373   [img, dv] = <a href="#_sub28" class="code" title="subfunction [img, dv] = update_img_using_limits(img, img0, data0, N, dv, opt)">update_img_using_limits</a>(img, img0, data0, N, dv, opt);
0374 
0375   <span class="comment">% update change in element data from the prior de and</span>
0376   <span class="comment">% the measurement error dv</span>
0377   [dv, opt] = <a href="#_sub30" class="code" title="subfunction [dv, opt] = update_dv(dv, img, data0, N, opt, reason)">update_dv</a>(dv, img, data0, N, opt);
0378   de = <a href="#_sub29" class="code" title="subfunction  de = update_de(de, img, img0, opt)">update_de</a>(de, img, img0, opt);
0379   <span class="keyword">if</span> opt.verbose &gt;= 5
0380     dvall(:,k+1) = dv;
0381     <a href="#_sub1" class="code" title="subfunction show_meas_err(dvall, data0, k, N, W, opt)">show_meas_err</a>(dvall, data0, k, N, W, opt);
0382   <span class="keyword">end</span>
0383   <a href="#_sub33" class="code" title="subfunction show_fem_iter(k, img, inv_model, stop, opt)">show_fem_iter</a>(k, img, inv_model, stop, opt);
0384 
0385   <span class="comment">% now find the residual, quit if we're done</span>
0386   [stop, k, r, img] = <a href="#_sub6" class="code" title="subfunction [stop, k, r, img] = update_residual(dv, img, de, W, hps2RtR, hpt2LLt, k, r, alpha, sx, opt)">update_residual</a>(dv, img, de, W, hps2RtR, hpt2LLt, k, r, alpha, sx, opt);
0387   <span class="keyword">if</span> stop
0388      <span class="keyword">if</span> stop == -1
0389         alpha_all(k) = 0;
0390      <span class="keyword">end</span>
0391      <span class="keyword">break</span>;
0392   <span class="keyword">end</span>
0393 <span class="keyword">end</span>
0394 [img, opt] = <a href="#_sub44" class="code" title="subfunction [img, opt] = strip_c2f_background(img, opt, indent)">strip_c2f_background</a>(img, opt);
0395 <span class="comment">% check we're returning the right size of data</span>
0396 <span class="keyword">if</span> isfield(inv_model, <span class="string">'rec_model'</span>)
0397   img.fwd_model = inv_model.rec_model;
0398 <span class="keyword">end</span>
0399 <span class="keyword">if</span> opt.verbose &gt;= 1
0400    <span class="keyword">if</span> k==1; itrs=<span class="string">''</span>; <span class="keyword">else</span> itrs=<span class="string">'s'</span>; <span class="keyword">end</span>
0401    fprintf(<span class="string">'  %d fwd_solves required for this solution in %d iteration%s\n'</span>, <span class="keyword">...</span>
0402            opt.fwd_solutions, k, itrs);
0403 <span class="keyword">end</span>
0404 <span class="comment">% convert data for output</span>
0405 img = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, opt.elem_output);
0406 <span class="keyword">if</span> strcmp(inv_model.reconst_type, <span class="string">'difference'</span>)
0407    img0 = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img0, opt.elem_output);
0408    img.elem_data = img.elem_data - img0.elem_data;
0409 <span class="keyword">end</span>
0410 img.meas_err = dv;
0411 <span class="keyword">if</span> opt.return_working_variables
0412   img.inv_solve_core.J = J;
0413   img.inv_solve_core.dx = dx;
0414   img.inv_solve_core.sx = sx;
0415   img.inv_solve_core.alpha = alpha_all;
0416   img.inv_solve_core.beta = beta_all;
0417   img.inv_solve_core.k = k;
0418   img.inv_solve_core.r = r(1:(k+1),:); <span class="comment">% trim r to n-iterations' rows</span>
0419   img.inv_solve_core.N = N;
0420   img.inv_solve_core.W = W;
0421   img.inv_solve_core.hps2RtR = hps2RtR;
0422   img.inv_solve_core.dv = dv;
0423   img.inv_solve_core.de = de;
0424   <span class="keyword">if</span> opt.verbose &gt;= 5
0425     img.inv_solve_core.dvall = dvall;
0426   <span class="keyword">end</span>
0427 <span class="keyword">end</span>
0428 <span class="comment">%img = data_mapper(img, 1); % move data from img.elem_data to whatever 'params'</span>
0429 
0430 <a name="_sub1" href="#_subfunctions" class="code">function show_meas_err(dvall, data0, k, N, W, opt)</a>
0431    clf;
0432    assert(length(opt.meas_working) == 1,<span class="string">'TODO meas_working len &gt; 1'</span>);
0433    subplot(211); bar(dvall(:,k+1)); ylabel(sprintf(<span class="string">'dv_k [%s]'</span>,opt.meas_working{1})); xlabel(<span class="string">'meas #'</span>); title(sprintf(<span class="string">'measurement error @ iter=%d'</span>,k));
0434    subplot(212); bar(<a href="#_sub50" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(dvall(:,k+1),N,opt.meas_working{1}, <span class="string">'voltage'</span>)); ylabel(<span class="string">'dv_k [V]'</span>); xlabel(<span class="string">'meas #'</span>); title(<span class="string">''</span>);
0435    drawnow;
0436    <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
0437       print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-meas_err%d'</span>,opt.fig_prefix,k));
0438       print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-meas_err%d'</span>,opt.fig_prefix,k));
0439       saveas(gcf,sprintf(<span class="string">'%s-meas_err%d.fig'</span>,opt.fig_prefix,k));
0440    <span class="keyword">end</span>
0441    drawnow;
0442 
0443 <span class="comment">% count_data_frames() needs to agree with calc_difference_data behaviour!</span>
0444 <a name="_sub2" href="#_subfunctions" class="code">function n_frames = count_data_frames(data1)</a>
0445    <span class="keyword">if</span> isnumeric(data1)
0446       n_frames = size(data1,2);
0447    <span class="keyword">else</span>
0448       n_frames = size(horzcat(data1(:).meas),2);
0449    <span class="keyword">end</span>
0450 
0451 <a name="_sub3" href="#_subfunctions" class="code">function img = init_elem_data(img, opt)</a>
0452   <span class="keyword">if</span> opt.verbose &gt; 1
0453     fprintf(<span class="string">'  setting prior elem_data\n'</span>);
0454   <span class="keyword">end</span>
0455   ne2 = 0; <span class="comment">% init</span>
0456   img.elem_data = zeros(sum([opt.elem_len{:}]),sum([opt.n_frames{:}])); <span class="comment">% preallocate</span>
0457   <span class="keyword">for</span> i=1:length(opt.elem_prior)
0458     ne1 = ne2+1; <span class="comment">% next start idx ne1</span>
0459     ne2 = ne1+opt.elem_len{i}-1; <span class="comment">% this set ends at idx ne2</span>
0460     <span class="keyword">if</span> opt.verbose &gt; 1
0461       <span class="keyword">if</span> length(opt.prior_data{i}) == 1
0462         fprintf(<span class="string">'    %d x %s: %0.1f\n'</span>,opt.elem_len{i},opt.elem_prior{i}, opt.prior_data{i});
0463       <span class="keyword">else</span>
0464         fprintf(<span class="string">'    %d x %s: ...\n'</span>,opt.elem_len{i},opt.elem_prior{i});
0465         <span class="keyword">if</span> length(opt.prior_data{i}) ~= opt.elem_len{i}
0466            error(sprintf(<span class="string">'expected %d elem, got %d elem in elem_prior'</span>, <span class="keyword">...</span>
0467                          opt.elem_len{i}, length(opt.prior_data{i})));
0468         <span class="keyword">end</span>
0469       <span class="keyword">end</span>
0470     <span class="keyword">end</span>
0471     img.params_sel(i) = {ne1:ne2};
0472     img.elem_data(img.params_sel{i},:) = opt.prior_data{i};
0473   <span class="keyword">end</span>
0474   img.current_params = opt.elem_prior;
0475 
0476 <a name="_sub4" href="#_subfunctions" class="code">function W = init_meas_icov(inv_model, opt)</a>
0477    W = 1;
0478    <span class="keyword">if</span> opt.calc_meas_icov
0479       <span class="keyword">if</span> opt.verbose &gt; 1
0480          disp(<span class="string">'  calc measurement inverse covariance W'</span>);
0481       <span class="keyword">end</span>
0482       W   = <a href="../../../eidors/solvers/calc_meas_icov.html" class="code" title="function meas_icov = calc_meas_icov( inv_model )">calc_meas_icov</a>( inv_model );
0483    <span class="keyword">end</span>
0484    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(W, <span class="string">'init_meas_icov'</span>);
0485 
0486 <a name="_sub5" href="#_subfunctions" class="code">function [N, dN] = init_normalization(fmdl, data0, opt)</a>
0487    <span class="comment">% precalculate the normalization of the data if required (apparent resistivity)</span>
0488    N = 1;
0489    dN = 1;
0490    vh1.meas = 1;
0491    <span class="keyword">if</span> ~iscell(opt.meas_input) || ~iscell(opt.meas_working)
0492       error(<span class="string">'expected cell array for meas_input and meas_working'</span>);
0493    <span class="keyword">end</span>
0494    <span class="comment">% TODO support for multiple measurement types</span>
0495    assert(length(opt.meas_input) == length(opt.meas_working), <span class="string">'meas_input and meas_working lengths must match'</span>);
0496    assert(length(opt.meas_working) == 1, <span class="string">'TODO only supports a single type of measurements'</span>);
0497    go =       any(strcmp({opt.meas_input{1}, opt.meas_working{1}},<span class="string">'apparent_resistivity'</span>));
0498    go = go || any(strcmp({opt.meas_input{1}, opt.meas_working{1}},<span class="string">'log_apparent_resistivity'</span>));
0499    go = go || any(strcmp({opt.meas_input{1}, opt.meas_working{1}},<span class="string">'log10_apparent_resistivity'</span>));
0500    <span class="keyword">if</span> go
0501       <span class="keyword">if</span> opt.verbose &gt; 1
0502          disp([<span class="string">'  calc measurement normalization matrix N (voltage -&gt; '</span> opt.meas_working{1} <span class="string">')'</span>]);
0503       <span class="keyword">end</span>
0504       <span class="comment">% calculate geometric factor for apparent_resitivity conversions</span>
0505       img1 = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(fmdl,1);
0506       vh1  = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(img1);
0507       N    = <a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(1./vh1.meas);
0508       <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(N,  <span class="string">'init_normalization: N'</span>);
0509    <span class="keyword">end</span>
0510    <span class="keyword">if</span> go &amp;&amp; (opt.verbose &gt; 1)
0511       disp([<span class="string">'  calc Jacobian normalization matrix   dN (voltage -&gt; '</span> opt.meas_working{1} <span class="string">')'</span>]);
0512    <span class="keyword">end</span>
0513    <span class="comment">% calculate the normalization factor for the Jacobian</span>
0514    assert(length(opt.meas_working)==1, <span class="string">'only supports single measurement type at a time'</span>);
0515    data0 = <a href="#_sub31" class="code" title="subfunction data = map_meas_struct(data, N, out)">map_meas_struct</a>(data0, N, <span class="string">'voltage'</span>); <span class="comment">% to voltage</span>
0516    <span class="keyword">switch</span> opt.meas_working{1}
0517       <span class="keyword">case</span> <span class="string">'apparent_resistivity'</span>
0518          dN = <a href="#_sub20" class="code" title="subfunction dN = da_dv(v,vh)">da_dv</a>(data0.meas, vh1.meas);
0519       <span class="keyword">case</span> <span class="string">'log_apparent_resistivity'</span>
0520          dN = <a href="#_sub21" class="code" title="subfunction dN = dloga_dv(v,vh)">dloga_dv</a>(data0.meas, vh1.meas);
0521       <span class="keyword">case</span> <span class="string">'log10_apparent_resistivity'</span>
0522          dN = <a href="#_sub22" class="code" title="subfunction dN = dlog10a_dv(v,vh)">dlog10a_dv</a>(data0.meas, vh1.meas);
0523       <span class="keyword">case</span> <span class="string">'voltage'</span>
0524          dN = <a href="#_sub23" class="code" title="subfunction dN = dv_dv(v,vh)">dv_dv</a>(data0.meas, vh1.meas);
0525       <span class="keyword">case</span> <span class="string">'log_voltage'</span>
0526          dN = <a href="#_sub24" class="code" title="subfunction dN = dlogv_dv(v,vh) ">dlogv_dv</a>(data0.meas, vh1.meas);
0527       <span class="keyword">case</span> <span class="string">'log10_voltage'</span>
0528          dN = <a href="#_sub25" class="code" title="subfunction dN = dlog10v_dv(v,vh) ">dlog10v_dv</a>(data0.meas, vh1.meas);
0529       <span class="keyword">otherwise</span>
0530          error(<span class="string">'hmm'</span>);
0531    <span class="keyword">end</span>
0532    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(dN, <span class="string">'init_normalization: dN'</span>);
0533 
0534 <span class="comment">% r_km1: previous residual, if its the first iteration r_km1 = inf</span>
0535 <span class="comment">% r_k: new residual</span>
0536 <a name="_sub6" href="#_subfunctions" class="code">function [stop, k, r, img] = update_residual(dv, img, de, W, hps2RtR, hpt2LLt, k, r, alpha, sx, opt)</a>
0537   stop = 0;
0538 
0539   <span class="comment">% update residual estimate</span>
0540   <span class="keyword">if</span> k == 0
0541      r = ones(opt.max_iterations, 3)*NaN;
0542      r_km1 = inf;
0543      r_1   = inf;
0544   <span class="keyword">else</span>
0545      r_km1 = r(k, 1);
0546      r_1   = r(1, 1);
0547   <span class="keyword">end</span>
0548   [r_k m_k e_k] = feval(opt.residual_func, dv, de, W, hps2RtR, hpt2LLt);
0549   <span class="comment">% save residual for next iteration</span>
0550   r(k+1,1:3) = [r_k m_k e_k];
0551 
0552   <span class="comment">% now do something with that information</span>
0553   <span class="keyword">if</span> opt.verbose &gt; 1
0554      fprintf(<span class="string">'    calc residual\n'</span>);
0555      <span class="keyword">if</span> k == 0
0556         fprintf(<span class="string">'    stop @ max iter = %d, tol = %0.3g (%0.3g%%), dtol = %0.3g%% (after %d iter)\n'</span>, <span class="keyword">...</span>
0557                 opt.max_iterations, opt.tol, opt.tol/r_k*100, opt.dtol*100, opt.dtol_iter);
0558         fprintf(<span class="string">'      r =%0.3g = %0.3g meas + %0.3g elem\n'</span>, r_k, m_k, e_k);
0559      <span class="keyword">else</span>
0560         fprintf(<span class="string">'      r =%0.3g (%0.03g%%) = %0.3g meas (%0.03g%%) + %0.3g elem (%0.3g%%)\n'</span>, <span class="keyword">...</span>
0561                 r_k, r_k/r(1,1)*100, m_k, m_k/r(1,2)*100, e_k, e_k/r(1,3)*100);
0562         dr = (r_k - r_km1);
0563         fprintf(<span class="string">'      dr=%0.3g (%0.3g%%)\n'</span>, dr, dr/r_1*100);
0564      <span class="keyword">end</span>
0565   <span class="keyword">end</span>
0566   <span class="keyword">if</span> opt.plot_residuals
0567      <span class="comment">%         optimization_criteria, data misfit, roughness</span>
0568      r(k+1,2:3) = [sum(sum(dv.^2,1))/2 sum(sum(de.^2,1))/2];
0569      <span class="keyword">if</span> k &gt; 0
0570         clf;
0571         x = 1:(k+1);
0572         y = r(x, :);
0573         y = y ./ repmat(max(y,[],1),size(y,1),1) * 100;
0574         plot(x-1, y, <span class="string">'o-'</span>, <span class="string">'linewidth'</span>, 2, <span class="string">'MarkerSize'</span>, 10);
0575         title(<span class="string">'residuals'</span>);
0576         axis tight;
0577         ylabel(<span class="string">'residual (% of max)'</span>);
0578         xlabel(<span class="string">'iteration'</span>);
0579         set(gca, <span class="string">'xtick'</span>, x);
0580         set(gca, <span class="string">'xlim'</span>, [0 max(x)-1]);
0581         legend(<span class="string">'residual'</span>,<span class="string">'meas. misfit'</span>,<span class="string">'prior misfit'</span>);
0582         legend(<span class="string">'Location'</span>, <span class="string">'EastOutside'</span>);
0583         drawnow;
0584         <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
0585            print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-r'</span>,opt.fig_prefix));
0586            print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-r'</span>,opt.fig_prefix));
0587            saveas(gcf,sprintf(<span class="string">'%s-r.fig'</span>,opt.fig_prefix));
0588         <span class="keyword">end</span>
0589      <span class="keyword">end</span>
0590   <span class="keyword">end</span>
0591 
0592   <span class="comment">% evaluate stopping criteria</span>
0593   <span class="keyword">if</span> r_k &gt; r_km1 <span class="comment">% bad step</span>
0594      <span class="keyword">if</span> opt.verbose &gt; 1
0595         fprintf(<span class="string">'  terminated at iteration %d (bad step, returning previous iteration''s result)\n'</span>,k);
0596      <span class="keyword">end</span>
0597      img.elem_data = img.elem_data - alpha * sx; <span class="comment">% undo the last step</span>
0598      stop = -1;
0599   <span class="keyword">elseif</span> k &gt;= opt.max_iterations
0600      <span class="keyword">if</span> opt.verbose &gt; 1
0601         fprintf(<span class="string">'  terminated at iteration %d (max iterations)\n'</span>,k);
0602      <span class="keyword">end</span>
0603      stop = 1;
0604   <span class="keyword">elseif</span> r_k &lt; opt.tol + opt.ntol
0605      <span class="keyword">if</span> opt.verbose &gt; 1
0606         fprintf(<span class="string">'  terminated at iteration %d\n'</span>,k);
0607         fprintf(<span class="string">'    residual tolerance (%0.3g) achieved\n'</span>, opt.tol + opt.ntol);
0608      <span class="keyword">end</span>
0609      stop = 1;
0610   <span class="keyword">elseif</span> (k &gt;= opt.dtol_iter) &amp;&amp; ((r_k - r_km1)/r_1 &gt; opt.dtol - 2*opt.ntol)
0611      <span class="keyword">if</span> opt.verbose &gt; 1
0612         fprintf(<span class="string">'  terminated at iteration %d (iterations not improving)\n'</span>, k);
0613         fprintf(<span class="string">'    residual slope tolerance (%0.3g%%) exceeded\n'</span>, (opt.dtol - 2*opt.ntol)*100);
0614      <span class="keyword">end</span>
0615      stop = 1;
0616   <span class="keyword">end</span>
0617   <span class="keyword">if</span> ~stop
0618      <span class="comment">% update iteration count</span>
0619      k = k+1;
0620   <span class="keyword">end</span>
0621 
0622 <span class="comment">% for Conjugate Gradient, else beta = 0</span>
0623 <span class="comment">%  dx_k, dx_{k-1}, sx_{k-1}</span>
0624 <a name="_sub7" href="#_subfunctions" class="code">function beta = update_beta(dx_k, dx_km1, sx_km1, opt);</a>
0625    <span class="keyword">if</span> isfield(opt, <span class="string">'beta_func'</span>)
0626       <span class="keyword">if</span> opt.verbose &gt; 1
0627          <span class="keyword">try</span> beta_str = func2str(opt.beta_func);
0628          <span class="keyword">catch</span>
0629             <span class="keyword">try</span>
0630                 beta_str = opt.beta_func;
0631             <span class="keyword">catch</span>
0632                 beta_str = <span class="string">'unknown'</span>;
0633             <span class="keyword">end</span>
0634          <span class="keyword">end</span>
0635       <span class="keyword">end</span>
0636       beta= feval(opt.beta_func, dx_k, dx_km1, sx_km1);
0637    <span class="keyword">else</span>
0638      beta_str = <span class="string">'&lt;none&gt;'</span>;
0639      beta = 0;
0640    <span class="keyword">end</span>
0641    <span class="keyword">if</span> opt.verbose &gt; 1
0642       str = sprintf(<span class="string">'    calc beta (%s)=%0.3f\n'</span>, beta_str, beta);
0643    <span class="keyword">end</span>
0644 
0645 <span class="comment">% update the search direction</span>
0646 <span class="comment">% for Gauss-Newton</span>
0647 <span class="comment">%   sx_k = dx_k</span>
0648 <span class="comment">% for Conjugate-Gradient</span>
0649 <span class="comment">%   sx_k = dx_k + beta * sx_{k-1}</span>
0650 <a name="_sub8" href="#_subfunctions" class="code">function sx = update_sx(dx, beta, sx_km1, opt);</a>
0651    sx = dx + beta * sx_km1;
0652    <span class="keyword">if</span>(opt.verbose &gt; 1)
0653       nsx = norm(sx);
0654       nsxk = norm(sx_km1);
0655       fprintf( <span class="string">'    update step dx, beta=%0.3g, ||dx||=%0.3g\n'</span>, beta, nsx);
0656       <span class="keyword">if</span> nsxk ~= 0
0657          fprintf( <span class="string">'      acceleration     d||dx||=%0.3g\n'</span>, nsx-nsxk);
0658          <span class="comment">% ||ddx|| = chord_len = 2 sin(theta/2)</span>
0659          ddx = norm(sx/nsx-sx_km1/nsxk);
0660          fprintf( <span class="string">'      direction change ||ddx||=%0.3g (%0.3g°)\n'</span>, ddx, 2*asind(ddx/2));
0661       <span class="keyword">end</span>
0662    <span class="keyword">end</span>
0663 
0664 <span class="comment">% this function constructs the blockwise RtR spatial regularization matrix</span>
0665 <a name="_sub9" href="#_subfunctions" class="code">function hps2RtR = update_hps2RtR(inv_model, J, k, img, opt)</a>
0666    <span class="keyword">if</span> k==0 <span class="comment">% first the start up iteration use the initial hyperparameter</span>
0667       k=1;
0668    <span class="keyword">end</span>
0669    <span class="comment">% TODO sometimes (with Noser?) this requires the Jacobian, could this be done more efficiently?</span>
0670    <span class="comment">% add a test function to determine if img.elem_data affects RtR, skip this if independant</span>
0671    <span class="comment">% TODO we could detect in the opt_parsing whether the calc_RtR_prior depends on 'x' and skip this if no</span>
0672    <span class="keyword">if</span> ~opt.calc_RtR_prior
0673       error(<span class="string">'no RtR calculation mechanism, set imdl.inv_solve_core.RtR_prior or imdl.RtR_prior'</span>);
0674    <span class="keyword">end</span>
0675    <span class="keyword">if</span> opt.verbose &gt; 1
0676       disp(<span class="string">'    calc hp^2 R^t R'</span>);
0677    <span class="keyword">end</span>
0678    hp2 = <a href="../../../eidors/solvers/calc_hyperparameter.html" class="code" title="function hyperparameter = calc_hyperparameter( inv_model )">calc_hyperparameter</a>( inv_model )^2; <span class="comment">% = \lambda^2</span>
0679    net = sum([opt.elem_len{:}]); <span class="comment">% Number of Elements, Total</span>
0680    RtR = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(net,net); <span class="comment">% init RtR = sparse(zeros(net,net));</span>
0681    esi = 0; eei = 0; <span class="comment">% element start, element end</span>
0682    <span class="keyword">for</span> i = 1:size(opt.RtR_prior,1) <span class="comment">% row i</span>
0683       esi = eei + 1;
0684       eei = eei + opt.elem_len{i};
0685       esj = 0; eej = 0; <span class="comment">% element start, element end</span>
0686       <span class="keyword">for</span> j = 1:size(opt.RtR_prior,2) <span class="comment">% column j</span>
0687          esj = eej + 1;
0688          eej = eej + opt.elem_len{j};
0689          <span class="keyword">if</span> isempty(opt.RtR_prior{i,j}) <span class="comment">% null entries</span>
0690             <span class="keyword">continue</span>; <span class="comment">% no need to explicitly create zero block matrices</span>
0691          <span class="keyword">end</span>
0692 
0693          <span class="comment">% select a hyperparameter, potentially, per iteration</span>
0694          <span class="comment">% if we're at the end of the list, select the last entry</span>
0695          hp=opt.hyperparameter_spatial{i,j};
0696          <span class="keyword">if</span> length(hp) &gt; k
0697             hp=hp(k);
0698          <span class="keyword">else</span>
0699             hp=hp(end);
0700          <span class="keyword">end</span>
0701 
0702          <span class="keyword">try</span> RtR_str = func2str(opt.RtR_prior{i,j});
0703          <span class="keyword">catch</span>
0704             <span class="keyword">try</span>
0705                 RtR_str = opt.RtR_prior{i,j};
0706             <span class="keyword">catch</span>
0707                 RtR_str = <span class="string">'unknown'</span>;
0708             <span class="keyword">end</span>
0709          <span class="keyword">end</span>
0710          <span class="keyword">if</span> opt.verbose &gt; 1
0711             fprintf(<span class="string">'      {%d,%d} regularization RtR (%s), ne=%dx%d, hp=%0.4g\n'</span>, i,j,RtR_str,eei-esi+1,eej-esj+1,hp*sqrt(hp2));
0712          <span class="keyword">end</span>
0713          imgt = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, opt.elem_working{i});
0714          inv_modelt = inv_model;
0715          inv_modelt.RtR_prior = opt.RtR_prior{i,j};
0716          <span class="keyword">if</span> strcmp(RtR_str, <span class="string">'prior_noser'</span>) <span class="comment">% intercept prior_noser: we already have the Jacobian calculated</span>
0717             <span class="keyword">if</span> i ~= j
0718                error(<span class="string">'noser for off diagonal prior (RtR) is undefined'</span>)
0719             <span class="keyword">end</span>
0720             exponent= 0.5; <span class="keyword">try</span> exponent = inv_model.prior_noser.exponent; <span class="keyword">end</span>; <span class="keyword">try</span> exponent = inv_model.prior_noser.exponent{j}; <span class="keyword">end</span>
0721             ss = sum(J(:,esj:eej).^2,1)';
0722             Reg = spdiags( ss.^exponent, 0, opt.elem_len{j}, opt.elem_len{j}); <span class="comment">% = diag(J'*J)^0.5</span>
0723             RtR(esi:eei, esj:eej) = hp.^2 * Reg;
0724          <span class="keyword">else</span>
0725             RtR(esi:eei, esj:eej) = hp.^2 * <a href="#_sub13" class="code" title="subfunction RtR = calc_RtR_prior_wrapper(inv_model, img, opt)">calc_RtR_prior_wrapper</a>(inv_modelt, imgt, opt);
0726          <span class="keyword">end</span>
0727       <span class="keyword">end</span>
0728    <span class="keyword">end</span>
0729    hps2RtR = hp2*RtR;
0730 
0731 <span class="comment">% this function constructs the LLt temporal regularization matrix</span>
0732 <a name="_sub10" href="#_subfunctions" class="code">function hpt2LLt = update_hpt2LLt(inv_model, data0, k, opt)</a>
0733    <span class="keyword">if</span> k==0 <span class="comment">% first the start up iteration use the initial hyperparameter</span>
0734       k=1;
0735    <span class="keyword">end</span>
0736    <span class="keyword">if</span> ~opt.calc_LLt_prior
0737       error(<span class="string">'no LLt calculation mechanism, set imdl.inv_solve_core.LLt_prior or imdl.LLt_prior'</span>);
0738    <span class="keyword">end</span>
0739    <span class="keyword">if</span> opt.verbose &gt; 1
0740       disp(<span class="string">'    calc hp^2 L L^t'</span>);
0741    <span class="keyword">end</span>
0742    hp2 = 1;
0743    nmt = sum([opt.n_frames{:}]); <span class="comment">% Number of Measurements, Total</span>
0744    LLt = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(nmt,nmt); <span class="comment">% init = 0</span>
0745    msi = 0; mei = 0; <span class="comment">% measurement start, measurement end</span>
0746    <span class="keyword">for</span> i = 1:size(opt.LLt_prior,1) <span class="comment">% row i</span>
0747       msi = mei + 1;
0748       mei = mei + opt.n_frames{i};
0749       msj = 0; mej = 0; <span class="comment">% element start, element end</span>
0750       <span class="keyword">for</span> j = 1:size(opt.LLt_prior,2) <span class="comment">% column j</span>
0751          msj = mej + 1;
0752          mej = mej + opt.n_frames{j};
0753          <span class="keyword">if</span> isempty(opt.LLt_prior{i,j}) <span class="comment">% null entries</span>
0754             <span class="keyword">continue</span>; <span class="comment">% no need to explicitly create zero block matrices</span>
0755          <span class="keyword">end</span>
0756 
0757          <span class="comment">% select a hyperparameter, potentially, per iteration</span>
0758          <span class="comment">% if we're at the end of the list, select the last entry</span>
0759          hp=opt.hyperparameter_temporal{i,j};
0760          <span class="keyword">if</span> length(hp) &gt; k
0761             hp=hp(k);
0762          <span class="keyword">else</span>
0763             hp=hp(end);
0764          <span class="keyword">end</span>
0765 
0766          <span class="keyword">try</span> LLt_str = func2str(opt.LLt_prior{i,j});
0767          <span class="keyword">catch</span>
0768             <span class="keyword">try</span>
0769                 LLt_str = opt.LLt_prior{i,j};
0770                 <span class="keyword">if</span> isnumeric(LLt_str)
0771                    <span class="keyword">if</span> LLt_str == eye(size(LLt_str))
0772                       LLt_str = <span class="string">'eye'</span>;
0773                    <span class="keyword">else</span>
0774                       LLt_str = sprintf(<span class="string">'array, norm=%0.1g'</span>,norm(LLt_str));
0775                    <span class="keyword">end</span>
0776                 <span class="keyword">end</span>
0777             <span class="keyword">catch</span>
0778                 LLt_str = <span class="string">'unknown'</span>;
0779             <span class="keyword">end</span>
0780          <span class="keyword">end</span>
0781          <span class="keyword">if</span> opt.verbose &gt; 1
0782             fprintf(<span class="string">'      {%d,%d} regularization LLt (%s), frames=%dx%d, hp=%0.4g\n'</span>, i,j,LLt_str,mei-msi+1,mej-msj+1,hp*sqrt(hp2));
0783          <span class="keyword">end</span>
0784          inv_modelt = inv_model;
0785          inv_modelt.LLt_prior = opt.LLt_prior{i,j};
0786          LLt(msi:mei, msj:mej) = hp.^2 * <a href="../../../eidors/solvers/calc_LLt_prior.html" class="code" title="function LLt_prior = calc_LLt_prior( data0, inv_model )">calc_LLt_prior</a>( data0, inv_modelt );
0787       <span class="keyword">end</span>
0788    <span class="keyword">end</span>
0789    hpt2LLt = hp2*LLt;
0790 
0791 <a name="_sub11" href="#_subfunctions" class="code">function plot_dx_and_svd_elem(J, W, hps2RtR, k, sx, dx, img, opt)</a>
0792    <span class="keyword">if</span>(opt.verbose &gt;= 5)
0793       <span class="comment">% and try a show_fem with the pixel search direction</span>
0794       clf;
0795       imgb=img;
0796       imgb.elem_data = dx;
0797       imgb.current_params = opt.elem_working;
0798       imgb.is_dx_plot = 1; <span class="comment">% hint to show_fem that this is a dx plot (for handling log scale if anything clever is going on)</span>
0799       <span class="keyword">if</span> isfield(imgb.inv_model,<span class="string">'rec_model'</span>)
0800          imgb.fwd_model = imgb.inv_model.rec_model;
0801       <span class="keyword">end</span>
0802       feval(opt.show_fem,imgb,1);
0803       title(sprintf(<span class="string">'dx @ iter=%d'</span>,k));
0804       drawnow;
0805       <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
0806          print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-dx%d'</span>,opt.fig_prefix,k));
0807          print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-dx%d'</span>,opt.fig_prefix,k));
0808          saveas(gcf,sprintf(<span class="string">'%s-dx%d.fig'</span>,opt.fig_prefix,k));
0809       <span class="keyword">end</span>
0810    <span class="keyword">end</span>
0811    <span class="keyword">if</span> opt.verbose &lt; 8
0812       <span class="keyword">return</span>; <span class="comment">% do nothing if not verbose</span>
0813    <span class="keyword">end</span>
0814    <span class="comment">% canonicalize the structures so we don't have to deal with a bunch of scenarios below</span>
0815    <span class="keyword">if</span> ~isfield(img, <span class="string">'params_sel'</span>)
0816       img.params_sel = {1:length(img.elem_data)};
0817    <span class="keyword">end</span>
0818    <span class="keyword">if</span> ~isfield(img, <span class="string">'current_params'</span>)
0819       img.current_params = <span class="string">'conductivity'</span>;
0820    <span class="keyword">end</span>
0821    <span class="keyword">if</span> ~iscell(img.current_params)
0822       img.current_params = {img.current_params};
0823    <span class="keyword">end</span>
0824    <span class="comment">% go</span>
0825    cols=length(opt.elem_working);
0826    <span class="keyword">if</span> norm(sx - dx) &lt; <a href="#_sub51" class="code" title="subfunction x=range(y)">range</a>(dx)/max(dx)*0.01 <span class="comment">% sx and dx are within 1%</span>
0827       rows=2;
0828    <span class="keyword">else</span>
0829       rows=3;
0830    <span class="keyword">end</span>
0831    clf; <span class="comment">% individual SVD plots</span>
0832    <span class="keyword">for</span> i=1:cols
0833       <span class="keyword">if</span> 1 <span class="comment">% if Tikhonov</span>
0834          hp=opt.hyperparameter_spatial{i};
0835          <span class="keyword">if</span> k ~= 0 &amp;&amp; k &lt; length(hp)
0836             hp = hp(k);
0837          <span class="keyword">else</span>
0838             hp = hp(end);
0839          <span class="keyword">end</span>
0840       <span class="keyword">else</span>
0841          hp = [];
0842       <span class="keyword">end</span>
0843       sel=img.params_sel{i};
0844       str=strrep(img.current_params{i},<span class="string">'_'</span>,<span class="string">' '</span>);
0845       <a href="#_sub12" class="code" title="subfunction plot_svd(J, W, hps2RtR, k, hp)">plot_svd</a>(J(:,sel), W, hps2RtR(sel,sel), k, hp); xlabel(str);
0846       drawnow;
0847       <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
0848          print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-svd%d-%s'</span>,opt.fig_prefix,k,img.current_params{i}));
0849          print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-svd%d-%s'</span>,opt.fig_prefix,k,img.current_params{i}));
0850          saveas(gcf,sprintf(<span class="string">'%s-svd%d-%s.fig'</span>,opt.fig_prefix,k,img.current_params{i}));
0851       <span class="keyword">end</span>
0852    <span class="keyword">end</span>
0853    clf; <span class="comment">% combo plot</span>
0854    <span class="keyword">for</span> i=1:cols
0855       <span class="keyword">if</span> 1 <span class="comment">% if Tikhonov</span>
0856          hp=opt.hyperparameter_spatial{i};
0857          <span class="keyword">if</span> k ~= 0 &amp;&amp; k &lt; length(hp)
0858             hp = hp(k);
0859          <span class="keyword">else</span>
0860             hp = hp(end);
0861          <span class="keyword">end</span>
0862       <span class="keyword">else</span>
0863          hp = [];
0864       <span class="keyword">end</span>
0865       subplot(rows,cols,i);
0866       sel=img.params_sel{i};
0867       str=strrep(img.current_params{i},<span class="string">'_'</span>,<span class="string">' '</span>);
0868       <a href="#_sub12" class="code" title="subfunction plot_svd(J, W, hps2RtR, k, hp)">plot_svd</a>(J(:,sel), W, hps2RtR(sel,sel), k, hp); xlabel(str);
0869       subplot(rows,cols,cols+i);
0870       bar(dx(sel)); ylabel([<span class="string">'dx: '</span> str]);
0871       <span class="keyword">if</span> rows &gt; 2
0872          subplot(rows,cols,2*cols+i);
0873          bar(sx(sel)); ylabel([<span class="string">'sx: '</span> str]);
0874       <span class="keyword">end</span>
0875    <span class="keyword">end</span>
0876    drawnow;
0877    <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
0878       print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-svd%d'</span>,opt.fig_prefix,k));
0879       print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-svd%d'</span>,opt.fig_prefix,k));
0880       saveas(gcf,sprintf(<span class="string">'%s-svd%d.fig'</span>,opt.fig_prefix,k));
0881    <span class="keyword">end</span>
0882 
0883 <a name="_sub12" href="#_subfunctions" class="code">function plot_svd(J, W, hps2RtR, k, hp)</a>
0884    <span class="keyword">if</span> nargin &lt; 5
0885       hp = [];
0886    <span class="keyword">end</span>
0887    <span class="comment">% calculate the singular values before and after regularization</span>
0888    [~,s1,~]=svd(J'*W*J); s1=sqrt(diag(s1));
0889    [~,s2,~]=svd(J'*W*J + hps2RtR); s2=sqrt(diag(s2));
0890    h=semilogy(s1,<span class="string">'bx'</span>); axis tight; set(h,<span class="string">'LineWidth'</span>,2);
0891    hold on; h=semilogy(s2,<span class="string">'go'</span>); axis tight; set(h,<span class="string">'LineWidth'</span>,2); hold off;
0892    xlabel(<span class="string">'k'</span>); ylabel(<span class="string">'value \sigma'</span>);
0893    title(sprintf(<span class="string">'singular values of J at iteration %d'</span>,k));
0894    legend(<span class="string">'J^T J'</span>, <span class="string">'J^T J + \lambda^2 R^T R'</span>); legend location best;
0895    <span class="comment">% line for \lambda</span>
0896 <span class="comment">%     if regularization == 2 % Noser</span>
0897 <span class="comment">%        hp_scaled = hp*sqrt(norm(full(RtR)));</span>
0898 <span class="comment">%        h=line([1 length(s1)],[hp_scaled hp_scaled]);</span>
0899 <span class="comment">%        text(length(s1)/2,hp_scaled*0.9,sprintf('\\lambda ||R^T R||^{%0.1f}= %0.4g; \\lambda = %0.4g', noser_p, hp_scaled, hp));</span>
0900 <span class="comment">%        fprintf('  affecting %d of %d singular values\k', length(find(s1&lt;hp_scaled)), length(s1));</span>
0901 <span class="comment">%     else % Tikhonov</span>
0902    <span class="keyword">if</span> length(hp)==1
0903         h=line([1 length(s1)],[hp hp]);
0904         ly=10^(log10(hp)-0.05*<a href="#_sub51" class="code" title="subfunction x=range(y)">range</a>(log10([s1;s2])));
0905         text(length(s1)/2,ly,sprintf(<span class="string">'\\lambda = %0.4g'</span>, hp));
0906 <span class="comment">%       fprintf('  affecting %d of %d singular values\k', length(find(s1&lt;hp)), length(s1));</span>
0907      <span class="keyword">end</span>
0908      set(h,<span class="string">'LineStyle'</span>,<span class="string">'-.'</span>); set(h,<span class="string">'LineWidth'</span>,2);
0909    set(gca,<span class="string">'YMinorTick'</span>,<span class="string">'on'</span>, <span class="string">'YMinorGrid'</span>, <span class="string">'on'</span>, <span class="string">'YGrid'</span>, <span class="string">'on'</span>);
0910 
0911 
0912 <span class="comment">% TODO this function is one giant HACK around broken RtR generation with c2f matrices</span>
0913 <a name="_sub13" href="#_subfunctions" class="code">function RtR = calc_RtR_prior_wrapper(inv_model, img, opt)</a>
0914    RtR = <a href="../../../eidors/solvers/calc_RtR_prior.html" class="code" title="function RtR_prior = calc_RtR_prior( inv_model )">calc_RtR_prior</a>( inv_model );
0915    <span class="keyword">if</span> size(RtR,1) &lt; length(img.elem_data)
0916      ne = length(img.elem_data) - size(RtR,1);
0917      <span class="comment">% we are correcting for the added background element</span>
0918      <span class="keyword">for</span> i=1:ne
0919        RtR(end+1:end+1, end+1:end+1) = RtR(1,1);
0920      <span class="keyword">end</span>
0921      <span class="keyword">if</span> opt.verbose &gt; 1
0922         fprintf(<span class="string">'      c2f: adjusting RtR by appending %d rows/cols\n'</span>, ne);
0923         disp(   <span class="string">'      TODO move this fix, or something like it to calc_RtR_prior -- this fix is a quick HACK to get things to run...'</span>);
0924      <span class="keyword">end</span>
0925    <span class="keyword">end</span>
0926 
0927 <span class="comment">% opt is only updated for the fwd_solve count</span>
0928 <a name="_sub14" href="#_subfunctions" class="code">function [J, opt] = update_jacobian(img, dN, k, opt)</a>
0929    img.elem_data = img.elem_data(:,1);
0930    base_types = <a href="#_sub46" class="code" title="subfunction out = map_img_base_types(img)">map_img_base_types</a>(img);
0931    imgb = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, base_types);
0932    imgb = feval(opt.update_img_func, imgb, opt);
0933    <span class="comment">% if the electrodes/geometry moved, we need to recalculate dN if it depends on vh</span>
0934    <span class="comment">% note that only apparent_resisitivity needs vh; all others depend on data0 measurements</span>
0935    <span class="keyword">if</span> any(strcmp(<a href="#_sub46" class="code" title="subfunction out = map_img_base_types(img)">map_img_base_types</a>(img), <span class="string">'movement'</span>)) &amp;&amp; any(strcmp(opt.meas_working, <span class="string">'apparent_resistivity'</span>))
0936       imgh = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(imgb, <span class="string">'conductivity'</span>); <span class="comment">% drop everything but conductivity</span>
0937       imgh.elem_data = imgh.elem_data*0 +1; <span class="comment">% conductivity = 1</span>
0938       vh = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(imgh); vh = vh.meas;
0939       dN = <a href="#_sub20" class="code" title="subfunction dN = da_dv(v,vh)">da_dv</a>(1,vh); <span class="comment">% = diag(1/vh)</span>
0940       opt.fwd_solutions = opt.fwd_solutions +1;
0941    <span class="keyword">end</span>
0942    ee = 0; <span class="comment">% element select, init</span>
0943    pp = <a href="../../../eidors/solvers/forward/fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>(imgb.fwd_model);
0944    J = zeros(pp.n_meas,sum([opt.elem_len{:}]));
0945    <span class="keyword">for</span> i=1:length(opt.jacobian)
0946       <span class="keyword">if</span>(opt.verbose &gt; 1)
0947          <span class="keyword">if</span> isnumeric(opt.jacobian{i})
0948             J_str = <span class="string">'[fixed]'</span>;
0949          <span class="keyword">elseif</span> isa(opt.jacobian{i}, <span class="string">'function_handle'</span>)
0950             J_str = func2str(opt.jacobian{i});
0951          <span class="keyword">else</span>
0952             J_str = opt.jacobian{i};
0953          <span class="keyword">end</span>
0954          <span class="keyword">if</span> i == 1 fprintf(<span class="string">'    calc Jacobian J(x) = '</span>);
0955          <span class="keyword">else</span>      fprintf(<span class="string">'                       + '</span>); <span class="keyword">end</span>
0956          fprintf(<span class="string">'(%s,'</span>, J_str);
0957       <span class="keyword">end</span>
0958       <span class="comment">% start and end of these Jacobian columns</span>
0959       es = ee+1;
0960       ee = es+opt.elem_len{i}-1;
0961       <span class="comment">% scaling if we are working in something other than direct conductivity</span>
0962       S = feval(opt.calc_jacobian_scaling_func{i}, imgb.elem_data(es:ee)); <span class="comment">% chain rule</span>
0963       <span class="comment">% finalize the jacobian</span>
0964       <span class="comment">% Note that if a normalization (i.e. apparent_resistivity) has been applied</span>
0965       <span class="comment">% to the measurements, it needs to be applied to the Jacobian as well!</span>
0966       imgt = imgb;
0967       <span class="keyword">if</span>  strcmp(base_types{i}, <span class="string">'conductivity'</span>) <span class="comment">% make legacy jacobian calculators happy... only conductivity on imgt.elem_data</span>
0968          imgt = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, <span class="string">'conductivity'</span>);
0969       <span class="keyword">end</span>
0970       imgt.fwd_model.jacobian = opt.jacobian{i};
0971       Jn = <a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>( imgt ); <span class="comment">% unscaled natural units (i.e. conductivity)</span>
0972       J(:,es:ee) = dN * Jn * S; <span class="comment">% scaled and normalized</span>
0973       <span class="keyword">if</span> opt.verbose &gt; 1
0974          tmp = zeros(1,size(J,2));
0975          tmp(es:ee) = 1;
0976          tmp(opt.elem_fixed) = 0;
0977          fprintf(<span class="string">' %d DoF, %d meas, %s)\n'</span>, sum(tmp), size(J,1), func2str(opt.calc_jacobian_scaling_func{i}));
0978       <span class="keyword">end</span>
0979       <span class="keyword">if</span> opt.verbose &gt;= 5
0980          clf;
0981          t=axes(<span class="string">'Position'</span>,[0 0 1 1],<span class="string">'Visible'</span>,<span class="string">'off'</span>); <span class="comment">% something to put our title on after we're done</span>
0982          text(0.03,0.1,sprintf(<span class="string">'update\\_jacobian (%s), iter=%d'</span>, strrep(J_str,<span class="string">'_'</span>,<span class="string">'\_'</span>), k),<span class="string">'FontSize'</span>,20,<span class="string">'Rotation'</span>,90);
0983          <span class="keyword">for</span> y=0:1
0984             <span class="keyword">if</span> y == 0; D = Jn; <span class="keyword">else</span> D = J(:,es:ee); <span class="keyword">end</span>
0985             axes(<span class="string">'units'</span>, <span class="string">'normalized'</span>, <span class="string">'position'</span>, [ 0.13 0.62-y/2 0.8 0.3 ]);
0986             imagesc(D);
0987             <span class="keyword">if</span> y == 0; ylabel(<span class="string">'meas (1)'</span>); xlabel([<span class="string">'elem ('</span> strrep(base_types{i},<span class="string">'_'</span>,<span class="string">'\_'</span>) <span class="string">')'</span>]);
0988             <span class="keyword">else</span>       ylabel(<span class="string">'meas (dN)'</span>); xlabel([<span class="string">'elem ('</span> strrep(opt.elem_working{i},<span class="string">'_'</span>,<span class="string">'\_'</span>) <span class="string">')'</span>]);
0989             <span class="keyword">end</span>
0990             os = get(gca, <span class="string">'Position'</span>); c=colorbar(<span class="string">'southoutside'</span>); <span class="comment">% colorbar start...</span>
0991             set(gca, <span class="string">'Position'</span>, os); <span class="comment">% fix STUPID colorbar resizing</span>
0992             <span class="comment">% reduce height, this has to be done after the axes fix or STUPID matlab messes things up real good</span>
0993             cP = get(c,<span class="string">'Position'</span>); set(c,<span class="string">'Position'</span>, [0.13    0.54-y/2    0.8    0.010]);
0994             axes(<span class="string">'units'</span>, <span class="string">'normalized'</span>, <span class="string">'position'</span>, [ 0.93 0.62-y/2 0.05 0.3 ]);
0995             barh(sqrt(sum(D.^2,2))); axis tight; axis ij; set(gca, <span class="string">'ytick'</span>, [], <span class="string">'yticklabel'</span>, []);
0996             axes(<span class="string">'units'</span>, <span class="string">'normalized'</span>, <span class="string">'position'</span>, [ 0.13 0.92-y/2 0.8 0.05 ]);
0997             bar(sqrt(sum(D.^2,1))); axis tight; set(gca, <span class="string">'xtick'</span>, [], <span class="string">'xticklabel'</span>, []);
0998          <span class="keyword">end</span>
0999          drawnow;
1000          <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
1001             print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-J%d-%s'</span>,opt.fig_prefix,k,strrep(J_str,<span class="string">'_'</span>,<span class="string">''</span>)));
1002             print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-J%d-%s'</span>,opt.fig_prefix,k,strrep(J_str,<span class="string">'_'</span>,<span class="string">''</span>)));
1003             saveas(gcf,sprintf(<span class="string">'%s-J%d-%s.fig'</span>,opt.fig_prefix,k,strrep(J_str,<span class="string">'_'</span>,<span class="string">''</span>)));
1004          <span class="keyword">end</span>
1005       <span class="keyword">end</span>
1006    <span class="keyword">end</span>
1007    <span class="keyword">if</span> opt.verbose &gt;= 4
1008       <span class="comment">% and try a show_fem with the pixel sensitivity</span>
1009       <span class="keyword">try</span>
1010          clf;
1011          imgb.elem_data = log(sqrt(sum(J.^2,1)));
1012          <span class="keyword">for</span> i = 1:length(imgb.current_params)
1013             imgb.current_params{i} = [ <span class="string">'log_sensitivity_'</span> imgb.current_params{i} ];
1014          <span class="keyword">end</span>
1015          <span class="keyword">if</span> isfield(imgb.inv_model,<span class="string">'rec_model'</span>)
1016             imgb.fwd_model = imgb.inv_model.rec_model;
1017          <span class="keyword">end</span>
1018          feval(opt.show_fem,imgb,1);
1019          title(sprintf(<span class="string">'sensitivity @ iter=%d'</span>,k));
1020          drawnow;
1021          <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
1022             print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-Js%d-%s'</span>,opt.fig_prefix,k,strrep(J_str,<span class="string">'_'</span>,<span class="string">''</span>)));
1023             print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-Js%d-%s'</span>,opt.fig_prefix,k,strrep(J_str,<span class="string">'_'</span>,<span class="string">''</span>)));
1024             saveas(gcf,sprintf(<span class="string">'%s-Js%d-%s.fig'</span>,opt.fig_prefix,k,strrep(J_str,<span class="string">'_'</span>,<span class="string">''</span>)));
1025          <span class="keyword">end</span>
1026       <span class="keyword">catch</span> <span class="comment">% no worries if it didn't work... carry on</span>
1027       <span class="keyword">end</span>
1028    <span class="keyword">end</span>
1029 
1030 <span class="comment">% -------------------------------------------------</span>
1031 <span class="comment">% Chain Rule Products for Jacobian Translations</span>
1032 <span class="comment">% x is conductivity, we want the chain rule to translate the</span>
1033 <span class="comment">% Jacobian of conductivity to conductivity on resistivity or</span>
1034 <span class="comment">% logs of either.</span>
1035 <span class="comment">% This chain rule works out to a constant.</span>
1036 <span class="comment">%</span>
1037 <span class="comment">% d log_b(x)     1          d x</span>
1038 <span class="comment">% ---------- = ------- , ---------- = x ln(b)</span>
1039 <span class="comment">%     d x      x ln(b)   d log_b(x)</span>
1040 <a name="_sub15" href="#_subfunctions" class="code">function S = dx_dlogx(x);</a>
1041    S = <a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(x);
1042 <a name="_sub16" href="#_subfunctions" class="code">function S = dx_dlog10x(x);</a>
1043    S = <a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(x * log(10));
1044 <span class="comment">% resistivity 'y'</span>
1045 <span class="comment">% d x     d x   -1</span>
1046 <span class="comment">% ----- = --- = ---, y = 1/x --&gt; -(x^2)</span>
1047 <span class="comment">% d 1/x   d y   y^2</span>
1048 <a name="_sub17" href="#_subfunctions" class="code">function S = dx_dy(x);</a>
1049    S = <a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(-(x.^2));
1050 <span class="comment">% then build the log versions of conductivity by combining chain rule products</span>
1051 <a name="_sub18" href="#_subfunctions" class="code">function S = dx_dlogy(x);</a>
1052 <span class="comment">%   S = dx_dy(x) * dy_dlogy(x);</span>
1053 <span class="comment">%     = -(x^2) * 1/x = -x</span>
1054    S = <a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(-x);
1055 <a name="_sub19" href="#_subfunctions" class="code">function S = dx_dlog10y(x);</a>
1056 <span class="comment">%   S = dx_dy(x) * dy_dlog10y(x);</span>
1057 <span class="comment">%     = -(x^2) * 1/(ln(10) x) = -x / ln(10)</span>
1058    S = <a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(-x/log(10));
1059 <span class="comment">% ... some renaming to make things understandable above: x = 1/y</span>
1060 <span class="comment">%function S = dy_dlogy(x);</span>
1061 <span class="comment">%   S = dx_dlogx(1./x);</span>
1062 <span class="comment">%function S = dy_dlog10y(x);</span>
1063 <span class="comment">%   S = dx_dlog10x(1./x);</span>
1064 <span class="comment">% -------------------------------------------------</span>
1065 <span class="comment">% apparent_resistivity 'a' versus voltage 'x'</span>
1066 <span class="comment">% d a    1  d v    1         v</span>
1067 <span class="comment">% --- = --- --- = --- ; a = ---</span>
1068 <span class="comment">% d v    vh d v    vh        vh</span>
1069 <span class="comment">% log_apparent_resistivity</span>
1070 <span class="comment">% d loga   d loga d a    1   1     vh  1     1</span>
1071 <span class="comment">% ------ = ------ --- = --- --- = --- --- = ---</span>
1072 <span class="comment">% d v       d a   d v    a   vh    v   vh    v</span>
1073 <a name="_sub20" href="#_subfunctions" class="code">function dN = da_dv(v,vh)</a>
1074    dN = <a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(1./vh); <span class="comment">% N == dN for apparent_resistivity</span>
1075 <a name="_sub21" href="#_subfunctions" class="code">function dN = dloga_dv(v,vh)</a>
1076    dN = <a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(1./v);
1077 <a name="_sub22" href="#_subfunctions" class="code">function dN = dlog10a_dv(v,vh)</a>
1078    dN = <a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>( 1./(v * log(10)) );
1079 <a name="_sub23" href="#_subfunctions" class="code">function dN = dv_dv(v,vh)</a>
1080    dN = 1;
1081 <a name="_sub24" href="#_subfunctions" class="code">function dN = dlogv_dv(v,vh) </a><span class="comment">% same as dloga_dv</span>
1082    dN = <a href="#_sub21" class="code" title="subfunction dN = dloga_dv(v,vh)">dloga_dv</a>(v,vh);
1083 <a name="_sub25" href="#_subfunctions" class="code">function dN = dlog10v_dv(v,vh) </a><span class="comment">% same as dlog10a_dv</span>
1084    dN = <a href="#_sub22" class="code" title="subfunction dN = dlog10a_dv(v,vh)">dlog10a_dv</a>(v, vh);
1085 <span class="comment">% -------------------------------------------------</span>
1086 
1087 
1088 <a name="_sub26" href="#_subfunctions" class="code">function [alpha, img, dv, opt] = update_alpha(img, sx, data0, img0, N, W, hps2RtR, hpt2LLt, k, dv, opt)</a>
1089   <span class="keyword">if</span> k == 0 <span class="comment">% first iteration, just setting up, no line search happens</span>
1090      alpha = 0;
1091      <span class="keyword">return</span>;
1092   <span class="keyword">end</span>
1093 
1094   <span class="keyword">if</span>(opt.verbose &gt; 1)
1095      <span class="keyword">try</span>
1096          ls_str = func2str(opt.line_search_func);
1097      <span class="keyword">catch</span>
1098          ls_str = opt.line_search_func;
1099      <span class="keyword">end</span>
1100      fprintf(<span class="string">'    line search, alpha = %s\n'</span>, ls_str);
1101   <span class="keyword">end</span>
1102 
1103   <span class="comment">% some sanity checks before we feed this information to the line search</span>
1104   <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(sx, <span class="string">'sx (pre-line search)'</span>);
1105   <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(img.elem_data, <span class="string">'img.elem_data (pre-line search)'</span>);
1106 
1107   <span class="keyword">if</span> any(size(img.elem_data) ~= size(sx))
1108      error(sprintf(<span class="string">'mismatch on elem_data[%d,%d] vs. sx[%d,%d] vector sizes, check c2f_background_fixed'</span>,size(img.elem_data), size(sx)));
1109   <span class="keyword">end</span>
1110 
1111   optt = opt;
1112   <span class="keyword">if</span> isfield(optt,<span class="string">'fig_prefix'</span>) <span class="comment">% set fig_prefix for the iteration#</span>
1113     optt.fig_prefix = [opt.fig_prefix <span class="string">'-k'</span> num2str(k)];
1114   <span class="keyword">end</span>
1115   [alpha, imgo, dv, opto] = feval(opt.line_search_func, img, sx, data0, img0, N, W, hps2RtR, hpt2LLt, dv, optt);
1116   <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>) <span class="comment">% set fig_prefix back to it's old value</span>
1117     opto.fig_prefix = opt.fig_prefix;
1118   <span class="keyword">end</span>
1119   <span class="keyword">if</span> ~isempty(imgo)
1120      img = imgo;
1121   <span class="keyword">else</span>
1122      img.elem_data = img.elem_data + alpha*sx;
1123   <span class="keyword">end</span>
1124   <span class="keyword">if</span> ~isempty(opto)
1125      opt = opto;
1126   <span class="keyword">end</span>
1127 
1128   <span class="keyword">if</span>(opt.verbose &gt; 1)
1129      fprintf(<span class="string">'      selected alpha=%0.3g\n'</span>, alpha);
1130   <span class="keyword">end</span>
1131 
1132   <span class="keyword">if</span> (alpha == 0) &amp;&amp; (k == 1)
1133     error(<span class="string">'first iteration failed to advance solution'</span>);
1134   <span class="keyword">end</span>
1135 
1136 <a name="_sub27" href="#_subfunctions" class="code">function err_if_inf_or_nan(x, str);</a>
1137   <span class="keyword">if</span> any(any(isnan(x) | isinf(x)))
1138       error(sprintf(<span class="string">'bad %s (%d NaN, %d Inf of %d)'</span>, <span class="keyword">...</span>
1139                     str, <span class="keyword">...</span>
1140                     length(find(isnan(x))), <span class="keyword">...</span>
1141                     length(find(isinf(x))), <span class="keyword">...</span>
1142                     length(x(:))));
1143   <span class="keyword">end</span>
1144 
1145 
1146 <a name="_sub28" href="#_subfunctions" class="code">function [img, dv] = update_img_using_limits(img, img0, data0, N, dv, opt)</a>
1147   <span class="comment">% fix max/min values for x</span>
1148   <span class="keyword">if</span> opt.max_value ~= +inf
1149      lih = find(img.elem_data &gt; opt.max_value);
1150      img.elem_data(lih) = opt.max_value;
1151      <span class="keyword">if</span> opt.verbose &gt; 1
1152         fprintf(<span class="string">'    limit max(x)=%g for %d elements\n'</span>, opt.max_value, length(lih));
1153      <span class="keyword">end</span>
1154      dv = []; <span class="comment">% dv is now invalid since we changed the conductivity</span>
1155   <span class="keyword">end</span>
1156   <span class="keyword">if</span> opt.min_value ~= -inf
1157      lil = find(img.elem_data &lt; opt.min_value);
1158      img.elem_data(lil) = opt.min_value;
1159      <span class="keyword">if</span> opt.verbose &gt; 1
1160         fprintf(<span class="string">'    limit min(x)=%g for %d elements\n'</span>, opt.min_value, length(lil));
1161      <span class="keyword">end</span>
1162      dv = []; <span class="comment">% dv is now invalid since we changed the conductivity</span>
1163   <span class="keyword">end</span>
1164   <span class="comment">% update voltage change estimate if the limit operation changed the img data</span>
1165   [dv, opt] = <a href="#_sub30" class="code" title="subfunction [dv, opt] = update_dv(dv, img, data0, N, opt, reason)">update_dv</a>(dv, img, data0, N, opt, <span class="string">'(dv out-of-date)'</span>);
1166 
1167 <a name="_sub29" href="#_subfunctions" class="code">function  de = update_de(de, img, img0, opt)</a>
1168    img0 = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img0, opt.elem_working);
1169    img  = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img,  opt.elem_working);
1170    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(img0.elem_data, <span class="string">'de img0'</span>);
1171    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(img.elem_data,  <span class="string">'de img'</span>);
1172    <span class="comment">% probably not the most robust check for whether this is the first update</span>
1173    <span class="comment">% but this ensures that we get exactly zero for the first iteration and not</span>
1174    <span class="comment">% a set of values that has numeric floating point errors that are nearly zero</span>
1175    <span class="keyword">if</span> isempty(de) <span class="comment">% first iteration</span>
1176       <span class="comment">% data hasn't changed yet!</span>
1177       de = zeros(size(img0.elem_data));
1178    <span class="keyword">else</span>
1179       de = img.elem_data - img0.elem_data;
1180    <span class="keyword">end</span>
1181    de(opt.elem_fixed) = 0; <span class="comment">% TODO is this redundant... delete me?</span>
1182    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(de, <span class="string">'de out'</span>);
1183 
1184 <a name="_sub30" href="#_subfunctions" class="code">function [dv, opt] = update_dv(dv, img, data0, N, opt, reason)</a>
1185    <span class="comment">% estimate current error as a residual</span>
1186    <span class="keyword">if</span> ~isempty(dv) <span class="comment">% need to calculate dv...</span>
1187       <span class="keyword">return</span>;
1188    <span class="keyword">end</span>
1189    <span class="keyword">if</span> nargin &lt; 7
1190       reason = <span class="string">''</span>;
1191    <span class="keyword">end</span>
1192    <span class="keyword">if</span> opt.verbose &gt; 1
1193       disp([<span class="string">'    fwd_solve b=Ax '</span>, reason]);
1194    <span class="keyword">end</span>
1195    [dv, opt, err] = <a href="#_sub32" class="code" title="subfunction [dv, opt, err] = update_dv_core(img, data0, N, opt)">update_dv_core</a>(img, data0, N, opt);
1196 <span class="comment">% TODO AB inject the img.error here, so it doesn't need to be recalculated when calc_solution_error=1</span>
1197 <span class="comment">%   img.error = err;</span>
1198 
1199 <a name="_sub31" href="#_subfunctions" class="code">function data = map_meas_struct(data, N, out)</a>
1200    <span class="keyword">try</span>
1201        current_meas_params = data.current_params;
1202    <span class="keyword">catch</span>
1203        current_meas_params = <span class="string">'voltage'</span>;
1204    <span class="keyword">end</span>
1205    data.meas = <a href="#_sub50" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(data.meas, N, current_meas_params, out);
1206    data.current_params = out;
1207    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(data.meas, <span class="string">'dv meas'</span>);
1208 
1209 <span class="comment">% also used by the line search as opt.line_search_dv_func</span>
1210 <a name="_sub32" href="#_subfunctions" class="code">function [dv, opt, err] = update_dv_core(img, data0, N, opt)</a>
1211    data0 = <a href="#_sub31" class="code" title="subfunction data = map_meas_struct(data, N, out)">map_meas_struct</a>(data0, N, <span class="string">'voltage'</span>);
1212    img = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, <a href="#_sub46" class="code" title="subfunction out = map_img_base_types(img)">map_img_base_types</a>(img));
1213    img = feval(opt.update_img_func, img, opt);
1214    img = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, <span class="string">'conductivity'</span>); <span class="comment">% drop everything but conductivity</span>
1215    <span class="comment">% if the electrodes/geometry moved, we need to recalculate N if it's being used</span>
1216    <span class="keyword">if</span> any(any(N ~= 1)) &amp;&amp; any(strcmp(<a href="#_sub46" class="code" title="subfunction out = map_img_base_types(img)">map_img_base_types</a>(img), <span class="string">'movement'</span>))
1217       <span class="comment">% note: data0 is mapped back to 'voltage' before N is modified</span>
1218       imgh=img; imgh.elem_data = imgh.elem_data(:,1)*0 +1; <span class="comment">% conductivity = 1</span>
1219       vh = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(imgh); vh = vh.meas;
1220       N = <a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(1./vh);
1221       opt.fwd_solutions = opt.fwd_solutions +1;
1222    <span class="keyword">end</span>
1223    data = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(img);
1224    opt.fwd_solutions = opt.fwd_solutions +1;
1225    dv = <a href="../../../eidors/solvers/calc_difference_data.html" class="code" title="function dva = calc_difference_data( data1, data2, fwd_model)">calc_difference_data</a>(data0, data, img.fwd_model);
1226 <span class="comment">%   clf;subplot(211); h=show_fem(img,1); set(h,'EdgeColor','none'); subplot(212); xx=1:length(dv); plot(xx,[data0.meas,data.meas,dv]); legend('d0','d1','dv'); drawnow; pause(1);</span>
1227    <span class="keyword">if</span> nargout &gt;= 3
1228       err = norm(dv)/norm(data0.meas);
1229    <span class="keyword">else</span>
1230       err = NaN;
1231    <span class="keyword">end</span>
1232    dv = <a href="#_sub50" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(dv, N, <span class="string">'voltage'</span>, opt.meas_working);
1233    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(dv, <span class="string">'dv out'</span>);
1234 
1235 <a name="_sub33" href="#_subfunctions" class="code">function show_fem_iter(k, img, inv_model, stop, opt)</a>
1236   <span class="keyword">if</span> (opt.verbose &lt; 4) || (stop == -1)
1237      <span class="keyword">return</span>; <span class="comment">% if verbosity is low OR we're dropping the last iteration because it was bad, do nothing</span>
1238   <span class="keyword">end</span>
1239   <span class="keyword">if</span> opt.verbose &gt; 1
1240      str=opt.show_fem;
1241      <span class="keyword">if</span> isa(str,<span class="string">'function_handle'</span>)
1242         str=func2str(str);
1243      <span class="keyword">end</span>
1244      disp([<span class="string">'    '</span> str <span class="string">'()'</span>]);
1245   <span class="keyword">end</span>
1246   <span class="keyword">if</span> isequal(opt.show_fem,@<a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>) <span class="comment">% opt.show_fem == @show_fem... so we need to try to be smart enough to make show_fem not explode</span>
1247      img = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, <span class="string">'resistivity'</span>); <span class="comment">% TODO big fat hack to make this work at the expense of an actual function...</span>
1248      [img, opt] = <a href="#_sub44" class="code" title="subfunction [img, opt] = strip_c2f_background(img, opt, indent)">strip_c2f_background</a>(img, opt, <span class="string">'    '</span>);
1249      <span class="comment">% check we're returning the right size of data</span>
1250      <span class="keyword">if</span> isfield(inv_model, <span class="string">'rec_model'</span>)
1251        img.fwd_model = inv_model.rec_model;
1252      <span class="keyword">end</span>
1253    <span class="comment">%  bg = 1;</span>
1254    <span class="comment">%  img.calc_colours.ref_level = bg;</span>
1255    <span class="comment">%  img.calc_colours.clim = bg;</span>
1256      img.calc_colours.cb_shrink_move = [0.3,0.6,0.02]; <span class="comment">% move color bars</span>
1257      <span class="keyword">if</span> size(img.elem_data,1) ~= size(img.fwd_model.elems,1)
1258         warning(sprintf(<span class="string">'img.elem_data has %d elements, img.fwd_model.elems has %d elems\n'</span>, <span class="keyword">...</span>
1259                         size(img.elem_data,1), <span class="keyword">...</span>
1260                         size(img.fwd_model.elems,1)));
1261      <span class="keyword">end</span>
1262   <span class="keyword">else</span> <span class="comment">% do the &quot;final clean up&quot;, same as when we quit</span>
1263      img = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, opt.elem_output);
1264      [img, opt] = <a href="#_sub44" class="code" title="subfunction [img, opt] = strip_c2f_background(img, opt, indent)">strip_c2f_background</a>(img, opt, <span class="string">'    '</span>);
1265      <span class="keyword">if</span> isfield(inv_model, <span class="string">'rec_model'</span>)
1266        img.fwd_model = inv_model.rec_model;
1267      <span class="keyword">end</span>
1268   <span class="keyword">end</span>
1269   clf; feval(opt.show_fem, img, 1);
1270   title(sprintf(<span class="string">'x @ iter=%d'</span>,k));
1271   drawnow;
1272   <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
1273      print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-x%d'</span>,opt.fig_prefix,k));
1274      print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-x%d'</span>,opt.fig_prefix,k));
1275      saveas(gcf,sprintf(<span class="string">'%s-x%d.fig'</span>,opt.fig_prefix,k));
1276   <span class="keyword">end</span>
1277 
1278 <a name="_sub34" href="#_subfunctions" class="code">function [ residual meas elem ] = GN_residual(dv, de, W, hps2RtR, hpt2LLt)</a>
1279    <span class="comment">% We operate on whatever the iterations operate on</span>
1280    <span class="comment">% (log data, resistance, etc) + perturb(i)*dx.</span>
1281    <span class="comment">% We use the kronecker vector identity (Bt x A) vec(X) = vec(A X B) to</span>
1282    <span class="comment">% efficiently compute a residual over many frames.</span>
1283    Wdv = W*dv;
1284    meas = 0.5 * dv(:)' * Wdv(:);
1285    Rde = hps2RtR * de * hpt2LLt';
1286    elem = 0.5 * de(:)' * Rde(:);
1287    residual = meas + elem;
1288 
1289 <a name="_sub35" href="#_subfunctions" class="code">function residual = meas_residual(dv, de, W, hps2RtR)</a>
1290    residual = norm(dv);
1291 
1292 <span class="comment">%function img = initial_estimate( imdl, data )</span>
1293 <span class="comment">%   img = calc_jacobian_bkgnd( imdl );</span>
1294 <span class="comment">%   vs = fwd_solve(img);</span>
1295 <span class="comment">%</span>
1296 <span class="comment">%   if isstruct(data)</span>
1297 <span class="comment">%      data = data.meas;</span>
1298 <span class="comment">%   else</span>
1299 <span class="comment">%     meas_select = [];</span>
1300 <span class="comment">%     try</span>
1301 <span class="comment">%        meas_select = imdl.fwd_model.meas_select;</span>
1302 <span class="comment">%     end</span>
1303 <span class="comment">%     if length(data) == length(meas_select)</span>
1304 <span class="comment">%        data = data(meas_select);</span>
1305 <span class="comment">%     end</span>
1306 <span class="comment">%   end</span>
1307 <span class="comment">%</span>
1308 <span class="comment">%   pf = polyfit(data,vs.meas,1);</span>
1309 <span class="comment">%</span>
1310 <span class="comment">%   % create elem_data</span>
1311 <span class="comment">%   img = data_mapper(img);</span>
1312 <span class="comment">%</span>
1313 <span class="comment">%   if isfield(img.fwd_model,'coarse2fine');</span>
1314 <span class="comment">%      % TODO: the whole coarse2fine needs work here.</span>
1315 <span class="comment">%      %   what happens if c2f doesn't cover the whole region</span>
1316 <span class="comment">%</span>
1317 <span class="comment">%      % TODO: the two cases are very different. c2f case should match other</span>
1318 <span class="comment">%      nc = size(img.fwd_model.coarse2fine,2);</span>
1319 <span class="comment">%      img.elem_data = mean(img.elem_data)*ones(nc,1)*pf(1);</span>
1320 <span class="comment">%   else</span>
1321 <span class="comment">%      img.elem_data = img.elem_data*pf(1);</span>
1322 <span class="comment">%   end</span>
1323 <span class="comment">%</span>
1324 <span class="comment">%   % remove elem_data</span>
1325 <span class="comment">%%   img = data_mapper(img,1);</span>
1326 <span class="comment">%</span>
1327 <span class="comment">%function [img opt] = update_step(org, next, dx, fmin,res, opt)</span>
1328 <span class="comment">%   if isfield(opt, 'update_func')</span>
1329 <span class="comment">%      [img opt] = feval(opt.update_func,org,next,dx,fmin,res,opt);</span>
1330 <span class="comment">%   else</span>
1331 <span class="comment">%      img = next;</span>
1332 <span class="comment">%   end</span>
1333 <span class="comment">%</span>
1334 <span class="comment">% function bg = calc_background_resistivity(fmdl, va)</span>
1335 <span class="comment">%   % have a look at what we've created</span>
1336 <span class="comment">%   % compare data to homgeneous (how good is the model?)</span>
1337 <span class="comment">%   % NOTE background conductivity is set by matching amplitude of</span>
1338 <span class="comment">%   % homogeneous data against the measurements to get rough matching</span>
1339 <span class="comment">%   if(opt.verbose&gt;1)</span>
1340 <span class="comment">%     fprintf('est. background resistivity\n');</span>
1341 <span class="comment">%   end</span>
1342 <span class="comment">%   cache_obj = { fmdl, va };</span>
1343 <span class="comment">%   BACKGROUND_R = eidors_obj('get-cache', cache_obj, 'calc_background_resistivity');</span>
1344 <span class="comment">%   if isempty(BACKGROUND_R);</span>
1345 <span class="comment">%     imgh = mk_image(fmdl, 1); % conductivity = 1 S/m</span>
1346 <span class="comment">%     vh = fwd_solve(imgh);</span>
1347 <span class="comment">%     % take the best fit of the data</span>
1348 <span class="comment">%     BACKGROUND_R = vh.meas \ va; % 32 Ohm.m ... agrees w/ Wilkinson's papers</span>
1349 <span class="comment">%     % update cache</span>
1350 <span class="comment">%     eidors_obj('set-cache', cache_obj, 'calc_background_resistivity', BACKGROUND_R);</span>
1351 <span class="comment">%   else</span>
1352 <span class="comment">%     if(opt.verbose &gt; 1)</span>
1353 <span class="comment">%       fprintf('  ... cache hit\n');</span>
1354 <span class="comment">%     end</span>
1355 <span class="comment">%   end</span>
1356 <span class="comment">%   if(opt.verbose &gt; 1)</span>
1357 <span class="comment">%     fprintf('estimated background resistivity: %0.1f Ohm.m\n', BACKGROUND_R);</span>
1358 <span class="comment">%   end</span>
1359 
1360 <a name="_sub36" href="#_subfunctions" class="code">function opt = parse_options(imdl,n_frames)</a>
1361    <span class="comment">% merge legacy options locations</span>
1362 <span class="comment">%   imdl = deprecate_imdl_opt(imdl, 'parameters');</span>
1363 <span class="comment">%   imdl = deprecate_imdl_opt(imdl, 'inv_solve');</span>
1364 
1365    <span class="comment">% for any general options</span>
1366    <span class="keyword">if</span> isfield(imdl, <span class="string">'inv_solve_core'</span>)
1367       opt = imdl.inv_solve_core;
1368    <span class="keyword">else</span>
1369       opt = struct;
1370    <span class="keyword">end</span>
1371 
1372    <span class="comment">% verbosity, debug output</span>
1373    <span class="comment">% 0: quiet</span>
1374    <span class="comment">% 1: print iteration count</span>
1375    <span class="comment">% 2: print details as the algorithm progresses</span>
1376    <span class="keyword">if</span> ~isfield(opt,<span class="string">'verbose'</span>)
1377       opt.verbose = 1;
1378       fprintf(<span class="string">'  selecting inv_model.inv_solve_core.verbose=1\n'</span>);
1379    <span class="keyword">end</span>
1380    <span class="keyword">if</span> opt.verbose &gt; 1
1381       fprintf(<span class="string">'  verbose = %d\n'</span>, opt.verbose);
1382       fprintf(<span class="string">'  setting default parameters\n'</span>);
1383    <span class="keyword">end</span>
1384    <span class="comment">% we track how many fwd_solves we do since they are the most expensive part of the iterations</span>
1385    opt.fwd_solutions = 0;
1386 
1387    <span class="keyword">if</span> ~isfield(opt, <span class="string">'show_fem'</span>)
1388       opt.show_fem = @<a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>;
1389    <span class="keyword">end</span>
1390 
1391    <span class="keyword">if</span> ~isfield(opt, <span class="string">'residual_func'</span>) <span class="comment">% the objective function</span>
1392       opt.residual_func = @<a href="#_sub34" class="code" title="subfunction [ residual meas elem ] = GN_residual(dv, de, W, hps2RtR, hpt2LLt)">GN_residual</a>; <span class="comment">% r = f(dv, de, W, hps2RtR, hpt2LLt)</span>
1393       <span class="comment">% NOTE: the meas_residual function exists to maintain</span>
1394       <span class="comment">% compatibility with Nolwenn's code, the GN_residual</span>
1395       <span class="comment">% is a better choice</span>
1396       <span class="comment">%opt.residual_func = @meas_residual; % [r,m,e] = f(dv, de, W, hps2RtR, hpt2LLt)</span>
1397    <span class="keyword">end</span>
1398 
1399    <span class="comment">% calculation of update components</span>
1400    <span class="keyword">if</span> ~isfield(opt, <span class="string">'update_func'</span>)
1401       opt.update_func = @<a href="#_sub39" class="code" title="subfunction dx = GN_update(J, W, hps2RtR, hpt2LLt, dv, de, opt)">GN_update</a>; <span class="comment">% dx = f(J, W, hps2RtR, hpt2LLt, dv, de, opt)</span>
1402    <span class="keyword">end</span>
1403    <span class="keyword">if</span> ~isfield(opt, <span class="string">'update_method'</span>)
1404       opt.update_method = <span class="string">'cholesky'</span>;
1405    <span class="keyword">end</span>
1406 
1407    <span class="comment">% figure out if things need to be calculated</span>
1408    <span class="keyword">if</span> ~isfield(opt, <span class="string">'calc_meas_icov'</span>)
1409       opt.calc_meas_icov = 0; <span class="comment">% W</span>
1410    <span class="keyword">end</span>
1411    <span class="keyword">if</span> ~isfield(opt, <span class="string">'calc_RtR_prior'</span>)
1412       opt.calc_RtR_prior = 0; <span class="comment">% RtR</span>
1413    <span class="keyword">end</span>
1414    <span class="keyword">if</span> ~isfield(opt, <span class="string">'calc_LLt_prior'</span>)
1415       opt.calc_LLt_prior = 0; <span class="comment">% LLt</span>
1416    <span class="keyword">end</span>
1417 <span class="comment">% TODO calc_spatial_hyperparameter, calc_temporal_hyperparameter</span>
1418    <span class="keyword">if</span> ~isfield(opt, <span class="string">'calc_hyperparameter'</span>)
1419       opt.calc_hyperparameter = 0; <span class="comment">% hps2</span>
1420    <span class="keyword">end</span>
1421 
1422 <span class="comment">%   try</span>
1423       <span class="keyword">if</span> opt.verbose &gt; 1
1424          fprintf(<span class="string">'    examining function %s(...) for required arguments\n'</span>, func2str(opt.update_func));
1425       <span class="keyword">end</span>
1426       <span class="comment">% ensure that necessary components are calculated</span>
1427       <span class="comment">% opt.update_func: dx = f(J, W, hps2RtR, dv, de, opt)</span>
1428 <span class="comment">%TODO BROKEN      args = function_depends_upon(opt.update_func, 6);</span>
1429       args = ones(5,1); <span class="comment">% TODO BROKEN</span>
1430       <span class="keyword">if</span> args(2) == 1
1431          opt.calc_meas_icov = 1;
1432       <span class="keyword">end</span>
1433       <span class="keyword">if</span> args(3) == 1
1434          opt.calc_hyperparameter = 1;
1435       <span class="keyword">end</span>
1436       <span class="keyword">if</span> args(4) == 1
1437          opt.calc_RtR_prior = 1;
1438       <span class="keyword">end</span>
1439       <span class="keyword">if</span> args(5) == 1
1440          opt.calc_LLt_prior = 1;
1441       <span class="keyword">end</span>
1442 <span class="comment">%   catch</span>
1443 <span class="comment">%      error('exploration of function %s via function_depends_upon() failed', func2str(opt.update_func));</span>
1444 <span class="comment">%   end</span>
1445 
1446    <span class="comment">% stopping criteria, solution limits</span>
1447    <span class="keyword">if</span> ~isfield(opt, <span class="string">'max_iterations'</span>)
1448       opt.max_iterations = 10;
1449    <span class="keyword">end</span>
1450    <span class="keyword">if</span> ~isfield(opt, <span class="string">'ntol'</span>)
1451       opt.ntol = eps; <span class="comment">% attempt to quantify numeric machine precision</span>
1452    <span class="keyword">end</span>
1453    <span class="keyword">if</span> ~isfield(opt, <span class="string">'tol'</span>)
1454       opt.tol = 0; <span class="comment">% terminate iterations if residual is less than tol</span>
1455    <span class="keyword">end</span>
1456    <span class="keyword">if</span> ~isfield(opt, <span class="string">'dtol'</span>)
1457       <span class="comment">% terminate iterations if residual slope is greater than dtol</span>
1458       <span class="comment">% generally, we would want dtol to be -0.01 (1% decrease) or something similar</span>
1459       <span class="comment">%  ... as progress levels out, stop working</span>
1460       opt.dtol = -1e-4; <span class="comment">% --&gt; -0.01% slope (really slow)</span>
1461    <span class="keyword">end</span>
1462    <span class="keyword">if</span> opt.dtol &gt; 0
1463       error(<span class="string">'dtol must be less than 0 (residual decreases at every iteration)'</span>);
1464       <span class="comment">% otherwise we won't converge...</span>
1465    <span class="keyword">end</span>
1466    <span class="keyword">if</span> ~isfield(opt, <span class="string">'dtol_iter'</span>)
1467       <span class="comment">%opt.dtol_iter = inf; % ignore dtol for dtol_iter iterations</span>
1468       opt.dtol_iter = 0; <span class="comment">% use dtol from the beginning</span>
1469    <span class="keyword">end</span>
1470    <span class="keyword">if</span> ~isfield(opt, <span class="string">'min_value'</span>)
1471       opt.min_value = -inf; <span class="comment">% min elem_data value</span>
1472    <span class="keyword">end</span>
1473    <span class="keyword">if</span> ~isfield(opt, <span class="string">'max_value'</span>)
1474       opt.max_value = +inf; <span class="comment">% max elem_data value</span>
1475    <span class="keyword">end</span>
1476    <span class="comment">% provide a graphical display of the line search values &amp; fit</span>
1477    <span class="keyword">if</span> ~isfield(opt, <span class="string">'plot_residuals'</span>)
1478       <span class="keyword">if</span> opt.verbose &gt; 2
1479          opt.plot_residuals = 1;
1480       <span class="keyword">else</span>
1481          opt.plot_residuals = 0;
1482       <span class="keyword">end</span>
1483    <span class="keyword">end</span>
1484    <span class="keyword">if</span> opt.plot_residuals ~= 0
1485       disp(<span class="string">'  residual plot (updated per iteration) are enabled, to disable them set'</span>);
1486       disp(<span class="string">'    inv_model.inv_solve_core.plot_residuals=0'</span>);
1487    <span class="keyword">end</span>
1488 
1489    <span class="comment">% line search</span>
1490    <span class="keyword">if</span> ~isfield(opt,<span class="string">'line_search_func'</span>)
1491       <span class="comment">% [alpha, img, dv, opt] = f(img, sx, data0, img0, N, W, hps2RtR, dv, opt);</span>
1492       opt.line_search_func = @<a href="line_search_onm2.html" class="code" title="function  [alpha, img, dv, opt] = line_search_onm2(imgk, dx, data1, img1, N, W, hps2RtR, hpt2LLt, dv0, opt, retry, pf_max)">line_search_onm2</a>;
1493    <span class="keyword">end</span>
1494    <span class="keyword">if</span> ~isfield(opt,<span class="string">'line_search_dv_func'</span>)
1495       opt.line_search_dv_func = @<a href="#_sub32" class="code" title="subfunction [dv, opt, err] = update_dv_core(img, data0, N, opt)">update_dv_core</a>;
1496       <span class="comment">% [dv, opt] = update_dv_core(img, data0, N, opt)</span>
1497    <span class="keyword">end</span>
1498    <span class="keyword">if</span> ~isfield(opt,<span class="string">'line_search_de_func'</span>)
1499       <span class="comment">% we create an anonymous function to skip the first input argument since</span>
1500       <span class="comment">% we always want to calculate de in the line search</span>
1501       opt.line_search_de_func = @(img, img0, opt) <a href="#_sub29" class="code" title="subfunction  de = update_de(de, img, img0, opt)">update_de</a>(1, img, img0, opt);
1502       <span class="comment">% de = f(img, img0, opt)</span>
1503    <span class="keyword">end</span>
1504    <span class="comment">% an initial guess for the line search step sizes, may be modified by line search</span>
1505    <span class="comment">% TODO this 'sensible default' should be moved to the line_search code since it is not generic to any other line searches</span>
1506    <span class="keyword">if</span> ~isfield(opt,<span class="string">'line_search_args'</span>) || <span class="keyword">...</span>
1507       ~isfield(opt.line_search_args, <span class="string">'perturb'</span>)
1508       fmin = 1/4; <span class="comment">% arbitrary starting guess</span>
1509       opt.line_search_args.perturb = [0 fmin/4 fmin/2 fmin fmin*2 fmin*4];
1510       <span class="comment">%opt.line_search_args.perturb = [0 fmin/4 fmin fmin*4];</span>
1511       <span class="comment">%opt.line_search_args.perturb = [0 0.1 0.35 0.7 1.0];</span>
1512       <span class="comment">%opt.line_search_args.perturb = [0 0.1 0.5 0.7 1.0];</span>
1513       <span class="comment">%pt.line_search_args.perturb = [0 0.1 0.7 0.9 1.0];</span>
1514       <span class="comment">%opt.line_search_args.perturb = [0 0.1 0.9 1.0];</span>
1515    <span class="keyword">end</span>
1516    <span class="comment">% provide a graphical display of the line search values &amp; fit</span>
1517    <span class="keyword">if</span> ~isfield(opt,<span class="string">'line_search_args'</span>) || <span class="keyword">...</span>
1518       ~isfield(opt.line_search_args, <span class="string">'plot'</span>)
1519       <span class="keyword">if</span> opt.verbose &gt;= 5
1520          opt.line_search_args.plot = 1;
1521       <span class="keyword">else</span>
1522          opt.line_search_args.plot = 0;
1523       <span class="keyword">end</span>
1524    <span class="keyword">end</span>
1525    <span class="comment">% pass fig_prefix to the line search as well, unless they are supposed to go somewhere elese</span>
1526    <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>) &amp;&amp; <span class="keyword">...</span>
1527       isfield(opt,<span class="string">'line_search_args'</span>) &amp;&amp; <span class="keyword">...</span>
1528       ~isfield(opt.line_search_args, <span class="string">'fig_prefix'</span>)
1529       opt.line_search_args.fig_prefix = opt.fig_prefix;
1530    <span class="keyword">end</span>
1531    <span class="comment">% some help on how to turn off the line search plots if we don't want to see them</span>
1532    <span class="keyword">if</span> opt.line_search_args.plot ~= 0
1533       disp(<span class="string">'  line search plots (per iteration) are enabled, to disable them set'</span>);
1534       disp(<span class="string">'    inv_model.inv_solve_core.line_search_args.plot=0'</span>);
1535    <span class="keyword">end</span>
1536 
1537    <span class="comment">% background</span>
1538    <span class="comment">% if &gt; 0, this is the elem_data that holds the background</span>
1539    <span class="comment">% this is stripped off just before the iterations complete</span>
1540    <span class="keyword">if</span> ~isfield(opt, <span class="string">'c2f_background'</span>)
1541      <span class="keyword">if</span> isfield(imdl, <span class="string">'fwd_model'</span>) &amp;&amp; isfield(imdl.fwd_model, <span class="string">'coarse2fine'</span>)
1542         opt.c2f_background = -1; <span class="comment">% possible: check if its required later</span>
1543      <span class="keyword">else</span>
1544         opt.c2f_background = 0;
1545      <span class="keyword">end</span>
1546    <span class="keyword">end</span>
1547    <span class="keyword">if</span> ~isfield(opt, <span class="string">'c2f_background_fixed'</span>)
1548       opt.c2f_background_fixed = 1; <span class="comment">% generally, don't touch the background</span>
1549    <span class="keyword">end</span>
1550 
1551 
1552    <span class="comment">% DATA CONVERSION settings</span>
1553    <span class="comment">% elem type for the initial estimate is based on calc_jacobian_bkgnd which returns an img</span>
1554    <span class="keyword">if</span> ~isfield(opt, <span class="string">'elem_working'</span>)
1555       opt.elem_working = {<span class="string">'conductivity'</span>};
1556    <span class="keyword">end</span>
1557    <span class="keyword">if</span> ~isfield(opt, <span class="string">'elem_prior'</span>)
1558       opt.elem_prior = {<span class="string">'conductivity'</span>};
1559    <span class="keyword">end</span>
1560    <span class="keyword">if</span> ~isfield(opt, <span class="string">'elem_output'</span>)
1561       opt.elem_output = {<span class="string">'conductivity'</span>};
1562    <span class="keyword">end</span>
1563    <span class="keyword">if</span> ~isfield(opt, <span class="string">'meas_input'</span>)
1564       opt.meas_input = <span class="string">'voltage'</span>;
1565    <span class="keyword">end</span>
1566    <span class="keyword">if</span> ~isfield(opt, <span class="string">'meas_working'</span>)
1567       opt.meas_working = <span class="string">'voltage'</span>;
1568    <span class="keyword">end</span>
1569    <span class="comment">% if the user didn't put these into cell arrays, do</span>
1570    <span class="comment">% so here so there is less error checking later in</span>
1571    <span class="comment">% the code</span>
1572    <span class="keyword">for</span> i = {<span class="string">'elem_working'</span>, <span class="string">'elem_prior'</span>, <span class="string">'elem_output'</span>, <span class="string">'meas_input'</span>, <span class="string">'meas_working'</span>}
1573      <span class="comment">% MATLAB voodoo: deincapsulate a cell containing a</span>
1574      <span class="comment">% string, then use that to access a struct element</span>
1575      x = opt.(i{1});
1576      <span class="keyword">if</span> ~iscell(x)
1577         opt.(i{1}) = {x};
1578      <span class="keyword">end</span>
1579    <span class="keyword">end</span>
1580    <span class="keyword">if</span> length(opt.meas_input) &gt; 1
1581       error(<span class="string">'imdl.inv_solve_core.meas_input: multiple measurement types not yet supported'</span>);
1582    <span class="keyword">end</span>
1583    <span class="keyword">if</span> length(opt.meas_working) &gt; 1
1584       error(<span class="string">'imdl.inv_solve_core.meas_working: multiple measurement types not yet supported'</span>);
1585    <span class="keyword">end</span>
1586 
1587    <span class="keyword">if</span> ~isfield(opt, <span class="string">'prior_data'</span>)
1588       <span class="keyword">if</span> isfield(imdl, <span class="string">'jacobian_bkgnd'</span>) &amp;&amp; <span class="keyword">...</span>
1589          isfield(imdl.jacobian_bkgnd, <span class="string">'value'</span>) &amp;&amp; <span class="keyword">...</span>
1590          length(opt.elem_prior) == 1
1591          opt.prior_data = {imdl.jacobian_bkgnd.value};
1592       <span class="keyword">else</span>
1593          error(<span class="string">'requires inv_model.inv_solve_core.prior_data'</span>);
1594       <span class="keyword">end</span>
1595    <span class="keyword">end</span>
1596 
1597    <span class="keyword">if</span> ~isfield(opt, <span class="string">'elem_len'</span>)
1598       <span class="keyword">if</span> length(opt.elem_working) == 1
1599          <span class="keyword">if</span> isfield(imdl.fwd_model, <span class="string">'coarse2fine'</span>)
1600             c2f = imdl.fwd_model.coarse2fine; <span class="comment">% coarse-to-fine mesh mapping</span>
1601             opt.elem_len = { size(c2f,2) };
1602          <span class="keyword">else</span>
1603             opt.elem_len = { size(imdl.fwd_model.elems,1) };
1604          <span class="keyword">end</span>
1605       <span class="keyword">else</span>
1606         error(<span class="string">'requires inv_model.inv_solve_core.elem_len'</span>);
1607       <span class="keyword">end</span>
1608    <span class="keyword">end</span>
1609 
1610    <span class="keyword">if</span> ~isfield(opt, <span class="string">'n_frames'</span>)
1611       opt.n_frames = {n_frames};
1612    <span class="keyword">end</span>
1613 
1614    <span class="comment">% meas_select already handles selecting from the valid measurements</span>
1615    <span class="comment">% we want the same for the elem_data, so we only work on modifying the legal values</span>
1616    <span class="comment">% Note that c2f_background's elements are added to this list if opt.c2f_background_fixed == 1</span>
1617    <span class="keyword">if</span> ~isfield(opt, <span class="string">'elem_fixed'</span>) <span class="comment">% give a safe default, if none has been provided</span>
1618       opt.elem_fixed = [];
1619    <span class="keyword">elseif</span> iscell(opt.elem_fixed) <span class="comment">% if its a cell-array, we convert it to absolute</span>
1620      <span class="comment">% numbers in elem_data</span>
1621      <span class="comment">%  -- requires: opt.elem_len to already be constructed if it was missing</span>
1622       offset=0;
1623       ef=[];
1624       <span class="keyword">for</span> i=1:length(opt.elem_fixed)
1625          ef = [ef, opt.elem_fixed{i} + offset];
1626          offset = offset + opt.elem_len{i};
1627       <span class="keyword">end</span>
1628       opt.elem_fixed = ef;
1629    <span class="keyword">end</span>
1630 
1631    <span class="comment">% allow a cell array of jacobians</span>
1632    <span class="keyword">if</span> ~isfield(opt, <span class="string">'jacobian'</span>)
1633       <span class="keyword">if</span> ~iscell(imdl.fwd_model.jacobian)
1634          opt.jacobian = {imdl.fwd_model.jacobian};
1635       <span class="keyword">else</span>
1636          opt.jacobian = imdl.fwd_model.jacobian;
1637       <span class="keyword">end</span>
1638    <span class="keyword">elseif</span> isfield(imdl.fwd_model, <span class="string">'jacobian'</span>)
1639       imdl.fwd_model
1640       imdl
1641       error(<span class="string">'inv_model.fwd_model.jacobian and inv_model.inv_solve_core.jacobian should not both exist: it''s ambiguous'</span>);
1642    <span class="keyword">end</span>
1643 
1644    <span class="keyword">if</span> isfield(opt, <span class="string">'hyperparameter'</span>)
1645       opt.hyperparameter_spatial = opt.hyperparameter; <span class="comment">% backwards compatible</span>
1646       opt = rmfield(opt, <span class="string">'hyperparameter'</span>);
1647    <span class="keyword">end</span>
1648    <span class="comment">% default hyperparameter is 1</span>
1649    <span class="keyword">if</span> ~isfield(opt, <span class="string">'hyperparameter_spatial'</span>)
1650       opt.hyperparameter_spatial = {[]};
1651       <span class="keyword">for</span> i=1:length(opt.elem_working)
1652          opt.hyperparameter_spatial{i} = 1;
1653       <span class="keyword">end</span>
1654    <span class="keyword">end</span>
1655    <span class="keyword">if</span> ~isfield(opt, <span class="string">'hyperparameter_temporal'</span>)
1656       opt.hyperparameter_temporal = {[]};
1657       <span class="keyword">for</span> i=1:length(opt.meas_working)
1658          opt.hyperparameter_temporal{i} = 1;
1659       <span class="keyword">end</span>
1660    <span class="keyword">end</span>
1661    <span class="comment">% if the user didn't put these into cell arrays, do</span>
1662    <span class="comment">% so here so there is less error checking later in</span>
1663    <span class="comment">% the code</span>
1664    <span class="keyword">for</span> i = {<span class="string">'elem_len'</span>, <span class="string">'prior_data'</span>, <span class="string">'jacobian'</span>, <span class="string">'hyperparameter_spatial'</span>, <span class="string">'hyperparameter_temporal'</span>}
1665      <span class="comment">% MATLAB voodoo: deincapsulate a cell containing a</span>
1666      <span class="comment">% string, then use that to access a struct eleemnt</span>
1667      x = opt.(i{1});
1668      <span class="keyword">if</span> ~iscell(x)
1669         opt.(i{1}) = {x};
1670      <span class="keyword">end</span>
1671    <span class="keyword">end</span>
1672    <span class="comment">% show what the hyperparameters are configured to when logging</span>
1673    <span class="keyword">if</span> opt.verbose &gt; 1
1674       fprintf(<span class="string">'  hyperparameters\n'</span>);
1675       <span class="keyword">try</span>
1676           hp_global = imdl.hyperparameter.value;
1677           hp_global_str = sprintf(<span class="string">' x %0.4g'</span>,hp_global);
1678       <span class="keyword">catch</span>
1679           hp_global = 1;
1680           hp_global_str = <span class="string">''</span>;
1681       <span class="keyword">end</span>
1682       <span class="keyword">for</span> i=1:length(opt.elem_working)
1683          <span class="keyword">if</span> isnumeric(opt.hyperparameter_spatial{i}) &amp;&amp; length(opt.hyperparameter_spatial{i}) == 1
1684             fprintf(<span class="string">'    %s: %0.4g\n'</span>,opt.elem_working{i}, opt.hyperparameter_spatial{i}*hp_global);
1685          <span class="keyword">elseif</span> isa(opt.hyperparameter_spatial{i}, <span class="string">'function_handle'</span>)
1686             fprintf(<span class="string">'    %s: @%s%s\n'</span>,opt.elem_working{i}, func2str(opt.hyperparameter_spatial{i}), hp_global_str);
1687          <span class="keyword">elseif</span> ischar(opt.hyperparameter_spatial{i})
1688             fprintf(<span class="string">'    %s: @%s%s\n'</span>,opt.elem_working{i}, opt.hyperparameter_spatial{i}, hp_global_str);
1689          <span class="keyword">else</span>
1690             fprintf(<span class="string">'    %s: ...\n'</span>,opt.elem_working{i});
1691          <span class="keyword">end</span>
1692       <span class="keyword">end</span>
1693       <span class="keyword">for</span> i=1:length(opt.meas_working)
1694          <span class="keyword">if</span> isnumeric(opt.hyperparameter_temporal{i}) &amp;&amp; length(opt.hyperparameter_temporal{i}) == 1
1695             fprintf(<span class="string">'    %s: %0.4g\n'</span>,opt.meas_working{i}, opt.hyperparameter_temporal{i}*hp_global);
1696          <span class="keyword">elseif</span> isa(opt.hyperparameter_temporal{i}, <span class="string">'function_handle'</span>)
1697             fprintf(<span class="string">'    %s: @%s%s\n'</span>,opt.meas_working{i}, func2str(opt.hyperparameter_temporal{i}), hp_global_str);
1698          <span class="keyword">elseif</span> ischar(opt.hyperparameter_temporal{i})
1699             fprintf(<span class="string">'    %s: @%s%s\n'</span>,opt.meas_working{i}, opt.hyperparameter_temporal{i}, hp_global_str);
1700          <span class="keyword">else</span>
1701             fprintf(<span class="string">'    %s: ...\n'</span>,opt.meas_working{i});
1702          <span class="keyword">end</span>
1703       <span class="keyword">end</span>
1704    <span class="keyword">end</span>
1705 
1706    <span class="comment">% REGULARIZATION RtR</span>
1707    <span class="comment">% for constructing the blockwise RtR matrix</span>
1708    <span class="comment">% can be: explicit matrix, blockwise matrix diagonal, or full blockwise matrix</span>
1709    <span class="comment">% blockwise matrices can be function ptrs or explicit</span>
1710    <span class="keyword">if</span> ~isfield(opt, <span class="string">'RtR_prior'</span>)
1711       <span class="keyword">if</span> isfield(imdl, <span class="string">'RtR_prior'</span>)
1712          opt.RtR_prior = {imdl.RtR_prior};
1713       <span class="keyword">else</span>
1714          opt.RtR_prior = {[]}; <span class="comment">% null matrix (all zeros)</span>
1715          warning(<span class="string">'missing imdl.inv_solve_core.RtR_prior or imdl.RtR_prior: assuming NO spatial regularization RtR=0'</span>);
1716       <span class="keyword">end</span>
1717    <span class="keyword">end</span>
1718    <span class="comment">% bit of a make work project but if its actually a full numeric matrix we</span>
1719    <span class="comment">% canoncialize it by breaking it up into the blockwise components</span>
1720    <span class="keyword">if</span> isnumeric(opt.RtR_prior)
1721       <span class="keyword">if</span> size(opt.RtR_prior, 1) ~= size(opt.RtR_prior, 2)
1722          error(<span class="string">'expecting square matrix for imdl.RtR_prior or imdl.inv_solve_core.RtR_prior'</span>);
1723       <span class="keyword">end</span>
1724       <span class="keyword">if</span> length(opt.RtR_prior) == 1
1725          opt.RtR_prior = {opt.RtR_prior}; <span class="comment">% encapsulate directly into a cell array</span>
1726       <span class="keyword">else</span>
1727          RtR = opt.RtR_prior;
1728          opt.RtR_prior = {[]};
1729          esi = 0; eei = 0;
1730          <span class="keyword">for</span> i=1:length(opt.elem_len)
1731             esi = eei +1;
1732             eei = eei +opt.elem_len{i};
1733             esj = 0; eej = 0;
1734             <span class="keyword">for</span> j=1:length(opt.elem_len)
1735                esj = eej +1;
1736                eej = eej +opt.elem_len{j};
1737                opt.RtR_prior(i,j) = RtR(esi:eei, esj:eej);
1738             <span class="keyword">end</span>
1739          <span class="keyword">end</span>
1740       <span class="keyword">end</span>
1741    <span class="keyword">elseif</span> ~iscell(opt.RtR_prior) <span class="comment">% not a cell array? encapsulate it</span>
1742       opt.RtR_prior = {opt.RtR_prior};
1743    <span class="keyword">end</span>
1744    <span class="comment">% if not square then expand the block matrix</span>
1745    <span class="comment">% single row/column: this is our diagonal --&gt; expand to full blockwise matrix</span>
1746    <span class="keyword">if</span> any(size(opt.RtR_prior) ~= ([1 1]*length(opt.elem_len)))
1747       <span class="keyword">if</span> (size(opt.RtR_prior, 1) ~= 1) &amp;&amp; <span class="keyword">...</span>
1748          (size(opt.RtR_prior, 2) ~= 1)
1749          error(<span class="string">'odd imdl.RtR_prior or imdl.inv_solve_core.RtR_prior, cannot figure out how to expand it blockwise'</span>);
1750       <span class="keyword">end</span>
1751       <span class="keyword">if</span> (size(opt.RtR_prior, 1) ~= length(opt.elem_len)) &amp;&amp; <span class="keyword">...</span>
1752          (size(opt.RtR_prior, 2) ~= length(opt.elem_len))
1753          error(<span class="string">'odd imdl.RtR_prior or imdl.inv_solve_core.RtR_prior, not enough blockwise components vs. elem_working types'</span>);
1754       <span class="keyword">end</span>
1755       RtR_diag = opt.RtR_prior;
1756       opt.RtR_prior = {[]}; <span class="comment">% delete and start again</span>
1757       <span class="keyword">for</span> i=1:length(opt.elem_len)
1758          opt.RtR_prior(i,i) = RtR_diag(i);
1759       <span class="keyword">end</span>
1760    <span class="keyword">end</span>
1761    <span class="comment">% now sort out the hyperparameter for the &quot;R^T R&quot; (RtR) matrix</span>
1762    hp=opt.hyperparameter_spatial;
1763    <span class="keyword">if</span> size(hp,1) == 1 <span class="comment">% one row</span>
1764       hp = hp'; <span class="comment">% ... now one col</span>
1765    <span class="keyword">end</span>
1766    <span class="keyword">if</span> iscell(hp)
1767       <span class="comment">% if it's a cell array that matches size of the RtR, then we're done</span>
1768       <span class="keyword">if</span> all(size(hp) == size(opt.RtR_prior))
1769          opt.hyperparameter_spatial = hp;
1770       <span class="comment">% if the columns match, then we can expand on the diagonal, everything else gets '1'</span>
1771       <span class="keyword">elseif</span> length(hp) == length(opt.RtR_prior)
1772          opt.hyperparameter_spatial = opt.RtR_prior;
1773          [opt.hyperparameter_spatial{:}] = deal(1); <span class="comment">% hp = 1 everywhere</span>
1774          opt.hyperparameter_spatial(logical(eye(size(opt.RtR_prior)))) = hp; <span class="comment">% assign to diagonal</span>
1775       <span class="keyword">else</span>
1776          error(<span class="string">'hmm, don''t understand this opt.hyperparameter_spatial cellarray'</span>);
1777       <span class="keyword">end</span>
1778    <span class="comment">% if it's a single hyperparameter, that's the value everywhere</span>
1779    <span class="keyword">elseif</span> isnumeric(hp)
1780       opt.hyperparameter_spatial = opt.RtR_prior;
1781       [opt.hyperparameter_spatial{:}] = deal({hp});
1782    <span class="keyword">else</span>
1783       error(<span class="string">'don''t understand this opt.hyperparameter_spatial'</span>);
1784    <span class="keyword">end</span>
1785    
1786    <span class="comment">% REGULARIZATION LLt</span>
1787    <span class="comment">% for constructing the blockwise LLt matrix</span>
1788    <span class="comment">% can be: explicit matrix, blockwise matrix diagonal, or full blockwise matrix</span>
1789    <span class="comment">% blockwise matrices can be function ptrs or explicit</span>
1790    <span class="keyword">if</span> ~isfield(opt, <span class="string">'LLt_prior'</span>)
1791       <span class="keyword">if</span> isfield(imdl, <span class="string">'LLt_prior'</span>)
1792          opt.LLt_prior = {imdl.LLt_prior};
1793       <span class="keyword">else</span>
1794          opt.LLt_prior = {eye(n_frames)};
1795          <span class="keyword">if</span> n_frames ~= 1
1796             fprintf(<span class="string">'warning: missing imdl.inv_solve_core.LLt_prior or imdl.LLt_prior: assuming NO temporal regularization LLt=I\n'</span>);
1797          <span class="keyword">end</span>
1798       <span class="keyword">end</span>
1799    <span class="keyword">end</span>
1800    <span class="comment">% bit of a make work project but if its actually a full numeric matrix we</span>
1801    <span class="comment">% canoncialize it by breaking it up into the blockwise components</span>
1802    <span class="keyword">if</span> isnumeric(opt.LLt_prior)
1803       <span class="keyword">if</span> size(opt.LLt_prior, 1) ~= size(opt.LLt_prior, 2)
1804          error(<span class="string">'expecting square matrix for imdl.LLt_prior or imdl.inv_solve_core.LLt_prior'</span>);
1805       <span class="keyword">end</span>
1806       <span class="keyword">if</span> length(opt.LLt_prior) == 1
1807          opt.LLt_prior = {opt.LLt_prior}; <span class="comment">% encapsulate directly into a cell array</span>
1808       <span class="keyword">else</span>
1809          LLt = opt.LLt_prior;
1810          opt.LLt_prior = {[]};
1811          msi = 0; mei = 0;
1812          <span class="keyword">for</span> i=1:length(opt.n_frames)
1813             msi = mei +1;
1814             mei = mei +opt.n_frames{i};
1815             msj = 0; mej = 0;
1816             <span class="keyword">for</span> j=1:length(opt.n_frames)
1817                msj = mej +1;
1818                mej = mej +opt.n_frames{j};
1819                opt.LLt_prior(i,j) = LLt(msi:mei, msj:mej);
1820             <span class="keyword">end</span>
1821          <span class="keyword">end</span>
1822       <span class="keyword">end</span>
1823    <span class="keyword">elseif</span> ~iscell(opt.LLt_prior) <span class="comment">% not a cell array? encapsulate it</span>
1824       opt.LLt_prior = {opt.LLt_prior};
1825    <span class="keyword">end</span>
1826    <span class="comment">% if not square then expand the block matrix</span>
1827    <span class="comment">% single row/column: this is our diagonal --&gt; expand to full blockwise matrix</span>
1828    <span class="keyword">if</span> any(size(opt.LLt_prior) ~= ([1 1]*length(opt.n_frames)))
1829       <span class="keyword">if</span> (size(opt.LLt_prior, 1) ~= 1) &amp;&amp; <span class="keyword">...</span>
1830          (size(opt.LLt_prior, 2) ~= 1)
1831          error(<span class="string">'odd imdl.LLt_prior or imdl.inv_solve_core.LLt_prior, cannot figure out how to expand it blockwise'</span>);
1832       <span class="keyword">end</span>
1833       <span class="keyword">if</span> (size(opt.LLt_prior, 1) ~= length(opt.n_frames)) &amp;&amp; <span class="keyword">...</span>
1834          (size(opt.LLt_prior, 2) ~= length(opt.n_frames))
1835          error(<span class="string">'odd imdl.LLt_prior or imdl.inv_solve_core.LLt_prior, not enough blockwise components vs. meas_working types'</span>);
1836       <span class="keyword">end</span>
1837       LLt_diag = opt.LLt_prior;
1838       opt.LLt_prior = {[]}; <span class="comment">% delete and start again</span>
1839       <span class="keyword">for</span> i=1:length(opt.n_frames)
1840          opt.LLt_prior(i,i) = LLt_diag(i);
1841       <span class="keyword">end</span>
1842    <span class="keyword">end</span>
1843    <span class="comment">% now sort out the hyperparameter for the &quot;L L^t&quot; (LLt) matrix</span>
1844    hp=opt.hyperparameter_temporal;
1845    <span class="keyword">if</span> size(hp,1) == 1 <span class="comment">% one row</span>
1846       hp = hp'; <span class="comment">% ... now one col</span>
1847    <span class="keyword">end</span>
1848    <span class="keyword">if</span> iscell(hp)
1849       <span class="comment">% if it's a cell array that matches size of the LLt, then we're done</span>
1850       <span class="keyword">if</span> all(size(hp) == size(opt.LLt_prior))
1851          opt.hyperparameter_temporal = hp;
1852       <span class="comment">% if the columns match, then we can expand on the diagonal, everything else gets '1'</span>
1853       <span class="keyword">elseif</span> length(hp) == length(opt.LLt_prior)
1854          opt.hyperparameter_temporal = opt.LLt_prior;
1855          [opt.hyperparameter_temporal{:}] = deal(1); <span class="comment">% hp = 1 everywhere</span>
1856          opt.hyperparameter_temporal(logical(eye(size(opt.LLt_prior)))) = hp; <span class="comment">% assign to diagonal</span>
1857       <span class="keyword">else</span>
1858          error(<span class="string">'hmm, don''t understand this opt.hyperparameter_temporal cellarray'</span>);
1859       <span class="keyword">end</span>
1860    <span class="comment">% if it's a single hyperparameter, that's the value everywhere</span>
1861    <span class="keyword">elseif</span> isnumeric(hp)
1862       opt.hyperparameter_temporal = opt.LLt_prior;
1863       [opt.hyperparameter_temporal{:}] = deal({hp});
1864    <span class="keyword">else</span>
1865       error(<span class="string">'don''t understand this opt.hyperparameter_temporal'</span>);
1866    <span class="keyword">end</span>
1867 
1868    <span class="comment">% JACOBIAN CHAIN RULE conductivity -&gt; whatever</span>
1869    <span class="comment">% where x = conductivity at this iteration</span>
1870    <span class="comment">%       S = a scaling matrix, generally a diagonal matrix of size matching Jacobian columns</span>
1871    <span class="comment">% Jn = J * S;</span>
1872    <span class="comment">% if not provided, determine based on 'elem_working' type</span>
1873    <span class="keyword">if</span> ~isfield(opt, <span class="string">'calc_jacobian_scaling_func'</span>)
1874       pinv = strfind(opt.elem_working, <span class="string">'resistivity'</span>);
1875       plog = strfind(opt.elem_working, <span class="string">'log_'</span>);
1876       plog10 = strfind(opt.elem_working, <span class="string">'log10_'</span>);
1877       <span class="keyword">for</span> i = 1:length(opt.elem_working)
1878         prefix = <span class="string">''</span>;
1879         <span class="keyword">if</span> plog{i}
1880            prefix = <span class="string">'log'</span>;
1881         <span class="keyword">elseif</span> plog10{i}
1882            prefix = <span class="string">'log10'</span>;
1883         <span class="keyword">else</span>
1884            prefix = <span class="string">''</span>;
1885         <span class="keyword">end</span>
1886         <span class="keyword">if</span> pinv{i}
1887            prefix = [prefix <span class="string">'_inv'</span>];
1888         <span class="keyword">end</span>
1889         <span class="keyword">switch</span>(prefix)
1890           <span class="keyword">case</span> <span class="string">''</span>
1891              opt.calc_jacobian_scaling_func{i} = @<a href="#_sub42" class="code" title="subfunction [out, x, y, z] = ret1_func(varargin);">ret1_func</a>;  <span class="comment">% S = f(x)</span>
1892           <span class="keyword">case</span> <span class="string">'log'</span>
1893              opt.calc_jacobian_scaling_func{i} = @<a href="#_sub15" class="code" title="subfunction S = dx_dlogx(x);">dx_dlogx</a>;   <span class="comment">% S = f(x)</span>
1894           <span class="keyword">case</span> <span class="string">'log10'</span>
1895              opt.calc_jacobian_scaling_func{i} = @<a href="#_sub16" class="code" title="subfunction S = dx_dlog10x(x);">dx_dlog10x</a>; <span class="comment">% S = f(x)</span>
1896           <span class="keyword">case</span> <span class="string">'_inv'</span>
1897              opt.calc_jacobian_scaling_func{i} = @<a href="#_sub17" class="code" title="subfunction S = dx_dy(x);">dx_dy</a>;      <span class="comment">% S = f(x)</span>
1898           <span class="keyword">case</span> <span class="string">'log_inv'</span>
1899              opt.calc_jacobian_scaling_func{i} = @<a href="#_sub18" class="code" title="subfunction S = dx_dlogy(x);">dx_dlogy</a>;   <span class="comment">% S = f(x)</span>
1900           <span class="keyword">case</span> <span class="string">'log10_inv'</span>
1901              opt.calc_jacobian_scaling_func{i} = @<a href="#_sub19" class="code" title="subfunction S = dx_dlog10y(x);">dx_dlog10y</a>; <span class="comment">% S = f(x)</span>
1902           <span class="keyword">otherwise</span>
1903              error(<span class="string">'oops'</span>);
1904        <span class="keyword">end</span>
1905      <span class="keyword">end</span>
1906    <span class="keyword">end</span>
1907 
1908    <span class="keyword">if</span> ~isfield(opt, <span class="string">'update_img_func'</span>)
1909       opt.update_img_func = @<a href="#_sub41" class="code" title="subfunction out = null_func(in, varargin);">null_func</a>; <span class="comment">% img = f(img, opt)</span>
1910    <span class="keyword">end</span>
1911 
1912    <span class="keyword">if</span> ~isfield(opt, <span class="string">'return_working_variables'</span>)
1913       opt.return_working_variables = 0;
1914    <span class="keyword">end</span>
1915 
1916 <a name="_sub37" href="#_subfunctions" class="code">function check_matrix_sizes(J, W, hps2RtR, hpt2LLt, dv, de, opt)</a>
1917    <span class="comment">% assuming our equation looks something like</span>
1918    <span class="comment">% dx = (J'*W*J + hps2RtR)\(J'*dv + hps2RtR*de);</span>
1919    <span class="comment">% check that all the matrix sizes are correct</span>
1920    ne = size(de,1);
1921    nv = size(dv,1);
1922    nf = size(dv,2);
1923    <span class="keyword">if</span> size(de,2) ~= size(dv,2)
1924       error(<span class="string">'de cols (%d) not equal to dv cols (%d)'</span>, size(de,2), size(dv,2));
1925    <span class="keyword">end</span>
1926    <span class="keyword">if</span> opt.calc_meas_icov &amp;&amp; <span class="keyword">...</span>
1927       any(size(W) ~= [nv nv])
1928       error(<span class="string">'W size (%d rows, %d cols) is incorrect (%d rows, %d cols)'</span>, size(W), nv, nv);
1929    <span class="keyword">end</span>
1930    <span class="keyword">if</span> any(size(J) ~= [nv ne])
1931       error(<span class="string">'J size (%d rows, %d cols) is incorrect (%d rows, %d cols)'</span>, size(J), nv, ne);
1932    <span class="keyword">end</span>
1933    <span class="keyword">if</span> opt.calc_RtR_prior &amp;&amp; <span class="keyword">...</span>
1934       any(size(hps2RtR) ~= [ne ne])
1935       error(<span class="string">'hps2RtR size (%d rows, %d cols) is incorrect (%d rows, %d cols)'</span>, size(hps2RtR), ne, ne);
1936    <span class="keyword">end</span>
1937    <span class="keyword">if</span> opt.calc_LLt_prior &amp;&amp; <span class="keyword">...</span>
1938       any(size(hpt2LLt) ~= [nf nf])
1939       error(<span class="string">'hpt2LLt size (%d rows, %d cols) is incorrect (%d rows, %d cols)'</span>, size(hpt2LLt), nf, nf);
1940    <span class="keyword">end</span>
1941 
1942 <a name="_sub38" href="#_subfunctions" class="code">function dx = update_dx(J, W, hps2RtR, hpt2LLt, dv, de, opt)</a>
1943    <span class="keyword">if</span>(opt.verbose &gt; 1)
1944       fprintf( <span class="string">'    calc step size dx\n'</span>);
1945    <span class="keyword">end</span>
1946    <span class="comment">% don't penalize for fixed elements</span>
1947    de(opt.elem_fixed) = 0;
1948 
1949    <span class="comment">% TODO move this outside the inner loop of the iterations, it only needs to be done once</span>
1950    <a href="#_sub37" class="code" title="subfunction check_matrix_sizes(J, W, hps2RtR, hpt2LLt, dv, de, opt)">check_matrix_sizes</a>(J, W, hps2RtR, hpt2LLt, dv, de, opt)
1951 
1952    <span class="comment">% zero out the appropriate things so that we can get a dx=0 for the elem_fixed</span>
1953    J(:,opt.elem_fixed) = 0;
1954    de(opt.elem_fixed,:) = 0;
1955    hps2RtR(opt.elem_fixed,:) = 0;
1956    V=opt.elem_fixed;
1957    N=size(hps2RtR,1)+1;
1958    hps2RtR(N*(V-1)+1) = 1; <span class="comment">% set diagonals to 1 to avoid divide by zero</span>
1959    <span class="comment">% do the update step direction calculation</span>
1960    dx = feval(opt.update_func, J, W, hps2RtR, hpt2LLt, dv, de, opt);
1961 
1962    <span class="comment">% check that our elem_fixed stayed fixed</span>
1963    <span class="keyword">if</span> any(dx(opt.elem_fixed) ~= 0)
1964       error(<span class="string">'elem_fixed did''t give dx=0 at update_dx'</span>)
1965    <span class="keyword">end</span>
1966 
1967    <span class="keyword">if</span>(opt.verbose &gt; 1)
1968       fprintf(<span class="string">'      ||dx||=%0.3g\n'</span>, norm(dx));
1969       es = 0; ee = 0;
1970       <span class="keyword">for</span> i=1:length(opt.elem_working)
1971           es = ee +1; ee = ee + opt.elem_len{i};
1972           nd = norm(dx(es:ee));
1973           fprintf( <span class="string">'      ||dx_%d||=%0.3g (%s)\n'</span>,i, nd, opt.elem_working{i});
1974       <span class="keyword">end</span>
1975    <span class="keyword">end</span>
1976 
1977 <a name="_sub39" href="#_subfunctions" class="code">function dx = GN_update(J, W, hps2RtR, hpt2LLt, dv, de, opt)</a>
1978    <span class="keyword">if</span> ~any(strcmp(opt.update_method, {<span class="string">'cholesky'</span>,<span class="string">'pcg'</span>}))
1979       error([<span class="string">'unsupported update_method: '</span>,opt.update_method]);
1980    <span class="keyword">end</span>
1981    <span class="keyword">if</span> strcmp(opt.update_method, <span class="string">'cholesky'</span>)
1982       <span class="keyword">try</span>
1983          <span class="comment">% expansion for multiple frames</span>
1984          <span class="keyword">if</span> any(any(hpt2LLt ~= eye(size(hpt2LLt))))
1985             <span class="comment">% this will explode for &gt; some small number of frames... massive memory hog</span>
1986             nf = size(dv,2); <span class="comment">% number of frames</span>
1987             JtWJ = kron(eye(nf),J'*W*J);
1988             RtR = kron(hpt2LLt,hps2RtR);
1989             JtW = kron(eye(nf),J'*W);
1990             <span class="comment">% the actual update</span>
1991             <span class="comment">%dx = -(JtWJ + RtR)\(JtW*dv(:) + RtR*de(:)); % LU/Cholesky</span>
1992             dx = -<a href="../../../eidors/algorithms/left_divide.html" class="code" title="function [V] = left_divide(E,I,tol,~,V)">left_divide</a>( (JtWJ + RtR), (JtW*dv(:) + RtR*de(:)) ); <span class="comment">% LU/Cholesky</span>
1993             <span class="comment">% put back: one column per frame</span>
1994             dx = reshape(dx,length(dx)/nf,nf);
1995          <span class="keyword">else</span>
1996             <span class="comment">%dx = -(J'*W*J + hps2RtR)\(J'*W*dv + hps2RtR*de); % LU/Cholesky</span>
1997             dx = -<a href="../../../eidors/algorithms/left_divide.html" class="code" title="function [V] = left_divide(E,I,tol,~,V)">left_divide</a>( (J'*W*J + hps2RtR), (J'*W*dv + hps2RtR*de) ); <span class="comment">% LU/Cholesky</span>
1998          <span class="keyword">end</span>
1999       <span class="keyword">catch</span> ME <span class="comment">% boom</span>
2000          fprintf(<span class="string">'      Cholesky failed: '</span>);
2001          disp(ME.message)
2002          fprintf(<span class="string">'      try opt.update_method = ''pcg'' on future runs\n'</span>);
2003          opt.update_method = <span class="string">'pcg'</span>;
2004       <span class="keyword">end</span>
2005    <span class="keyword">end</span>
2006    <span class="keyword">if</span> strcmp(opt.update_method, <span class="string">'pcg'</span>)
2007       tol = 1e-6; <span class="comment">% default 1e-6</span>
2008       maxit = []; <span class="comment">% default [] --&gt; min(n,20)</span>
2009       M = []; <span class="comment">% default [] --&gt; no preconditioner</span>
2010       x0 = []; <span class="comment">% default [] --&gt; zeros(n,1)</span>
2011 
2012       <span class="comment">% try Preconditioned Conjugate Gradient: A x = b, solve for x</span>
2013       <span class="comment">% avoids J'*J for n x m matrix with large number of m cols --&gt; J'*J becomes an m x m dense matrix</span>
2014       nm = size(de,1); nf = size(de,2);
2015       X = @(x) reshape(x,nm,nf); <span class="comment">% undo vec() operation</span>
2016 
2017       LHS = @(X) (J'*(W*(J*X)) + hps2RtR*(X*hpt2LLt));
2018       RHS = -(J'*(W*dv) + hps2RtR*(de*hpt2LLt));
2019 
2020       LHSv = @(x) reshape(LHS(X(x)),nm*nf,1); <span class="comment">% vec() operation</span>
2021       RHSv = reshape(RHS,nm*nf,1);
2022 
2023       tol=100*eps*size(J,2)^2; <span class="comment">% rough estimate based on multiply-accumulates</span>
2024 <span class="comment">%      maxit = 10;</span>
2025 
2026       [dx, flag, relres, iter, resvec] = pcg(LHSv, RHSv, tol, maxit, M', M', x0);
2027       dx = X(dx);
2028       <span class="comment">% TODO if verbose...</span>
2029       <span class="keyword">switch</span> flag
2030          <span class="keyword">case</span> 0
2031             <span class="keyword">if</span> opt.verbose &gt; 1
2032                fprintf(<span class="string">'      PCG: relres=%g &lt; tol=%g @ iter#%d\n'</span>,relres,tol,iter);
2033             <span class="keyword">end</span>
2034          <span class="keyword">case</span> 1
2035             <span class="keyword">if</span> opt.verbose &gt; 1
2036                fprintf(<span class="string">'      PCG: relres=%g &gt; tol=%g @ iter#%d (max#%d) [max iter]\n'</span>,relres,tol,iter,maxit);
2037             <span class="keyword">end</span>
2038          <span class="keyword">case</span> 2
2039             error(<span class="string">'error: PCG ill-conditioned preconditioner M'</span>);
2040          <span class="keyword">case</span> 3
2041             <span class="keyword">if</span> opt.verbose &gt; 1
2042                fprintf(<span class="string">'      PCG: relres=%g &gt; tol=%g @ iter#%d (max#%d) [stagnated]\n'</span>,relres,tol,iter,maxit);
2043             <span class="keyword">end</span>
2044          <span class="keyword">case</span> 4
2045             error(<span class="string">'error: PCG a scalar quantity became too large or small to continue'</span>);
2046          <span class="keyword">otherwise</span>
2047             error(sprintf(<span class="string">'error: PCG unrecognized flag=%d'</span>,flag));
2048       <span class="keyword">end</span>
2049 <span class="comment">% NOTE PCG is still a work in progress and generally problem specific</span>
2050 <span class="comment">%      % plot convergence for pcg()</span>
2051 <span class="comment">%      clf;</span>
2052 <span class="comment">%         xlabel('iteration #');</span>
2053 <span class="comment">%         ylabel('relative residual');</span>
2054 <span class="comment">%         xx = 0:length(resvec)-1;</span>
2055 <span class="comment">%         semilogy(xx,resvec/norm(RHS),'b.');</span>
2056 <span class="comment">%         hold on;</span>
2057 <span class="comment">%         legend('no preconditioner');</span>
2058 <span class="comment">%hold on</span>
2059 <span class="comment">%% sparsity strategies: www.cerfacs.fr/algor/reports/Dissertations/TH_PA_02_48.pdf</span>
2060 <span class="comment">%sJ = J; sJ(J/max(J(:)) &gt; 0.005) = 0; sJ=sparse(sJ); % sparsify J</span>
2061 <span class="comment">%M = ichol(sJ'*W*sJ + hps2RtR + speye(length(J)));</span>
2062 <span class="comment">%      [dx, flag, relres, iter, resvec] = pcg(LHS, RHS, tol, maxit, M);</span>
2063 <span class="comment">%         semilogy(xx,resvec/norm(RHS),'r.');</span>
2064 <span class="comment">%         legend('no P', 'IC(sp(J'')*W*sp(J) + hps2RtR)');</span>
2065 <span class="comment">%</span>
2066 <span class="comment">%</span>
2067 <span class="comment">%clf; Jj=J(:,1:800); imagesc(Jj'*Jj);</span>
2068 
2069       <span class="comment">% compare with gmres, bicgstab, lsqr</span>
2070       <span class="comment">% try preconditioners ilu, ichol (incomplete LU or Cholesky decomp.)</span>
2071 
2072       <span class="comment">%rethrow(ME); % we assume this is an 'excessive memory requested' failure</span>
2073    <span class="keyword">end</span>
2074 
2075 <span class="comment">% for each argument, returns 1 if the function depends on it, 0 otherwise</span>
2076 <span class="comment">% 'zero' arguments do not need to be calculated since they don't get used</span>
2077 <a name="_sub40" href="#_subfunctions" class="code">function args = function_depends_upon(func, argn)</a>
2078    <span class="comment">% build function call</span>
2079    str = sprintf(<span class="string">'%s('</span>,func2str(func));
2080    args = zeros(argn,1);
2081    <span class="keyword">for</span> i = 1:argn-1
2082       str = [str sprintf(<span class="string">'a(%d),'</span>,i)];
2083    <span class="keyword">end</span>
2084    str = [str sprintf(<span class="string">'a(%d))'</span>,argn)];
2085    <span class="comment">% baseline</span>
2086    a = ones(argn,1)*2;
2087    x = eval(str);
2088    <span class="comment">% now check for a difference at each argument</span>
2089    <span class="keyword">for</span> i = 1:argn
2090       a = ones(argn,1)*2;
2091       a(i) = 0;
2092       y = eval(str);
2093       <span class="keyword">if</span> any(x ~= y)
2094          args(i) = 1;
2095       <span class="keyword">end</span>
2096    <span class="keyword">end</span>
2097 
2098 <span class="comment">% this function just passes data from its input to its output</span>
2099 <a name="_sub41" href="#_subfunctions" class="code">function out = null_func(in, varargin);</a>
2100    out = in;
2101 
2102 <span class="comment">% this function always returns one</span>
2103 <a name="_sub42" href="#_subfunctions" class="code">function [out, x, y, z] = ret1_func(varargin);</a>
2104    out = 1;
2105    x = [];
2106    y = [];
2107    z = [];
2108 
2109 <span class="comment">% if required, expand the coarse-to-fine matrix to cover the background of the image</span>
2110 <span class="comment">% this is removed at the end of the iterations</span>
2111 <a name="_sub43" href="#_subfunctions" class="code">function [inv_model, opt] = append_c2f_background(inv_model, opt)</a>
2112     <span class="comment">% either there is already a background</span>
2113     <span class="comment">% or none is required --&gt; -1 means we go to work building one</span>
2114     <span class="keyword">if</span> opt.c2f_background &gt;= 0
2115       <span class="keyword">return</span>
2116     <span class="keyword">end</span>
2117     <span class="comment">% check that all elements get assigned a conductivity</span>
2118     <span class="comment">% through the c2f conversion</span>
2119     c2f = inv_model.fwd_model.coarse2fine; <span class="comment">% coarse-to-fine mesh mapping</span>
2120     nf = size(inv_model.fwd_model.elems,1); <span class="comment">% number of fine elements</span>
2121     nc = size(c2f,2); <span class="comment">% number of coarse elements</span>
2122     <span class="comment">% ... each element of fel aught to sum to '1' since the</span>
2123     <span class="comment">% elem_data is being assigned from a continuous unit</span>
2124     <span class="comment">% surface value</span>
2125     <span class="comment">% now, find any fine elements that are not fully</span>
2126     <span class="comment">% mapped between the two meshes (&lt;1) w/in a tolerance</span>
2127     <span class="comment">% related to the number of additions in the summation</span>
2128     fel = sum(c2f,2); <span class="comment">% collapse mapping onto the fwd_model elements</span>
2129     n = find(fel &lt; 1 - (1e3+nc)*eps);
2130     <span class="comment">% ... 1e3 is a fudge factor since we don't care too much</span>
2131     <span class="comment">%     about small area mapping errors</span>
2132     <span class="comment">% if we do have some unassigned elements,</span>
2133     <span class="comment">% expand c2f and add a background element to the 'elem_data'</span>
2134     <span class="keyword">if</span> length(n) ~= 0
2135       <span class="keyword">if</span>(opt.verbose &gt; 1)
2136         fprintf(<span class="string">'  c2f: adding background conductivity to %d\n    fwd_model elements not covered by rec_model\n'</span>, length(n));
2137       <span class="keyword">end</span>
2138       c2f(n,nc+1) = 1 - fel(n);
2139       inv_model.fwd_model.coarse2fine = c2f;
2140       opt.c2f_background = nc+1;
2141       <span class="keyword">if</span> opt.c2f_background_fixed
2142          <span class="comment">% TODO assumes conductivity/resistivity is the *first* parameterization</span>
2143          opt.elem_fixed(end+1) = nc+1;
2144       <span class="keyword">end</span>
2145     <span class="keyword">end</span>
2146     <span class="comment">% TODO assumes conductivity/resistivity is the *first* parameterization</span>
2147     opt.elem_len(1) = {size(c2f,2)}; <span class="comment">% elem_len +1</span>
2148 
2149 <a name="_sub44" href="#_subfunctions" class="code">function [img, opt] = strip_c2f_background(img, opt, indent)</a>
2150     <span class="keyword">if</span> nargin &lt; 3
2151        indent = <span class="string">''</span>;
2152     <span class="keyword">end</span>
2153     <span class="comment">% nothing to do?</span>
2154     <span class="keyword">if</span> opt.c2f_background &lt;= 0
2155       <span class="keyword">return</span>;
2156     <span class="keyword">end</span>
2157 
2158     <span class="comment">% if there are multiple 'params' (parametrizations), we assume its the first</span>
2159     <span class="comment">% TODO -- this isn't a great assumption but it'll work for now,</span>
2160     <span class="comment">%         we should add a better (more general) mechanism</span>
2161     in = img.current_params;
2162     out = opt.elem_output;
2163     <span class="keyword">if</span> iscell(in)
2164        in = in{1};
2165     <span class="keyword">end</span>
2166     <span class="keyword">if</span> iscell(out)
2167        out = out{1};
2168     <span class="keyword">end</span>
2169 
2170     <span class="comment">% go about cleaning up the background</span>
2171     e = opt.c2f_background;
2172     <span class="comment">% take backgtround elements and convert to output</span>
2173     <span class="comment">% 'params' (resistivity, etc)</span>
2174     bg = <a href="#_sub49" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(img.elem_data(e), in, out);
2175     img.elem_data_background = bg;
2176     <span class="comment">% remove elements from elem_data &amp; c2f</span>
2177     img.elem_data(e) = [];
2178     img.fwd_model.coarse2fine(:,e) = [];
2179     <span class="comment">% remove our element from the lists</span>
2180     opt.c2f_background = 0;
2181     ri = find(opt.elem_fixed == e);
2182     opt.elem_fixed(ri) = [];
2183     <span class="keyword">if</span> isfield(img, <span class="string">'params_sel'</span>)
2184        <span class="keyword">for</span> i = 1:length(img.params_sel)
2185           t = img.params_sel{i};
2186           ti = find(t == e);
2187           t(ti) = []; <span class="comment">% rm 'e' from the list of params_sel</span>
2188           ti = find(t &gt; e);
2189           t(ti) = t(ti)-1; <span class="comment">% down-count element indices greater than our deleted one</span>
2190           img.params_sel{i} = t;
2191        <span class="keyword">end</span>
2192     <span class="keyword">end</span>
2193 
2194     <span class="comment">% show what we got for a background value</span>
2195     <span class="keyword">if</span>(opt.verbose &gt; 1)
2196        bg = img.elem_data_background;
2197        bg = <a href="#_sub49" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(bg, in, <span class="string">'resistivity'</span>);
2198        fprintf(<span class="string">'%s  background conductivity: %0.1f Ohm.m\n'</span>, indent, bg);
2199     <span class="keyword">end</span>
2200 
2201 <a name="_sub45" href="#_subfunctions" class="code">function b = has_params(s)</a>
2202 b = false;
2203 <span class="keyword">if</span> isstruct(s)
2204    b = any(ismember(fieldnames(s),<a href="../../../eidors/models/supported_params.html" class="code" title="function list = supported_params">supported_params</a>));
2205 <span class="keyword">end</span>
2206 
2207 <span class="comment">% wrapper function for to_base_types</span>
2208 <a name="_sub46" href="#_subfunctions" class="code">function out = map_img_base_types(img)</a>
2209   out = <a href="#_sub47" class="code" title="subfunction type = to_base_types(type)">to_base_types</a>(img.current_params);
2210 
2211 <span class="comment">% convert from know types to their base types</span>
2212 <span class="comment">% A helper function for getting to a basic paramterization</span>
2213 <span class="comment">% prior to any required scaling, etc.</span>
2214 <a name="_sub47" href="#_subfunctions" class="code">function type = to_base_types(type)</a>
2215   <span class="keyword">if</span> ~iscell(type)
2216      type = {type};
2217   <span class="keyword">end</span>
2218   <span class="keyword">for</span> i = 1:length(type);
2219      type(i) = {strrep(type{i}, <span class="string">'log_'</span>, <span class="string">''</span>)};
2220      type(i) = {strrep(type{i}, <span class="string">'log10_'</span>, <span class="string">''</span>)};
2221      type(i) = {strrep(type{i}, <span class="string">'resistivity'</span>, <span class="string">'conductivity'</span>)};
2222      type(i) = {strrep(type{i}, <span class="string">'apparent_resistivity'</span>, <span class="string">'voltage'</span>)};
2223   <span class="keyword">end</span>
2224 
2225 <a name="_sub48" href="#_subfunctions" class="code">function img = map_img(img, out);</a>
2226    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(img.elem_data, <span class="string">'img-pre'</span>);
2227    <span class="keyword">try</span>
2228        in = img.current_params;
2229    <span class="keyword">catch</span>
2230        in = {<span class="string">'conductivity'</span>};
2231    <span class="keyword">end</span>
2232    <span class="comment">% make cell array of strings</span>
2233    <span class="keyword">if</span> ischar(in)
2234       in = {in};
2235       img.current_params = in;
2236    <span class="keyword">end</span>
2237    <span class="keyword">if</span> ischar(out)
2238       out = {out};
2239    <span class="keyword">end</span>
2240 
2241    <span class="comment">% if we have mixed data, check that we have a selector to differentiate between them</span>
2242    <span class="keyword">if</span> ~isfield(img, <span class="string">'params_sel'</span>)
2243       <span class="keyword">if</span> length(in(:)) == 1
2244          img.params_sel = {1:size(img.elem_data,1)};
2245       <span class="keyword">else</span>
2246          error(<span class="string">'found multiple parametrizations (params) but no params_sel cell array in img'</span>);
2247       <span class="keyword">end</span>
2248    <span class="keyword">end</span>
2249 
2250    <span class="comment">% create data?! we don't know how</span>
2251    <span class="keyword">if</span> length(out(:)) &gt; length(in(:))
2252       error(<span class="string">'missing data (more out types than in types)'</span>);
2253    <span class="keyword">elseif</span> length(out(:)) &lt; length(in(:))
2254       <span class="comment">% delete data: we can do that</span>
2255       <span class="comment">% TODO we could genearlize this into a reorganizing tool BUT we're just</span>
2256       <span class="comment">% interested in something that works, so if we have more than one out(:),</span>
2257       <span class="comment">% we don't know what to do currently and error out</span>
2258       <span class="keyword">if</span> length(out(:)) ~= 1
2259          error(<span class="string">'map_img can convert ALL parameters or select a SINGLE output type from multiple input types'</span>);
2260       <span class="keyword">end</span>
2261       inm  = <a href="#_sub47" class="code" title="subfunction type = to_base_types(type)">to_base_types</a>(in);
2262       outm = <a href="#_sub47" class="code" title="subfunction type = to_base_types(type)">to_base_types</a>(out);
2263       del = sort(find(~strcmp(outm(1), inm(:))), <span class="string">'descend'</span>); <span class="comment">% we do this loop backwards in the hopes of avoiding shuffling data that is about to be deleted</span>
2264       <span class="keyword">if</span> length(del)+1 ~= length(in)
2265          error(<span class="string">'Confused about what to remove from the img. You''ll need to sort the parametrizations out yourself when removing data.'</span>);
2266       <span class="keyword">end</span>
2267       <span class="keyword">for</span> i = del(:)' <span class="comment">% delete each of the extra indices</span>
2268          ndel = length(img.params_sel{i}); <span class="comment">% number of deleted elements</span>
2269          <span class="keyword">for</span> j = i+1:length(img.params_sel)
2270             img.params_sel{j} = img.params_sel{j} - ndel;
2271          <span class="keyword">end</span>
2272          img.elem_data(img.params_sel{i}) = []; <span class="comment">% rm elem_data</span>
2273          img.params_sel(i) = []; <span class="comment">% rm params_sel</span>
2274          img.current_params(i) = []; <span class="comment">% rm current_params</span>
2275       <span class="keyword">end</span>
2276       in = img.current_params;
2277    <span class="keyword">end</span>
2278 
2279    <span class="comment">% the sizes now match, we can do the mapping</span>
2280    <span class="keyword">for</span> i = 1:length(out(:))
2281       <span class="comment">% map the data</span>
2282       x = img.elem_data(img.params_sel{i});
2283       x = <a href="#_sub49" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(x, in{i}, out{i});
2284       img.elem_data(img.params_sel{i}) = x;
2285       img.current_params{i} = out{i};
2286    <span class="keyword">end</span>
2287    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(img.elem_data, <span class="string">'img-post'</span>);
2288 
2289    <span class="comment">% clean up params_sel/current_params if we only have one parametrization</span>
2290    <span class="keyword">if</span> length(img.current_params(:)) == 1
2291       img.current_params = img.current_params{1};
2292       img = rmfield(img, <span class="string">'params_sel'</span>); <span class="comment">% unnecessary since we know its all elem_data</span>
2293    <span class="keyword">end</span>
2294 
2295 <a name="_sub49" href="#_subfunctions" class="code">function x = map_data(x, in, out)</a>
2296    <span class="comment">% check that in and out are single strings, not lists of strings</span>
2297    <span class="keyword">if</span> ~ischar(in)
2298       <span class="keyword">if</span> iscell(in) &amp;&amp; (length(in(:)) == 1)
2299          in = in{1};
2300       <span class="keyword">else</span>
2301          error(<span class="string">'expecting single string for map_data() &quot;in&quot; type'</span>);
2302       <span class="keyword">end</span>
2303    <span class="keyword">end</span>
2304    <span class="keyword">if</span> ~ischar(out)
2305       <span class="keyword">if</span> iscell(out) &amp;&amp; (length(out(:)) == 1)
2306          out = out{1};
2307       <span class="keyword">else</span>
2308          error(<span class="string">'expecting single string for map_data() &quot;out&quot; type'</span>);
2309       <span class="keyword">end</span>
2310    <span class="keyword">end</span>
2311 
2312    <span class="comment">% quit early if there is nothing to do</span>
2313    <span class="keyword">if</span> strcmp(in, out) <span class="comment">% in == out</span>
2314       <span class="keyword">return</span>; <span class="comment">% do nothing</span>
2315    <span class="keyword">end</span>
2316 
2317    <span class="comment">% resistivity to conductivity conversion</span>
2318    <span class="comment">% we can't get here if in == out</span>
2319    <span class="comment">% we've already checked for log convserions on input or output</span>
2320    <span class="keyword">if</span> any(strcmp(in,  {<span class="string">'resistivity'</span>, <span class="string">'conductivity'</span>})) &amp;&amp; <span class="keyword">...</span>
2321       any(strcmp(out, {<span class="string">'resistivity'</span>, <span class="string">'conductivity'</span>}))
2322       x = 1./x; <span class="comment">% conductivity &lt;-&gt; resistivity</span>
2323    <span class="comment">% log conversion</span>
2324    <span class="keyword">elseif</span> any(strcmp({in(1:3), out(1:3)}, <span class="string">'log'</span>))
2325       <span class="comment">% log_10 x -&gt; x</span>
2326       <span class="keyword">if</span> strcmp(in(1:6), <span class="string">'log10_'</span>)
2327          <span class="keyword">if</span> any(x &gt;= log10(realmax)-eps) warning(<span class="string">'loss of precision -&gt; inf'</span>); <span class="keyword">end</span>
2328          x = <a href="#_sub49" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(10.^x, in(7:end), out);
2329       <span class="comment">% ln x -&gt; x</span>
2330       <span class="keyword">elseif</span> strcmp(in(1:4), <span class="string">'log_'</span>)
2331          <span class="keyword">if</span> any(x &gt;= log(realmax)-eps) warning(<span class="string">'loss of precision -&gt; inf'</span>); <span class="keyword">end</span>
2332          x = <a href="#_sub49" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(exp(x), in(5:end), out);
2333       <span class="comment">% x -&gt; log_10 x</span>
2334       <span class="keyword">elseif</span> strcmp(out(1:6), <span class="string">'log10_'</span>)
2335          <span class="keyword">if</span> any(x &lt;= 0 + eps) warning(<span class="string">'loss of precision -&gt; -inf'</span>); <span class="keyword">end</span>
2336          x = log10(<a href="#_sub49" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(x, in, out(7:end)));
2337       <span class="comment">% x -&gt; ln x</span>
2338       <span class="keyword">elseif</span> strcmp(out(1:4), <span class="string">'log_'</span>)
2339          <span class="keyword">if</span> any(x &lt;= 0 + eps) warning(<span class="string">'loss of precision -&gt; -inf'</span>); <span class="keyword">end</span>
2340          x = log(<a href="#_sub49" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(x, in, out(5:end)));
2341       <span class="keyword">else</span>
2342          error(sprintf(<span class="string">'unknown conversion (log conversion?) %s - &gt; %s'</span>, in, out));
2343       <span class="keyword">end</span>
2344    <span class="keyword">else</span>
2345       error(<span class="string">'unknown conversion %s -&gt; %s'</span>, in, out);
2346    <span class="keyword">end</span>
2347    x(x == +inf) = +realmax;
2348    x(x == -inf) = -realmax;
2349    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(x, <span class="string">'map_data-post'</span>);
2350 
2351 <a name="_sub50" href="#_subfunctions" class="code">function b = map_meas(b, N, in, out)</a>
2352    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(b, <span class="string">'map_meas-pre'</span>);
2353    <span class="keyword">if</span> strcmp(in, out) <span class="comment">% in == out</span>
2354       <span class="keyword">return</span>; <span class="comment">% do nothing</span>
2355    <span class="keyword">end</span>
2356 
2357    <span class="comment">% resistivity to conductivity conversion</span>
2358    <span class="comment">% we can't get here if in == out</span>
2359    <span class="keyword">if</span>     strcmp(in, <span class="string">'voltage'</span>) &amp;&amp; strcmp(out, <span class="string">'apparent_resistivity'</span>)
2360       <span class="keyword">if</span> N == 1
2361          error(<span class="string">'missing apparent resistivity conversion factor N'</span>);
2362       <span class="keyword">end</span>
2363       b = N * b; <span class="comment">% voltage -&gt; apparent resistivity</span>
2364    <span class="keyword">elseif</span> strcmp(in, <span class="string">'apparent_resistivity'</span>) &amp;&amp; strcmp(out, <span class="string">'voltage'</span>)
2365       <span class="keyword">if</span> N == 1
2366          error(<span class="string">'missing apparent resistivity conversion factor N'</span>);
2367       <span class="keyword">end</span>
2368       b = N \ b; <span class="comment">% apparent resistivity -&gt; voltage</span>
2369    <span class="comment">% log conversion</span>
2370    <span class="keyword">elseif</span> any(strcmp({in(1:3), out(1:3)}, <span class="string">'log'</span>))
2371       <span class="comment">% log_10 b -&gt; b</span>
2372       <span class="keyword">if</span> strcmp(in(1:6), <span class="string">'log10_'</span>)
2373          <span class="keyword">if</span> any(b &gt; log10(realmax)-eps) warning(<span class="string">'loss of precision -&gt; inf'</span>); <span class="keyword">end</span>
2374          b = <a href="#_sub50" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(10.^b, N, in(7:end), out);
2375       <span class="comment">% ln b -&gt; b</span>
2376       <span class="keyword">elseif</span> strcmp(in(1:4), <span class="string">'log_'</span>)
2377          <span class="keyword">if</span> any(b &gt; log(realmax)-eps) warning(<span class="string">'loss of precision -&gt; inf'</span>); <span class="keyword">end</span>
2378          b = <a href="#_sub50" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(exp(b), N, in(5:end), out);
2379       <span class="comment">% b -&gt; log_10 b</span>
2380       <span class="keyword">elseif</span> strcmp(out(1:6), <span class="string">'log10_'</span>)
2381          <span class="keyword">if</span> any(b &lt;= 0+eps) warning(<span class="string">'loss of precision -&gt; -inf'</span>); <span class="keyword">end</span>
2382          b = log10(<a href="#_sub50" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(b, N, in, out(7:end)));
2383       <span class="comment">% b -&gt; ln b</span>
2384       <span class="keyword">elseif</span> strcmp(out(1:4), <span class="string">'log_'</span>)
2385          <span class="keyword">if</span> any(b &lt;= 0+eps) warning(<span class="string">'loss of precision -&gt; -inf'</span>); <span class="keyword">end</span>
2386          b = log(<a href="#_sub50" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(b, N, in, out(5:end)));
2387       <span class="keyword">else</span>
2388          error(sprintf(<span class="string">'unknown conversion (log conversion?) %s - &gt; %s'</span>, in, out));
2389       <span class="keyword">end</span>
2390    <span class="keyword">else</span>
2391       error(<span class="string">'unknown conversion %s -&gt; %s'</span>, in, out);
2392    <span class="keyword">end</span>
2393    <a href="#_sub27" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(b, <span class="string">'map_meas-post'</span>);
2394 
2395 <a name="_sub51" href="#_subfunctions" class="code">function x=range(y)</a>
2396 x=max(y)-min(y);
2397 
2398 <a name="_sub52" href="#_subfunctions" class="code">function pass=do_unit_test(solver)</a>
2399    <span class="keyword">if</span> nargin == 0
2400       solver = <span class="string">'inv_solve_core'</span>;
2401       test = <span class="string">'all'</span>
2402    <span class="keyword">elseif</span> ((length(solver) &lt; 9) || ~strcmp(solver(1:9),<span class="string">'inv_solve'</span>))
2403       test = solver;
2404       solver = <span class="string">'inv_solve_core'</span>;
2405    <span class="keyword">else</span>
2406       test = <span class="string">'all'</span>
2407    <span class="keyword">end</span>
2408    <span class="keyword">switch</span>(test)
2409       <span class="keyword">case</span> <span class="string">'all'</span>
2410          <a href="#_sub55" class="code" title="subfunction do_unit_test_sub">do_unit_test_sub</a>;
2411          <a href="#_sub54" class="code" title="subfunction do_unit_test_diff()">do_unit_test_diff</a>;
2412          <a href="#_sub58" class="code" title="subfunction do_unit_test_rec1(solver)">do_unit_test_rec1</a>(solver);
2413          <a href="#_sub62" class="code" title="subfunction do_unit_test_rec2(solver)">do_unit_test_rec2</a>(solver);
2414          <a href="#_sub59" class="code" title="subfunction do_unit_test_rec_mv(solver)">do_unit_test_rec_mv</a>(solver);
2415          <a href="#_sub63" class="code" title="subfunction do_unit_test_diffseq(solver)">do_unit_test_diffseq</a>(solver);
2416          <a href="#_sub64" class="code" title="subfunction do_unit_test_absseq(solver)">do_unit_test_absseq</a>(solver);
2417       <span class="keyword">case</span> <span class="string">'sub'</span>
2418          <a href="#_sub55" class="code" title="subfunction do_unit_test_sub">do_unit_test_sub</a>;
2419       <span class="keyword">case</span> <span class="string">'diff'</span>
2420          <a href="#_sub54" class="code" title="subfunction do_unit_test_diff()">do_unit_test_diff</a>;
2421       <span class="keyword">case</span> <span class="string">'rec1'</span>
2422          <a href="#_sub58" class="code" title="subfunction do_unit_test_rec1(solver)">do_unit_test_rec1</a>(solver);
2423       <span class="keyword">case</span> <span class="string">'rec2'</span>
2424          <a href="#_sub62" class="code" title="subfunction do_unit_test_rec2(solver)">do_unit_test_rec2</a>(solver);
2425       <span class="keyword">case</span> <span class="string">'rec_mv'</span>
2426          <a href="#_sub59" class="code" title="subfunction do_unit_test_rec_mv(solver)">do_unit_test_rec_mv</a>(solver);
2427       <span class="keyword">case</span> <span class="string">'diffseq'</span>
2428          <a href="#_sub63" class="code" title="subfunction do_unit_test_diffseq(solver)">do_unit_test_diffseq</a>(solver);
2429       <span class="keyword">case</span> <span class="string">'absseq'</span>
2430          <a href="#_sub64" class="code" title="subfunction do_unit_test_absseq(solver)">do_unit_test_absseq</a>(solver);
2431       <span class="keyword">otherwise</span>
2432          error([<span class="string">'unrecognized solver or tests: '</span> test]);
2433    <span class="keyword">end</span>
2434 
2435 <a name="_sub53" href="#_subfunctions" class="code">function [imdl, vh, imgi, vi] = unit_test_imdl()</a>
2436    imdl = <a href="../../../eidors/models/mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'h22e'</span>,32);
2437    imdl.solve = <span class="string">'inv_solve_core'</span>;
2438    imdl.inv_solve_core.max_iterations = 1; <span class="comment">% see that we get the same as the GN 1-step difference soln</span>
2439    imdl.inv_solve_core.verbose = 0;
2440    imdl.reconst_type = <span class="string">'difference'</span>;
2441    imgh = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl,1);
2442    vh = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(imgh);
2443 
2444    <span class="keyword">if</span> nargout &gt; 2
2445       imgi = imgh;
2446       ctrs = <a href="../../../eidors/models/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(imdl.fwd_model);
2447       x = ctrs(:,1);
2448       y = ctrs(:,2);
2449       r1 = sqrt((x+15).^2 + (y+25).^2);
2450       r2 = sqrt((x-85).^2 + (y+65).^2);
2451       imgi.elem_data(r1&lt;25)= 1/2;
2452       imgi.elem_data(r2&lt;30)= 2;
2453       clf; <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgi,1);
2454       vi = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(imgi);
2455    <span class="keyword">end</span>
2456 
2457 <a name="_sub54" href="#_subfunctions" class="code">function do_unit_test_diff()</a>
2458    [imdl, vh, imgi, vi] = <a href="#_sub53" class="code" title="subfunction [imdl, vh, imgi, vi] = unit_test_imdl()">unit_test_imdl</a>();
2459 
2460    imdl.reconst_type = <span class="string">'absolute'</span>;
2461    img_abs = <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl,vi);
2462    imdl.reconst_type = <span class="string">'difference'</span>;
2463    img_itr = <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl,vh,vi);
2464    imdl.inv_solve_core.max_iterations = 1; <span class="comment">% see that we get the same as the GN 1-step difference soln</span>
2465    imdl.inv_solve_core.line_search_func = @<a href="#_sub42" class="code" title="subfunction [out, x, y, z] = ret1_func(varargin);">ret1_func</a>;
2466    img_it1 = <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl,vh,vi);
2467    imdl.solve = <span class="string">'inv_solve_diff_GN_one_step'</span>;
2468    img_gn1 = <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl,vh,vi);
2469    clf; subplot(223); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img_it1,1); title(<span class="string">'GN 1-iter'</span>);
2470         subplot(224); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img_gn1,1); title(<span class="string">'GN 1-step'</span>);
2471         subplot(221); h=<a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgi,1);  title(<span class="string">'fwd model'</span>); set(h,<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>);
2472         subplot(222); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img_itr,1); title(<span class="string">'GN 10-iter'</span>);
2473         subplot(222); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img_abs,1); title(<span class="string">'GN abs 10-iter'</span>);
2474    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'core (1-step) vs. diff_GN_one_step'</span>, img_it1.elem_data, img_gn1.elem_data, eps*15);
2475    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'core (1-step) vs. core (N-step)   '</span>, img_it1.elem_data, img_itr.elem_data, eps);
2476    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'core (N-step) vs. abs  (N-step)   '</span>, img_it1.elem_data, img_abs.elem_data-1, eps);
2477 
2478 <span class="comment">% test sub-functions</span>
2479 <span class="comment">% map_meas, map_data</span>
2480 <span class="comment">% jacobian scalings</span>
2481 <a name="_sub55" href="#_subfunctions" class="code">function do_unit_test_sub</a>
2482 d = 1;
2483 <span class="keyword">while</span> d ~= 1 &amp; d ~= 0
2484   d = rand(1);
2485 <span class="keyword">end</span>
2486 disp(<span class="string">'TEST: map_data()'</span>);
2487 elem_types = {<span class="string">'conductivity'</span>, <span class="string">'log_conductivity'</span>, <span class="string">'log10_conductivity'</span>, <span class="keyword">...</span>
2488               <span class="string">'resistivity'</span>,  <span class="string">'log_resistivity'</span>,  <span class="string">'log10_resistivity'</span>};
2489 expected = [d         log(d)         log10(d)      1./d      log(1./d)      log10(1./d); <span class="keyword">...</span>
2490             exp(d)    d              log10(exp(d)) 1./exp(d) log(1./exp(d)) log10(1./exp(d)); <span class="keyword">...</span>
2491             10.^d     log(10.^d )    d             1./10.^d  log(1./10.^d ) log10(1./10.^d ); <span class="keyword">...</span>
2492             1./d      log(1./d  )    log10(1./d)   d         log(d)         log10(d); <span class="keyword">...</span>
2493             1./exp(d) log(1./exp(d)) log10(1./exp(d)) exp(d) d              log10(exp(d)); <span class="keyword">...</span>
2494             1./10.^d  log(1./10.^d)  log10(1./10.^d)  10.^d  log(10.^d)     d ];
2495 <span class="keyword">for</span> i = 1:length(elem_types)
2496   <span class="keyword">for</span> j = 1:length(elem_types)
2497     <a href="#_sub56" class="code" title="subfunction test_map_data(data, in, out, expected)">test_map_data</a>(d, elem_types{i}, elem_types{j}, expected(i,j));
2498   <span class="keyword">end</span>
2499 <span class="keyword">end</span>
2500 
2501 disp(<span class="string">'TEST: map_meas()'</span>);
2502 N = 1/15;
2503 Ninv = 1/N;
2504 <span class="comment">% function b = map_meas(b, N, in, out)</span>
2505 elem_types = {<span class="string">'voltage'</span>, <span class="string">'log_voltage'</span>, <span class="string">'log10_voltage'</span>, <span class="keyword">...</span>
2506               <span class="string">'apparent_resistivity'</span>,  <span class="string">'log_apparent_resistivity'</span>,  <span class="string">'log10_apparent_resistivity'</span>};
2507 expected = [d         log(d)         log10(d)      N*d      log(N*d)      log10(N*d); <span class="keyword">...</span>
2508             exp(d)    d              log10(exp(d)) N*exp(d) log(N*exp(d)) log10(N*exp(d)); <span class="keyword">...</span>
2509             10.^d     log(10.^d )    d             N*10.^d  log(N*10.^d ) log10(N*10.^d ); <span class="keyword">...</span>
2510             Ninv*d      log(Ninv*d  )    log10(Ninv*d)   d         log(d)         log10(d); <span class="keyword">...</span>
2511             Ninv*exp(d) log(Ninv*exp(d)) log10(Ninv*exp(d)) exp(d) d              log10(exp(d)); <span class="keyword">...</span>
2512             Ninv*10.^d  log(Ninv*10.^d)  log10(Ninv*10.^d)  10.^d  log(10.^d)     d ];
2513 <span class="keyword">for</span> i = 1:length(elem_types)
2514   <span class="keyword">for</span> j = 1:length(elem_types)
2515     <a href="#_sub57" class="code" title="subfunction test_map_meas(data, N, in, out, expected)">test_map_meas</a>(d, N, elem_types{i}, elem_types{j}, expected(i,j));
2516   <span class="keyword">end</span>
2517 <span class="keyword">end</span>
2518 
2519 disp(<span class="string">'TEST: Jacobian scaling'</span>);
2520 d = [d d]';
2521 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( <span class="keyword">...</span>
2522    sprintf(<span class="string">'Jacobian scaling (%s)'</span>, <span class="string">'conductivity'</span>), <span class="keyword">...</span>
2523    <a href="#_sub42" class="code" title="subfunction [out, x, y, z] = ret1_func(varargin);">ret1_func</a>(d), 1);
2524 
2525 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( <span class="keyword">...</span>
2526    sprintf(<span class="string">'Jacobian scaling (%s)'</span>, <span class="string">'log_conductivity'</span>), <span class="keyword">...</span>
2527    <a href="#_sub15" class="code" title="subfunction S = dx_dlogx(x);">dx_dlogx</a>(d), diag(d));
2528 
2529 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( <span class="keyword">...</span>
2530    sprintf(<span class="string">'Jacobian scaling (%s)'</span>, <span class="string">'log10_conductivity'</span>), <span class="keyword">...</span>
2531    <a href="#_sub16" class="code" title="subfunction S = dx_dlog10x(x);">dx_dlog10x</a>(d), diag(d)*log(10));
2532 
2533 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( <span class="keyword">...</span>
2534    sprintf(<span class="string">'Jacobian scaling (%s)'</span>, <span class="string">'resistivity'</span>), <span class="keyword">...</span>
2535    <a href="#_sub17" class="code" title="subfunction S = dx_dy(x);">dx_dy</a>(d), diag(-d.^2));
2536 
2537 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( <span class="keyword">...</span>
2538    sprintf(<span class="string">'Jacobian scaling (%s)'</span>, <span class="string">'log_resistivity'</span>), <span class="keyword">...</span>
2539    <a href="#_sub18" class="code" title="subfunction S = dx_dlogy(x);">dx_dlogy</a>(d), diag(-d));
2540 
2541 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( <span class="keyword">...</span>
2542    sprintf(<span class="string">'Jacobian scaling (%s)'</span>, <span class="string">'log10_resistivity'</span>), <span class="keyword">...</span>
2543    <a href="#_sub19" class="code" title="subfunction S = dx_dlog10y(x);">dx_dlog10y</a>(d), diag(-d)/log(10));
2544 
2545 
2546 <a name="_sub56" href="#_subfunctions" class="code">function test_map_data(data, in, out, expected)</a>
2547 <span class="comment">%fprintf('TEST: map_data(%s -&gt; %s)\n', in, out);</span>
2548    calc_val = <a href="#_sub49" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(data, in, out);
2549    str = sprintf(<span class="string">'map_data(%s -&gt; %s)'</span>, in, out);
2550    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(str, calc_val, expected)
2551 
2552 <a name="_sub57" href="#_subfunctions" class="code">function test_map_meas(data, N, in, out, expected)</a>
2553 <span class="comment">%fprintf('TEST: map_meas(%s -&gt; %s)\n', in, out);</span>
2554    calc_val = <a href="#_sub50" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(data, N, in, out);
2555    str = sprintf(<span class="string">'map_data(%s -&gt; %s)'</span>, in, out);
2556    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(str, calc_val, expected)
2557 
2558 
2559 <span class="comment">% a couple easy reconstructions</span>
2560 <span class="comment">% check c2f, apparent_resistivity, log_conductivity, verbosity don't error out</span>
2561 <a name="_sub58" href="#_subfunctions" class="code">function do_unit_test_rec1(solver)</a>
2562 <span class="comment">% -------------</span>
2563 <span class="comment">% ADAPTED FROM</span>
2564 <span class="comment">% Create simulation data $Id: inv_solve_core.m 5746 2018-04-27 20:56:25Z alistair_boyle $</span>
2565 <span class="comment">%  http://eidors3d.sourceforge.net/tutorial/adv_image_reconst/basic_iterative.shtml</span>
2566 <span class="comment">% 3D Model</span>
2567 [imdl, vh, imgi, vi] = <a href="#_sub53" class="code" title="subfunction [imdl, vh, imgi, vi] = unit_test_imdl()">unit_test_imdl</a>();
2568 imdl.solve = solver;
2569 imdl.reconst_type = <span class="string">'absolute'</span>;
2570 imdl.inv_solve_core.prior_data = 1;
2571 imdl.inv_solve_core.elem_prior = <span class="string">'conductivity'</span>;
2572 imdl.inv_solve_core.elem_working = <span class="string">'log_conductivity'</span>;
2573 imdl.inv_solve_core.meas_working = <span class="string">'apparent_resistivity'</span>;
2574 imdl.inv_solve_core.calc_solution_error = 0;
2575 imdl.inv_solve_core.verbose = 0;
2576 
2577 imgp = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(imgi, <span class="string">'log10_conductivity'</span>);
2578 <span class="comment">% add noise</span>
2579 <span class="comment">%Add 30dB SNR noise to data</span>
2580 <span class="comment">%noise_level= std(vi.meas - vh.meas)/10^(30/20);</span>
2581 <span class="comment">%vi.meas = vi.meas + noise_level*randn(size(vi.meas));</span>
2582 <span class="comment">% Reconstruct Images</span>
2583 img1= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vi);
2584 <span class="comment">% -------------</span>
2585 disp(<span class="string">'TEST: previous solved at default verbosity'</span>);
2586 disp(<span class="string">'TEST: now solve same at verbosity=0 --&gt; should be silent'</span>);
2587 imdl.inv_solve_core.verbose = 0;
2588 <span class="comment">%imdl.inv_solve_core.meas_working = 'apparent_resistivity';</span>
2589 img2= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vi);
2590 <span class="comment">% -------------</span>
2591 imdl.inv_solve_core.elem_output = <span class="string">'log10_resistivity'</span>; <span class="comment">% resistivity output works</span>
2592 img3= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vi);
2593 
2594 disp(<span class="string">'TEST: try coarse2fine mapping with background'</span>);
2595 ctrs= <a href="../../../eidors/models/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(imdl.rec_model);
2596 x= ctrs(:,1); y= ctrs(:,2);
2597 r=sqrt((x+5).^2 + (y+5).^2);
2598 imdl.rec_model.elems(x-y &gt; 300, :) = [];
2599 c2f = <a href="../../../eidors/models/mk_approx_c2f.html" class="code" title="function [mapping, outside] = mk_approx_c2f( f_mdl, c_mdl );">mk_approx_c2f</a>(imdl.fwd_model,imdl.rec_model);
2600 imdl.fwd_model.coarse2fine = c2f;
2601 <span class="comment">% solve</span>
2602 <span class="comment">%imdl.inv_solve_core.verbose = 10;</span>
2603 imdl.inv_solve_core.elem_output = <span class="string">'conductivity'</span>;
2604 img4= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vi);
2605 
2606 clf; subplot(221); h=<a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgp,1); set(h,<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>); axis tight; title(<span class="string">'synthetic data, logC'</span>);
2607    subplot(222); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img1,1); axis tight; title(<span class="string">'#1 verbosity=default'</span>);
2608    subplot(223); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img2,1); axis tight; title(<span class="string">'#2 verbosity=0'</span>);
2609    subplot(223); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img3,1); axis tight; title(<span class="string">'#3 c2f + log10 resistivity out'</span>);
2610    subplot(224); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img4,1); axis tight; title(<span class="string">'#4 c2f cut'</span>);
2611    drawnow;
2612 d1 = img1.elem_data; d2 = img2.elem_data; d3 = img3.elem_data; d4 = img4.elem_data;
2613 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'img1 == img2'</span>, d1, d2, eps);
2614 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'img1 == img3'</span>, d1, 1./(10.^d3), eps);
2615 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'img1 == img4'</span>, (d1(x-y &lt;=300)-d4)./d4, 0, 0.05); <span class="comment">%  +-5% error</span>
2616 
2617 <span class="comment">%clf; subplot(211); plot((img3.elem_data - img1.elem_data)./img1.elem_data);</span>
2618 
2619 <span class="comment">% a couple easy reconstructions with movement or similar</span>
2620 <a name="_sub59" href="#_subfunctions" class="code">function do_unit_test_rec_mv(solver)</a>
2621 disp(<span class="string">'TEST: conductivity and movement --&gt; baseline conductivity only'</span>);
2622 <span class="comment">% -------------</span>
2623 <span class="comment">% ADAPTED FROM</span>
2624 <span class="comment">% Create simulation data $Id: inv_solve_core.m 5746 2018-04-27 20:56:25Z alistair_boyle $</span>
2625 <span class="comment">%  http://eidors3d.sourceforge.net/tutorial/adv_image_reconst/basic_iterative.shtml</span>
2626 <span class="comment">% 3D Model</span>
2627 imdl= <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'c2t4'</span>,16); <span class="comment">% 576 elements</span>
2628 ne = length(imdl.fwd_model.electrode);
2629 nt = length(imdl.fwd_model.elems);
2630 imdl.solve = solver;
2631 imdl.reconst_type = <span class="string">'absolute'</span>;
2632 <span class="comment">% specify the units to work in</span>
2633 imdl.inv_solve_core.meas_input   = <span class="string">'voltage'</span>;
2634 imdl.inv_solve_core.meas_working = <span class="string">'apparent_resistivity'</span>;
2635 imdl.inv_solve_core.elem_prior   = {   <span class="string">'conductivity'</span>   };
2636 imdl.inv_solve_core.prior_data   = {        1           };
2637 imdl.inv_solve_core.elem_working = {<span class="string">'log_conductivity'</span>};
2638 imdl.inv_solve_core.elem_output  = {<span class="string">'log10_conductivity'</span>};
2639 imdl.inv_solve_core.calc_solution_error = 0;
2640 imdl.inv_solve_core.verbose = 0;
2641 imdl.hyperparameter.value = 0.1;
2642 
2643 <span class="comment">% set homogeneous conductivity and simulate</span>
2644 imgsrc= <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( imdl.fwd_model, 1);
2645 vh=<a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(imgsrc);
2646 <span class="comment">% set inhomogeneous conductivity</span>
2647 ctrs= <a href="../../../eidors/models/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(imdl.fwd_model);
2648 x= ctrs(:,1); y= ctrs(:,2);
2649 r1=sqrt((x+5).^2 + (y+5).^2); r2 = sqrt((x-45).^2 + (y-35).^2);
2650 imgsrc.elem_data(r1&lt;50)= 0.05;
2651 imgsrc.elem_data(r2&lt;30)= 100;
2652 
2653 <span class="comment">% inhomogeneous data</span>
2654 vi=<a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>( imgsrc );
2655 <span class="comment">% add noise</span>
2656 <span class="comment">%Add 30dB SNR noise to data</span>
2657 noise_level= std(vi.meas - vh.meas)/10^(30/20);
2658 vi.meas = vi.meas + noise_level*randn(size(vi.meas));
2659 
2660 <span class="comment">% show model</span>
2661 hh=clf; subplot(221); imgp = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(imgsrc, <span class="string">'log10_conductivity'</span>); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgp,1); axis tight; title(<span class="string">'synth baseline, logC'</span>);
2662 
2663 <span class="comment">% Reconstruct Images</span>
2664 img0= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vi);
2665 figure(hh); subplot(222);
2666  img0 = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img0, <span class="string">'log10_conductivity'</span>);
2667  <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img0, 1); axis tight;
2668 
2669 disp(<span class="string">'TEST: conductivity + movement'</span>);
2670 imdl.fwd_model = rmfield(imdl.fwd_model, <span class="string">'jacobian'</span>);
2671 <span class="comment">% specify the units to work in</span>
2672 imdl.inv_solve_core.elem_prior   = {   <span class="string">'conductivity'</span>   , <span class="string">'movement'</span>};
2673 imdl.inv_solve_core.prior_data   = {        1           ,     0     };
2674 imdl.inv_solve_core.RtR_prior    = {     @<a href="../../../eidors/tools/eidors_default.html" class="code" title="function varargout = eidors_default(varargin)">eidors_default</a>, @<a href="#_sub61" class="code" title="subfunction RtR = prior_movement_only(imdl);">prior_movement_only</a>};
2675 imdl.inv_solve_core.elem_len     = {       nt           ,   ne*2    };
2676 imdl.inv_solve_core.elem_working = {  <span class="string">'log_conductivity'</span>, <span class="string">'movement'</span>};
2677 imdl.inv_solve_core.elem_output  = {<span class="string">'log10_conductivity'</span>, <span class="string">'movement'</span>};
2678 imdl.inv_solve_core.jacobian     = { @<a href="../../../eidors/solvers/forward/jacobian_adjoint.html" class="code" title="function J= jacobian_adjoint( fwd_model, img)">jacobian_adjoint</a>  , @<a href="#_sub60" class="code" title="subfunction Jm = jacobian_movement_only (fwd_model, img);">jacobian_movement_only</a>};
2679 imdl.inv_solve_core.hyperparameter = {   [1 1.1 0.9]    ,  sqrt(2e-3)     }; <span class="comment">% multiplied by imdl.hyperparameter.value</span>
2680 imdl.inv_solve_core.verbose = 0;
2681 
2682 <span class="comment">% electrode positions before</span>
2683 nn = [imgsrc.fwd_model.electrode(:).nodes];
2684 elec_orig = imgsrc.fwd_model.nodes(nn,:);
2685 <span class="comment">% set 2% radial movement</span>
2686 nn = imgsrc.fwd_model.nodes;
2687 imgsrc.fwd_model.nodes = nn * [1-0.02 0; 0 1+0.02]; <span class="comment">% 1% compress X, 1% expansion Y, NOT conformal</span>
2688 <span class="comment">% electrode positions after</span>
2689 nn = [imgsrc.fwd_model.electrode(:).nodes];
2690 elec_mv = imgsrc.fwd_model.nodes(nn,:);
2691 
2692 <span class="comment">% inhomogeneous data</span>
2693 vi=<a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>( imgsrc );
2694 <span class="comment">% add noise</span>
2695 <span class="comment">%Add 30dB SNR noise to data</span>
2696 noise_level= std(vi.meas - vh.meas)/10^(30/20);
2697 <span class="comment">%vi.meas = vi.meas + noise_level*randn(size(vi.meas));</span>
2698 
2699 <span class="comment">% show model</span>
2700 nn = [imgsrc.fwd_model.electrode(1:4).nodes];
2701 figure(hh); subplot(223); imgp = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(imgsrc, <span class="string">'log10_conductivity'</span>); <a href="../../../eidors/graphics/matlab/show_fem_move.html" class="code" title="function [hf,hh] = show_fem_move( img, move, scale, options )">show_fem_move</a>(imgp,elec_mv-elec_orig,10,1); axis tight; title(<span class="string">'synth mvmt, logC'</span>);
2702 
2703 <span class="comment">% Reconstruct Images</span>
2704 img1= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vi);
2705 figure(hh); subplot(224);
2706  imgm = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img1, <span class="string">'movement'</span>);
2707  img1 = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img1, <span class="string">'log10_conductivity'</span>);
2708  <a href="../../../eidors/graphics/matlab/show_fem_move.html" class="code" title="function [hf,hh] = show_fem_move( img, move, scale, options )">show_fem_move</a>(img1,reshape(imgm.elem_data,16,2), 10, 1); axis tight;
2709 
2710 d0 = img0.elem_data; d1 = img1.elem_data;
2711 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'img0 == img1 + mvmt'</span>, d0-d1, 0, 0.40);
2712 
2713 <span class="comment">% helper function: calculate jacobian movement by itself</span>
2714 <a name="_sub60" href="#_subfunctions" class="code">function Jm = jacobian_movement_only (fwd_model, img);</a>
2715   pp = <a href="../../../eidors/solvers/forward/fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>(img.fwd_model);
2716   szJm = pp.n_elec * pp.n_dims; <span class="comment">% number of electrodes * dimensions</span>
2717   img = <a href="#_sub48" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, <span class="string">'conductivity'</span>); <span class="comment">% expect conductivity only</span>
2718   Jcm = <a href="../../../eidors/solvers/forward/jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>(fwd_model, img);
2719   Jm = Jcm(:,(end-szJm+1):end);
2720 <span class="comment">%% this plot shows we are grabing the right section of the Jacobian</span>
2721 <span class="comment">%  figure();</span>
2722 <span class="comment">%  subplot(311); imagesc(Jcm); axis ij equal tight; xlabel(sprintf('||Jcm||=%g',norm(Jcm))); colorbar;</span>
2723 <span class="comment">%  Jc = jacobian_adjoint(fwd_model, img);</span>
2724 <span class="comment">%  subplot(312); imagesc([Jc Jm]); axis ij equal tight; xlabel(sprintf('||[Jc Jm]||=%g',norm([Jc Jm]))); colorbar;</span>
2725 <span class="comment">%  dd = abs([Jc Jm]-Jcm); % difference</span>
2726 <span class="comment">%  subplot(313); imagesc(dd); axis ij equal tight; xlabel(sprintf('|| |[Jc Jm]-Jcm| ||=%g',norm(dd))); colorbar;</span>
2727 
2728 <a name="_sub61" href="#_subfunctions" class="code">function RtR = prior_movement_only(imdl);</a>
2729   imdl.image_prior.parameters(1) = 1; <span class="comment">% weighting of movement vs. conductivity ... but we're dropping conductivity here</span>
2730   pp = <a href="../../../eidors/solvers/forward/fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>(imdl.fwd_model);
2731   szPm = pp.n_elec * pp.n_dims; <span class="comment">% number of electrodes * dimensions</span>
2732   RtR = <a href="prior_movement.html" class="code" title="function Reg= prior_movement( inv_model );">prior_movement</a>(imdl);
2733   RtR = RtR((end-szPm+1):<span class="keyword">end</span>,(end-szPm+1):end);
2734 
2735 <a name="_sub62" href="#_subfunctions" class="code">function do_unit_test_rec2(solver)</a>
2736 disp(<span class="string">'TEST: reconstruct a discontinuity'</span>);
2737 [imdl, vh] = <a href="#_sub53" class="code" title="subfunction [imdl, vh, imgi, vi] = unit_test_imdl()">unit_test_imdl</a>();
2738 imgi = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl, 1);
2739 ctrs = <a href="../../../eidors/models/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(imdl.fwd_model);
2740 x = ctrs(:,1); y = ctrs(:,2);
2741 imgi.elem_data(x-y&gt;100)= 1/10;
2742 vi = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(imgi); vi = vi.meas;
2743 clf; <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgi,1);
2744 
2745 imdl.solve = solver;
2746 imdl.hyperparameter.value = 1e2; <span class="comment">% was 0.1</span>
2747 
2748 imdl.reconst_type = <span class="string">'absolute'</span>;
2749 imdl.inv_solve_core.elem_working = <span class="string">'log_conductivity'</span>;
2750 imdl.inv_solve_core.elem_output = <span class="string">'log10_resistivity'</span>;
2751 imdl.inv_solve_core.meas_working = <span class="string">'apparent_resistivity'</span>;
2752 imdl.inv_solve_core.dtol_iter = 4; <span class="comment">% default 1 -&gt; start checking on the first iter</span>
2753 imdl.inv_solve_core.max_iterations = 20; <span class="comment">% default 10</span>
2754 imdl.inv_solve_core.calc_solution_error = 0;
2755 imdl.inv_solve_core.verbose = 10;
2756 imgr= <a href="inv_solve_core.html" class="code" title="function img= inv_solve_core( inv_model, data0, data1);">inv_solve_core</a>(imdl, vi);
2757 
2758 clf; <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgr,1);
2759 img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( imdl );
2760 img.elem_data= 1./(10.^imgr.elem_data);
2761 
2762 <span class="comment">%I = 1; % TODO FIXME -&gt; I is diag(1./vh) the conversion to apparent resistivity</span>
2763 <span class="comment">%% TODO these plots are useful, get them built into the solver!</span>
2764 <span class="comment">%vCG= fwd_solve(img); vCG = vCG.meas; fmdl = imdl.fwd_model;</span>
2765 <span class="comment">%clf; plot(I*(vi-vCG)); title('data misfit');</span>
2766 <span class="comment">%clf; hist(abs(I*(vi-vCG)),50); title('|data misfit|, histogram'); xlabel('|misfit|'); ylabel('count');</span>
2767 <span class="comment">%clf; show_pseudosection( fmdl, I*vi); title('measurement data');</span>
2768 <span class="comment">%clf; show_pseudosection( fmdl, I*vCG); title('reconstruction data');</span>
2769 <span class="comment">%clf; show_pseudosection( fmdl, (vCG-vi)/vi*100); title('data misfit');</span>
2770 
2771 <span class="comment">% sequence of time series difference data</span>
2772 <a name="_sub63" href="#_subfunctions" class="code">function do_unit_test_diffseq(solver)</a>
2773    lvl = <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,1);
2774    imdl = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'f2C'</span>,16);
2775    imdl.solve = solver;
2776    imdl.hyperparameter.value = 1e-2; <span class="comment">% was 0.1</span>
2777 
2778    imgh = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl,1);
2779    xyr = [];
2780    <span class="keyword">for</span> deg = [0:5:360]
2781       R = [sind(deg) cosd(deg); cosd(deg) -sind(deg)]; <span class="comment">% rotation matrix</span>
2782       xyr(:,end+1) = [R*[0.5 0.5]'; 0.2];
2783    <span class="keyword">end</span>
2784    [vh, vi, ~, imgm] = <a href="../../../eidors/models/simulate_movement.html" class="code" title="function [vh,vi,xyzr,c2f]= simulate_movement( img, xyzr, value );">simulate_movement</a>(imgh, xyr);
2785    disp(<span class="string">'*** alert: inverse crime underway ***'</span>);
2786    disp(<span class="string">' - no noise has been added to this data'</span>);
2787    disp(<span class="string">' - reconstructing to the same FEM discretization as simulated data'</span>);
2788    disp(<span class="string">'***'</span>);
2789    vv.meas = [];
2790    vv.time = nan;
2791    vv.name = <span class="string">'asfd'</span>;
2792    vv.type = <span class="string">'data'</span>;
2793    n_frames = size(vi,2);
2794    <span class="keyword">for</span> ii = 1:7
2795       <span class="keyword">switch</span> ii
2796          <span class="keyword">case</span> 1
2797             fprintf(<span class="string">'\n\nvh:numeric, vi:numeric data\n'</span>);
2798             vhi = vh;
2799             vii = vi;
2800          <span class="keyword">case</span> 2
2801             fprintf(<span class="string">'\n\nvh:struct, vi:numeric data\n'</span>);
2802             vhi = vv; vhi.meas = vh;
2803             vii = vi;
2804          <span class="keyword">case</span> 3
2805             fprintf(<span class="string">'\n\nvh:numeric, vi:struct data\n'</span>);
2806             vhi = vh;
2807             clear vii;
2808             <span class="keyword">for</span> jj=1:n_frames;
2809                vii(jj) = vv; vii(jj).meas = vi(:,jj);
2810             <span class="keyword">end</span>
2811          <span class="keyword">case</span> 4
2812             fprintf(<span class="string">'\n\nvh:struct, vi:struct data\n'</span>);
2813             vhi = vv; vhi.meas = vh;
2814             clear vii;
2815             <span class="keyword">for</span> jj=1:n_frames;
2816                vii(jj) = vv; vii(jj).meas = vi(:,jj);
2817             <span class="keyword">end</span>
2818          <span class="keyword">case</span> 5
2819             fprintf(<span class="string">'method = Cholesky\n'</span>);
2820             imdl.inv_solve_core.update_method = <span class="string">'cholesky'</span>;
2821          <span class="keyword">case</span> 6
2822             fprintf(<span class="string">'method = PCG\n'</span>);
2823             imdl.inv_solve_core.update_method = <span class="string">'pcg'</span>;
2824          <span class="keyword">otherwise</span>
2825             fprintf(<span class="string">'method = default\n'</span>);
2826             imdl.inv_solve_core = rmfield(imdl.inv_solve_core,<span class="string">'update_method'</span>);
2827       <span class="keyword">end</span>
2828       img= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vhi, vii);
2829       <span class="keyword">for</span> i=1:size(imgm,2)
2830          clf;
2831          subplot(211); imgi=imgh; imgi.elem_data = imgm(:,i); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgi); title(sprintf(<span class="string">'fwd#%d'</span>,i));
2832          subplot(212); imgi=imgh; imgi.elem_data = img.elem_data(:,i); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgi); title(<span class="string">'reconst'</span>);
2833          drawnow;
2834          err(i) = norm(imgm(:,i)/max(imgm(:,i)) - img.elem_data(:,i)/max(img.elem_data(:,i)));
2835          fprintf(<span class="string">'image#%d: reconstruction error = %g\n'</span>,i,err(i));
2836       <span class="keyword">end</span>
2837       <span class="keyword">for</span> i=1:size(imgm,2)
2838          <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( sprintf(<span class="string">'diff seq image#%d'</span>,i), <span class="keyword">...</span>
2839             imgm(:,i)/max(imgm(:,i)), <span class="keyword">...</span>
2840             img.elem_data(:,i)/max(img.elem_data(:,i)), <span class="keyword">...</span>
2841             0.70 );
2842       <span class="keyword">end</span>
2843    <span class="keyword">end</span>
2844    <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,lvl);
2845 
2846 <span class="comment">% sequence of time series data</span>
2847 <a name="_sub64" href="#_subfunctions" class="code">function do_unit_test_absseq(solver)</a>
2848    lvl = <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,1);
2849    imdl = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'f2C'</span>,16);
2850    imdl.reconst_type = <span class="string">'absolute'</span>;
2851    imdl.solve = solver;
2852    imdl.hyperparameter.value = 1e-2; <span class="comment">% was 0.1</span>
2853 
2854    imgh = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl,1);
2855    xyr = [];
2856    <span class="keyword">for</span> deg = [0:5:360]
2857       R = [sind(deg) cosd(deg); cosd(deg) -sind(deg)]; <span class="comment">% rotation matrix</span>
2858       xyr(:,end+1) = [R*[0.5 0.5]'; 0.2];
2859    <span class="keyword">end</span>
2860    [~, vi, ~, imgm] = <a href="../../../eidors/models/simulate_movement.html" class="code" title="function [vh,vi,xyzr,c2f]= simulate_movement( img, xyzr, value );">simulate_movement</a>(imgh, xyr);
2861    imgm = imgm + 1; <span class="comment">% simulate_movement returns difference images but we're doing absolute solver work</span>
2862    disp(<span class="string">'*** alert: inverse crime underway ***'</span>);
2863    disp(<span class="string">' - no noise has been added to this data'</span>);
2864    disp(<span class="string">' - reconstructing to the same FEM discretization as simulated data'</span>);
2865    disp(<span class="string">'***'</span>);
2866    vv.meas = [];
2867    vv.time = nan;
2868    vv.name = <span class="string">'asfd'</span>;
2869    vv.type = <span class="string">'data'</span>;
2870    n_frames = size(vi,2);
2871    <span class="keyword">for</span> ii = 1:5
2872       <span class="keyword">switch</span> ii
2873          <span class="keyword">case</span> 1
2874             fprintf(<span class="string">'\n\nvi:numeric data\n'</span>);
2875             vii = vi;
2876          <span class="keyword">case</span> 2
2877             fprintf(<span class="string">'\n\nvi:struct data\n'</span>);
2878             clear vii;
2879             <span class="keyword">for</span> jj=1:n_frames;
2880                vii(jj) = vv; vii(jj).meas = vi(:,jj);
2881             <span class="keyword">end</span>
2882          <span class="keyword">case</span> 3
2883             fprintf(<span class="string">'method = Cholesky\n'</span>);
2884             imdl.inv_solve_core.update_method = <span class="string">'cholesky'</span>;
2885          <span class="keyword">case</span> 4
2886             fprintf(<span class="string">'method = PCG\n'</span>);
2887             imdl.inv_solve_core.update_method = <span class="string">'pcg'</span>;
2888          <span class="keyword">otherwise</span>
2889             fprintf(<span class="string">'method = default\n'</span>);
2890             imdl.inv_solve_core = rmfield(imdl.inv_solve_core,<span class="string">'update_method'</span>);
2891       <span class="keyword">end</span>
2892       img= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vii);
2893       <span class="keyword">for</span> i=1:size(imgm,2)
2894          clf;
2895          subplot(211); imgi=imgh; imgi.elem_data = imgm(:,i); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgi); title(sprintf(<span class="string">'fwd#%d'</span>,i));
2896          subplot(212); imgi=imgh; imgi.elem_data = img.elem_data(:,i); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgi); title(<span class="string">'reconst'</span>);
2897          drawnow;
2898          err(i) = norm(imgm(:,i)/max(imgm(:,i)) - img.elem_data(:,i)/max(img.elem_data(:,i)));
2899          fprintf(<span class="string">'image#%d: reconstruction error = %g\n'</span>,i,err(i));
2900       <span class="keyword">end</span>
2901       <span class="keyword">for</span> i=1:size(imgm,2)
2902          <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( sprintf(<span class="string">'abs seq image#%d'</span>,i), <span class="keyword">...</span>
2903             imgm(:,i)/max(imgm(:,i)), <span class="keyword">...</span>
2904             img.elem_data(:,i)/max(img.elem_data(:,i)), <span class="keyword">...</span>
2905             0.46 );
2906       <span class="keyword">end</span>
2907    <span class="keyword">end</span>
2908    <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,lvl);</pre></div>
<hr><address>Generated on Fri 01-Jun-2018 15:59:55 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>