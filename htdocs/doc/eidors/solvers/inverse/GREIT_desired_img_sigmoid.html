<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of GREIT_desired_img_sigmoid</title>
  <meta name="keywords" content="GREIT_desired_img_sigmoid">
  <meta name="description" content="GREIT_DESIRED_IMG_SIGMOID sigmoid-decay desired image function for GREIT">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">inverse</a> &gt; GREIT_desired_img_sigmoid.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/solvers/inverse&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>GREIT_desired_img_sigmoid
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>GREIT_DESIRED_IMG_SIGMOID sigmoid-decay desired image function for GREIT</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function PSF = GREIT_desired_img_sigmoid(xyz,radius, opt) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">GREIT_DESIRED_IMG_SIGMOID sigmoid-decay desired image function for GREIT 
 PSF= GREIT_desired_img_sigmoid(xyc, radius, opt)
   xyz     - array of centers of desired target images
               [2xN] - xy only
               [3xN] - xyz or, if radius = [], xyr
               [4xN] - xyzr (radius is ignored)
   radius  - the radius of the target on the desired image as a fraction
             of the model radius (half the larger dimension in xy)
   opt     - a struct with these fields:
      .rec_model   a 2D or 3D model as generated by MK_GRID_MODEL that may
                   have had some pixels/voxels removed (a rec_model that 
                   is not a complete rectangle/parallelepiped). 
      .steepness   [optional] a factor controling the amount of blur, see
                   below for details. Lower steepness gives more blur, but
                   if the value is too low, image may not reach the value 
                   of 1 at the center of the target. 
                   May be specified as a scalar, a [1xN] vector, or a
                   function handle with the signature:
                        func(pts)
                   where pts is either [2xN] or [3xN], dependig on the xyz
                   function input, e.g. @(xyz) 50./(xyz(3,:))
                   Default: 10./radius
      .desired_img_radius
                   [optional] Overwrites the radius input. May be 
                   specified as a scalar, a [1xN] vector or a function 
                   handle with the signature:
                        func(pts)
                   where pts is either [2xN] or [3xN], dependig on the xyz
                   function input, e.g. @(xyz) abs(xyz(3,:))/5
      .threshold   [optional] voxels where the function is smaller than
                   threshold will be set 0. Values bigger than 1-threshold
                   will be 1. The smaller the threshold the more
                   computationally expensive is the evaluation. 
                   Default: 1e-4;

 The desired images approximate in each pixel the area integral of:
       f(r) = 1 / (1 + exp(s*(|r-r0| - radius)))
 where
       r   - position vector in 2D/3D space
       s   - opt.steepness
       r0  - target center
 For |r-r0| = radius, f(r) = 0.5.
 
 As of 2015-03-29, this is the default desired image function used by
 MK_GREIT_MODEL.

 See also: <a href="calc_GREIT_RM.html" class="code" title="function [RM, PJt, M] = calc_GREIT_RM(vh,vi, xyc, radius, weight, options)">CALC_GREIT_RM</a>, MK_GREIT_MODEL, MK_PIXEL_SLICE</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../../eidors/graphics/matlab/show_3d_slices.html" class="code" title="function h = show_3d_slices(img, varargin);">show_3d_slices</a>	show_3d_slices(img, z_cuts, x_cuts, y_cuts, any_cuts)</li><li><a href="../../../eidors/models/get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>	GET_ELEM_VOLUME: VOL = get_elem_volume(fwd_model, map_node )</li><li><a href="../../../eidors/models/mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>	MDL_DIM: dimension of model space (are nodes in 2D or 3D space)</li><li><a href="../../../eidors/models/mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>	MK_GRID_MODEL: Create reconstruction model on pixelated grid</li><li><a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="GREIT_desired_img_sigmoid.html" class="code" title="function PSF = GREIT_desired_img_sigmoid(xyz,radius, opt)">GREIT_desired_img_sigmoid</a>	GREIT_DESIRED_IMG_SIGMOID sigmoid-decay desired image function for GREIT</li><li><a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li><li><a href="../../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>	PROGRESS_MSG Progress messages and timing.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="GREIT_desired_img_sigmoid.html" class="code" title="function PSF = GREIT_desired_img_sigmoid(xyz,radius, opt)">GREIT_desired_img_sigmoid</a>	GREIT_DESIRED_IMG_SIGMOID sigmoid-decay desired image function for GREIT</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function PSF = desired_soln(xyz, radius, opt)</a></li><li><a href="#_sub2" class="code">function [X, Y, Z] = voxnodes(mdl)</a></li><li><a href="#_sub3" class="code">function [x,y,z] = interp_elem_new(mdl,e,radius,opt)</a></li><li><a href="#_sub4" class="code">function [x,y,z] = interp_elem(mdl,e,radius, opt)</a></li><li><a href="#_sub5" class="code">function out = linvec(v1, v2, N)</a></li><li><a href="#_sub6" class="code">function [x, y] = grid2d(vx, vy)</a></li><li><a href="#_sub7" class="code">function [x, y, z] = grid3d(vx,vy,vz)</a></li><li><a href="#_sub8" class="code">function farel = far_elems(Xnodes,Ynodes,Znodes,xyz,radius, th)</a></li><li><a href="#_sub9" class="code">function farel = close_elems(Xnodes,Ynodes,Znodes,xyz,radius, th)</a></li><li><a href="#_sub10" class="code">function [xyz, radius, opt] = parse_opt(xyz, radius, opt)</a></li><li><a href="#_sub11" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function PSF = GREIT_desired_img_sigmoid(xyz,radius, opt)</a>
0002 <span class="comment">%GREIT_DESIRED_IMG_SIGMOID sigmoid-decay desired image function for GREIT</span>
0003 <span class="comment">% PSF= GREIT_desired_img_sigmoid(xyc, radius, opt)</span>
0004 <span class="comment">%   xyz     - array of centers of desired target images</span>
0005 <span class="comment">%               [2xN] - xy only</span>
0006 <span class="comment">%               [3xN] - xyz or, if radius = [], xyr</span>
0007 <span class="comment">%               [4xN] - xyzr (radius is ignored)</span>
0008 <span class="comment">%   radius  - the radius of the target on the desired image as a fraction</span>
0009 <span class="comment">%             of the model radius (half the larger dimension in xy)</span>
0010 <span class="comment">%   opt     - a struct with these fields:</span>
0011 <span class="comment">%      .rec_model   a 2D or 3D model as generated by MK_GRID_MODEL that may</span>
0012 <span class="comment">%                   have had some pixels/voxels removed (a rec_model that</span>
0013 <span class="comment">%                   is not a complete rectangle/parallelepiped).</span>
0014 <span class="comment">%      .steepness   [optional] a factor controling the amount of blur, see</span>
0015 <span class="comment">%                   below for details. Lower steepness gives more blur, but</span>
0016 <span class="comment">%                   if the value is too low, image may not reach the value</span>
0017 <span class="comment">%                   of 1 at the center of the target.</span>
0018 <span class="comment">%                   May be specified as a scalar, a [1xN] vector, or a</span>
0019 <span class="comment">%                   function handle with the signature:</span>
0020 <span class="comment">%                        func(pts)</span>
0021 <span class="comment">%                   where pts is either [2xN] or [3xN], dependig on the xyz</span>
0022 <span class="comment">%                   function input, e.g. @(xyz) 50./(xyz(3,:))</span>
0023 <span class="comment">%                   Default: 10./radius</span>
0024 <span class="comment">%      .desired_img_radius</span>
0025 <span class="comment">%                   [optional] Overwrites the radius input. May be</span>
0026 <span class="comment">%                   specified as a scalar, a [1xN] vector or a function</span>
0027 <span class="comment">%                   handle with the signature:</span>
0028 <span class="comment">%                        func(pts)</span>
0029 <span class="comment">%                   where pts is either [2xN] or [3xN], dependig on the xyz</span>
0030 <span class="comment">%                   function input, e.g. @(xyz) abs(xyz(3,:))/5</span>
0031 <span class="comment">%      .threshold   [optional] voxels where the function is smaller than</span>
0032 <span class="comment">%                   threshold will be set 0. Values bigger than 1-threshold</span>
0033 <span class="comment">%                   will be 1. The smaller the threshold the more</span>
0034 <span class="comment">%                   computationally expensive is the evaluation.</span>
0035 <span class="comment">%                   Default: 1e-4;</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% The desired images approximate in each pixel the area integral of:</span>
0038 <span class="comment">%       f(r) = 1 / (1 + exp(s*(|r-r0| - radius)))</span>
0039 <span class="comment">% where</span>
0040 <span class="comment">%       r   - position vector in 2D/3D space</span>
0041 <span class="comment">%       s   - opt.steepness</span>
0042 <span class="comment">%       r0  - target center</span>
0043 <span class="comment">% For |r-r0| = radius, f(r) = 0.5.</span>
0044 <span class="comment">%</span>
0045 <span class="comment">% As of 2015-03-29, this is the default desired image function used by</span>
0046 <span class="comment">% MK_GREIT_MODEL.</span>
0047 <span class="comment">%</span>
0048 <span class="comment">% See also: CALC_GREIT_RM, MK_GREIT_MODEL, MK_PIXEL_SLICE</span>
0049 
0050 <span class="comment">% (C) 2015 Bartlomiej Grychtol - all rights reserved Swisstom AG.</span>
0051 <span class="comment">% License: GPL version 2 or 3</span>
0052 <span class="comment">% $Id: GREIT_desired_img_sigmoid.m 5340 2017-02-18 22:16:29Z bgrychtol $</span>
0053 
0054 <span class="comment">% &gt;&gt; SWISSTOM CONTRIBUTION &lt;&lt;</span>
0055 
0056 <span class="keyword">if</span> ischar(xyz) &amp;&amp; strcmp(xyz,<span class="string">'UNIT_TEST'</span>), <a href="#_sub11" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>, <span class="keyword">end</span>
0057 
0058 [xyzr, radius, opt] = <a href="#_sub10" class="code" title="subfunction [xyz, radius, opt] = parse_opt(xyz, radius, opt)">parse_opt</a>(xyz, radius, opt);
0059 
0060 copt.cache_obj = {xyzr, radius, opt.rec_model.nodes, opt.rec_model.elems, opt.steepness};
0061 copt.fstr = <span class="string">'GREIT_desired_img_sigmoid'</span>;
0062 PSF = <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub1" class="code" title="subfunction PSF = desired_soln(xyz, radius, opt)">desired_soln</a>,{xyzr, radius, opt},copt);
0063 
0064 
0065 <span class="keyword">end</span>
0066 
0067 <span class="comment">%-------------------------------------------------------------------------%</span>
0068 <span class="comment">% The main function</span>
0069 <a name="_sub1" href="#_subfunctions" class="code">function PSF = desired_soln(xyz, radius, opt)</a>
0070    num_it = size(xyz,2);
0071     <a href="../../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Composing desired images:'</span>,0,num_it);
0072     mdl = opt.rec_model;
0073     <span class="keyword">switch</span> opt.n_dim
0074         <span class="keyword">case</span> 3
0075             mdl.vox = [mdl.elems(1:6:<span class="keyword">end</span>,:) mdl.elems(6:6:<span class="keyword">end</span>,:)];
0076 
0077             min_vox_edge = min( [min(diff(unique(mdl.nodes(:,1)))), <span class="keyword">...</span>
0078                                  min(diff(unique(mdl.nodes(:,2)))), <span class="keyword">...</span>
0079                                  min(diff(unique(mdl.nodes(:,3))))] );
0080         <span class="keyword">case</span> 2
0081             mdl.vox = [mdl.elems(1:2:<span class="keyword">end</span>,:) mdl.elems(2:2:<span class="keyword">end</span>,:)];
0082             min_vox_edge = min( [min(diff(unique(mdl.nodes(:,1)))), <span class="keyword">...</span>
0083                                  min(diff(unique(mdl.nodes(:,2))))] );
0084 
0085     <span class="keyword">end</span>
0086     [Xnodes,Ynodes,Znodes] = <a href="#_sub2" class="code" title="subfunction [X, Y, Z] = voxnodes(mdl)">voxnodes</a>(mdl);
0087     
0088 
0089     
0090     warned = false;
0091     <a href="#_sub3" class="code" title="subfunction [x,y,z] = interp_elem_new(mdl,e,radius,opt)">interp_elem_new</a>(<span class="string">'reset'</span>,size(mdl.vox,1),[],opt);
0092     
0093     <span class="comment">% estimate the amount of memory needed to store PSF</span>
0094     n_el = size(mdl.vox,1);
0095     n_pt = size(xyz,2);
0096     n_ep = n_el*n_pt;
0097     ll = <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,0);
0098     vox_box = sum(<a href="../../../eidors/models/get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(mdl));
0099     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,ll);
0100     tgt_box = (2*mean(radius+opt.threshold./opt.steepness))^3;
0101     n_nz = ceil(n_ep*tgt_box/vox_box);
0102     SPARSE_STEP = ceil(n_nz/5);
0103     PSF = spalloc(n_el,n_pt,n_nz);
0104     
0105     <span class="keyword">for</span> i=1:size(xyz,2)
0106         <span class="keyword">if</span> nnz(PSF) &gt; n_nz
0107            n_nz = nnz(PSF) + SPARSE_STEP;
0108            [r,c,v] = find(PSF);
0109            PSF = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(r,c,v,n_el,n_pt,n_nz); 
0110         <span class="keyword">end</span>
0111         th = opt.threshold/opt.steepness(i);
0112         <a href="../../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(i,num_it);
0113         farel = <a href="#_sub8" class="code" title="subfunction farel = far_elems(Xnodes,Ynodes,Znodes,xyz,radius, th)">far_elems</a>(Xnodes,Ynodes,Znodes, xyz(:,i), radius(i), th);
0114         <span class="comment">% also check for elements so close to the center they are approx 1</span>
0115         close_el = false(size(farel));
0116         <span class="keyword">if</span> radius(i) - th &gt; min_vox_edge
0117            close_el = <a href="#_sub9" class="code" title="subfunction farel = close_elems(Xnodes,Ynodes,Znodes,xyz,radius, th)">close_elems</a>(Xnodes,Ynodes,Znodes, xyz(:,i), radius(i), th);
0118         <span class="keyword">end</span>
0119         el_idx = find(~farel &amp; ~close_el);
0120         <span class="comment">% start with an initial size</span>
0121         STEP = 1000;
0122         idx = zeros(STEP,1);
0123         factor = zeros(STEP,1);
0124         X = zeros(STEP,1);
0125         Y = zeros(STEP,1);
0126         Z = zeros(STEP,1);
0127         L = STEP;
0128         N = 1;
0129 
0130         <span class="keyword">for</span> e = el_idx'
0131             [x,y,z] = <a href="#_sub3" class="code" title="subfunction [x,y,z] = interp_elem_new(mdl,e,radius,opt)">interp_elem_new</a>(mdl,e,radius(i), opt);
0132             n = numel(x);
0133             N1 = N; 
0134             N = N+n;
0135             <span class="keyword">if</span> N &gt; L <span class="comment">% expand arrays as needed</span>
0136                 fill = zeros(STEP,1);
0137                 idx = [idx; fill];
0138                 factor = [factor; fill];
0139                 X = [X; fill]; Y = [Y; fill]; Z = [Z; fill];
0140                 L = L + STEP;
0141             <span class="keyword">end</span>
0142             v = N1:N-1;
0143             idx(v) = e;
0144             factor(v) = 1/n;
0145             X(v) = x; Y(v) = y; Z(v) = z;
0146         <span class="keyword">end</span>
0147         <span class="comment">% remove spare length</span>
0148         v = N:L;
0149         idx(v) = [];
0150         factor(v) = [];
0151         X(v) = []; Y(v) = []; Z(v) = [];
0152         
0153         <span class="keyword">if</span> isempty(X)
0154             <span class="keyword">if</span> ~warned
0155                warning(<span class="string">'EIDORS:OutsidePoint'</span>,<span class="keyword">...</span>
0156                   <span class="string">'Desired image generation failed for point %d (and maybe others)'</span>,i);
0157                warned = true;
0158             <span class="keyword">end</span>
0159             <span class="comment">% PSF(:,i) = 0; % not needed</span>
0160             <span class="keyword">continue</span>;
0161         <span class="keyword">end</span>
0162         V = [X Y Z];
0163         D = sqrt(sum(bsxfun(@minus,V(:,1:opt.n_dim),xyz(1:opt.n_dim,i)').^2, 2));
0164         x = D - radius(i);
0165         tmp = 1 ./ (1 + exp( opt.steepness(i) * x));
0166         PSF(:,i) = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(idx,1,tmp(:) .* factor,size(mdl.vox,1),1);
0167         PSF(close_el,i) = 1;
0168     <span class="keyword">end</span>
0169     <a href="#_sub3" class="code" title="subfunction [x,y,z] = interp_elem_new(mdl,e,radius,opt)">interp_elem_new</a>(<span class="string">'clear'</span>);
0170     <a href="../../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(Inf);
0171 <span class="keyword">end</span>
0172 
0173 <span class="comment">%-------------------------------------------------------------------------%</span>
0174 <span class="comment">% Generate internal points in elements</span>
0175 <a name="_sub2" href="#_subfunctions" class="code">function [X, Y, Z] = voxnodes(mdl)</a>
0176     x = mdl.nodes(:,1); X = x(mdl.vox);
0177     y = mdl.nodes(:,2); Y = y(mdl.vox);
0178     <span class="keyword">try</span>
0179         z = mdl.nodes(:,3); Z = z(mdl.vox);
0180     <span class="keyword">catch</span>
0181         Z = [];
0182     <span class="keyword">end</span>  
0183 <span class="keyword">end</span>
0184 
0185 <a name="_sub3" href="#_subfunctions" class="code">function [x,y,z] = interp_elem_new(mdl,e,radius,opt)</a>
0186     <span class="keyword">persistent</span> N_entries X  Y Z MAP N minnode maxnode done_elems sep
0187     <span class="keyword">if</span> ischar(mdl) &amp;&amp; strcmp(mdl,<span class="string">'reset'</span>)
0188         N_entries = 0; X = []; Y = []; Z = []; MAP = [];
0189         N       = ones(1,3);
0190         minnode = zeros(e,opt.n_dim);
0191         maxnode = zeros(e,opt.n_dim);
0192         sep     = zeros(e,opt.n_dim);
0193         done_elems = false(e,1);
0194         <span class="keyword">return</span>;
0195     <span class="keyword">end</span>
0196     <span class="keyword">if</span> ischar(mdl) &amp;&amp; strcmp(mdl,<span class="string">'clear'</span>)
0197        clear N_entries X  Y Z MAP N minnode maxnode done_elems sep
0198        <span class="keyword">return</span>;
0199     <span class="keyword">end</span>
0200     maxsep = radius/5;
0201     
0202     <span class="keyword">if</span> ~done_elems(e)
0203        minnode(e,:) = min(mdl.nodes(mdl.vox(e,:),:));
0204        maxnode(e,:) = max(mdl.nodes(mdl.vox(e,:),:));
0205        sep(e,:) = maxnode(e,:) - minnode(e,:);
0206        done_elems(e) = true;
0207     <span class="keyword">end</span>
0208     
0209     N(1:opt.n_dim) = max(3, ceil(sep(e,:)/maxsep)+1);
0210     
0211     <span class="keyword">try</span>
0212         entry = MAP(N(1),N(2),N(3));
0213         x = X{entry};
0214         y = Y{entry};
0215         z = Z{entry};
0216     <span class="keyword">catch</span>
0217         entry = N_entries+1;
0218         
0219         vx = <a href="#_sub5" class="code" title="subfunction out = linvec(v1, v2, N)">linvec</a>(0,1,N(1));
0220         vx = vx + .5*(vx(2) -vx(1));
0221         
0222         vy = <a href="#_sub5" class="code" title="subfunction out = linvec(v1, v2, N)">linvec</a>(0,1,N(2));
0223         vy = vy + .5*(vy(2) -vy(1));
0224         
0225         
0226         <span class="keyword">switch</span> opt.n_dim
0227             <span class="keyword">case</span> 2
0228                 [x, y] = <a href="#_sub6" class="code" title="subfunction [x, y] = grid2d(vx, vy)">grid2d</a>(vx,vy);
0229                 z = zeros(size(x));
0230             <span class="keyword">case</span> 3
0231                 vz = <a href="#_sub5" class="code" title="subfunction out = linvec(v1, v2, N)">linvec</a>(0,1,N(3));
0232                 vz = vz + .5*(vz(2) -vz(1));
0233                 [x, y, z] = <a href="#_sub7" class="code" title="subfunction [x, y, z] = grid3d(vx,vy,vz)">grid3d</a>(vx,vy,vz);
0234         <span class="keyword">end</span>
0235         X{entry} = x;
0236         Y{entry} = y;
0237         Z{entry} = z;
0238         N_entries = entry;
0239         MAP(N(1),N(2),N(3)) = entry;
0240     <span class="keyword">end</span>
0241     x = x*sep(e,1) + minnode(e,1);
0242     y = y*sep(e,2) + minnode(e,2);
0243     <span class="keyword">if</span> opt.n_dim == 3
0244        z = z*sep(e,3) + minnode(e,3);
0245     <span class="keyword">end</span>
0246     
0247 <span class="keyword">end</span>
0248 
0249 <span class="comment">%-------------------------------------------------------------------------%</span>
0250 <span class="comment">% Generate internal points in elements</span>
0251 <a name="_sub4" href="#_subfunctions" class="code">function [x,y,z] = interp_elem(mdl,e,radius, opt)</a>
0252     maxsep = radius/5;
0253 
0254     minnode = min(mdl.nodes(mdl.vox(e,:),:));
0255     maxnode = max(mdl.nodes(mdl.vox(e,:),:));
0256     
0257     sep = maxnode - minnode;
0258     N = max(3, ceil(sep/maxsep)+1);
0259 
0260     vx = <a href="#_sub5" class="code" title="subfunction out = linvec(v1, v2, N)">linvec</a>(minnode(1),maxnode(1),N(1));
0261     vx = vx + .5*(vx(2) -vx(1));
0262         
0263     vy = <a href="#_sub5" class="code" title="subfunction out = linvec(v1, v2, N)">linvec</a>(minnode(2),maxnode(2),N(2));
0264     vy = vy + .5*(vy(2) -vy(1));
0265     
0266 
0267     <span class="keyword">switch</span> opt.n_dim
0268         <span class="keyword">case</span> 2
0269             [x, y] = <a href="#_sub6" class="code" title="subfunction [x, y] = grid2d(vx, vy)">grid2d</a>(vx,vy);
0270             z = [];
0271         <span class="keyword">case</span> 3
0272             vz = <a href="#_sub5" class="code" title="subfunction out = linvec(v1, v2, N)">linvec</a>(minnode(3),maxnode(3),N(3));
0273             vz = vz + .5*(vz(2) -vz(1));
0274             [x, y, z] = <a href="#_sub7" class="code" title="subfunction [x, y, z] = grid3d(vx,vy,vz)">grid3d</a>(vx,vy,vz);
0275     <span class="keyword">end</span>
0276 <span class="keyword">end</span>
0277 
0278 
0279 <a name="_sub5" href="#_subfunctions" class="code">function out = linvec(v1, v2, N)</a>
0280 <span class="comment">% equivalent to out= linspace(v1,v2,N); out(end) = []; minus error checking</span>
0281 out = v1 + (0:(N-2)).*(v2-v1)/(N-1);
0282 
0283 <span class="keyword">end</span>
0284 
0285 <a name="_sub6" href="#_subfunctions" class="code">function [x, y] = grid2d(vx, vy)</a>
0286 <span class="comment">% ndgrid minus overhead, asumes both vx and vy are row vectors</span>
0287     vx = vx.';
0288     x = repmat(vx,size(vy));
0289     y = repmat(vy,size(vx));
0290 <span class="keyword">end</span>
0291 
0292 <a name="_sub7" href="#_subfunctions" class="code">function [x, y, z] = grid3d(vx,vy,vz)</a>
0293 <span class="comment">% ndgrid minus overhead</span>
0294     sz = [numel(vx) numel(vy) numel(vz)];
0295     x = reshape(vx,[sz(1) 1 1]);
0296     x = repmat(x,[1 sz(2) sz(3)]);
0297     
0298     y = reshape(vy,[1 sz(2) 1]);
0299     y = repmat(y,[sz(1) 1 sz(3)]);
0300     
0301     z = reshape(vz,[1 1 sz(3)]);
0302     z = repmat(z,[sz(1) sz(2) 1]);
0303     
0304 
0305 <span class="keyword">end</span>
0306 
0307 
0308 <span class="comment">%-------------------------------------------------------------------------%</span>
0309 <span class="comment">% Find elements where the function value is negligable</span>
0310 <a name="_sub8" href="#_subfunctions" class="code">function farel = far_elems(Xnodes,Ynodes,Znodes,xyz,radius, th)</a>
0311     farel = false(size(Xnodes,1),1);
0312 
0313     nodes_test = Xnodes &lt; xyz(1) - radius - th;
0314     farel = farel | all(nodes_test,2);
0315     <span class="keyword">if</span> all(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0316     nodes_test = Xnodes &gt; xyz(1) + radius + th;
0317     farel = farel | all(nodes_test,2);
0318     <span class="keyword">if</span> all(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0319     nodes_test = Ynodes &lt; xyz(2) - radius - th;
0320     farel = farel | all(nodes_test,2);
0321     <span class="keyword">if</span> all(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0322     nodes_test = Ynodes &gt; xyz(2) + radius + th;
0323     farel = farel | all(nodes_test,2);
0324     <span class="keyword">if</span> all(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0325     <span class="keyword">if</span> ~isempty(Znodes)
0326         nodes_test  = Znodes &gt; xyz(3) + radius + th;
0327         farel = farel | all(nodes_test,2);
0328         <span class="keyword">if</span> all(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0329         nodes_test  = Znodes &lt; xyz(3) - radius - th;
0330         farel = farel | all(nodes_test,2);
0331         <span class="keyword">if</span> all(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0332     <span class="keyword">end</span>
0333     idx = find(~farel);
0334 <span class="keyword">end</span>
0335 
0336 <span class="comment">%-------------------------------------------------------------------------%</span>
0337 <span class="comment">% Find elements where the function value is essentially 1</span>
0338 <a name="_sub9" href="#_subfunctions" class="code">function farel = close_elems(Xnodes,Ynodes,Znodes,xyz,radius, th)</a>
0339   
0340    farel = true(size(Xnodes,1),1);
0341 
0342     nodes_test = Xnodes &lt; xyz(1) + radius - th;
0343     farel = farel &amp; all(nodes_test,2);
0344     <span class="keyword">if</span> ~any(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0345     nodes_test = Xnodes &gt; xyz(1) - radius + th;
0346     farel = farel &amp; all(nodes_test,2);
0347     <span class="keyword">if</span> ~any(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0348     nodes_test = Ynodes &lt; xyz(2) + radius - th;
0349     farel = farel &amp; all(nodes_test,2);
0350     <span class="keyword">if</span> ~any(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0351     nodes_test = Ynodes &gt; xyz(2) - radius + th;
0352     farel = farel &amp; all(nodes_test,2);
0353     <span class="keyword">if</span> ~any(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0354     <span class="keyword">if</span> ~isempty(Znodes)
0355         nodes_test  = Znodes &gt; xyz(3) - radius + th;
0356         farel = farel &amp; all(nodes_test,2);
0357         <span class="keyword">if</span> ~any(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0358         nodes_test  = Znodes &lt; xyz(3) + radius - th;
0359         farel = farel &amp; all(nodes_test,2);
0360         <span class="keyword">if</span> ~any(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0361     <span class="keyword">end</span>
0362     idx = find(farel);
0363 <span class="keyword">end</span>
0364 
0365 
0366 <span class="comment">%-------------------------------------------------------------------------%</span>
0367 <span class="comment">% Parse options</span>
0368 <a name="_sub10" href="#_subfunctions" class="code">function [xyz, radius, opt] = parse_opt(xyz, radius, opt)</a>
0369 
0370     scale_radius = false;
0371     <span class="keyword">if</span> isempty(radius)
0372         radius = xyz(<span class="keyword">end</span>,:);
0373         scale_radius = true;
0374         xyz(<span class="keyword">end</span>,:) = [];
0375     <span class="keyword">end</span>
0376     
0377     <span class="keyword">if</span> isfield(opt,<span class="string">'desired_img_radius'</span>)
0378        scale_radius = false;
0379        <span class="keyword">if</span> isnumeric(opt.desired_img_radius)
0380           radius = opt.desired_img_radius;
0381        <span class="keyword">end</span>
0382        <span class="keyword">if</span> isa(opt.desired_img_radius, <span class="string">'function_handle'</span>)
0383           radius = feval(opt.desired_img_radius,xyz);
0384        <span class="keyword">end</span>
0385     <span class="keyword">end</span>
0386         
0387  
0388     
0389     mdl = opt.rec_model; <span class="comment">% must exist</span>
0390     opt.n_dim =<a href="../../../eidors/models/mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>(mdl);
0391     xyz = xyz(1:opt.n_dim, :); <span class="comment">% ingore z if model is 2D</span>
0392 
0393     
0394 
0395     opt.meshsz = [];
0396     <span class="keyword">try</span>
0397         <span class="keyword">for</span> i = 1:3
0398             opt.meshsz = [opt.meshsz min(mdl.nodes(:,i)) max(mdl.nodes(:,i))];
0399         <span class="keyword">end</span>
0400     <span class="keyword">end</span>
0401     
0402     opt.n_dim = length(opt.meshsz)/2;
0403     opt.meshsz = reshape(opt.meshsz,2,[])';
0404 
0405     opt.minpt = opt.meshsz(:,1);
0406     opt.maxpt = opt.meshsz(:,2);
0407     opt.range = opt.maxpt - opt.minpt;
0408     opt.maxrange = max(opt.range(1:2));
0409 
0410     <span class="comment">%rescale points to between -1 and 1 in the x-y plane</span>
0411     xyz = 2*bsxfun(@minus, xyz, mean(opt.meshsz,2))/opt.maxrange;
0412     mdl.nodes = 2*bsxfun(@minus, mdl.nodes, mean(opt.meshsz(1:size(mdl.nodes,2),:),2)')/opt.maxrange;
0413     opt.rec_model = mdl;
0414     <span class="keyword">if</span> scale_radius
0415         radius = 2*radius / opt.maxrange;
0416     <span class="keyword">end</span>
0417 
0418     <span class="keyword">if</span> ~isfield(opt, <span class="string">'steepness'</span>)
0419         opt.steepness = 10./radius;
0420     <span class="keyword">elseif</span> isa(opt.steepness,<span class="string">'function_handle'</span>)
0421         opt.steepness = feval(opt.steepness,xyz);
0422     <span class="keyword">end</span>
0423     
0424     <span class="keyword">if</span> numel(opt.steepness) == 1
0425        opt.steepness = ones(1,size(xyz,2)) * opt.steepness;
0426     <span class="keyword">end</span>
0427     
0428     <span class="keyword">if</span> numel(radius) == 1
0429         radius = ones(1,size(xyz,2)) * radius;
0430     <span class="keyword">end</span>
0431     
0432     <span class="keyword">if</span> opt.n_dim == 2
0433        xyz(3,:) = 0;
0434     <span class="keyword">end</span>
0435    
0436     <span class="keyword">if</span> ~isfield(opt, <span class="string">'threshold'</span>)
0437        opt.threshold = 1e-4;
0438     <span class="keyword">end</span>
0439     
0440     opt.threshold = log(1/opt.threshold - 1); 
0441     
0442 <span class="keyword">end</span>
0443 
0444 <span class="comment">%-------------------------------------------------------------------------%</span>
0445 <span class="comment">% UNIT_TEST</span>
0446 <a name="_sub11" href="#_subfunctions" class="code">function do_unit_test</a>
0447     <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a> off <a href="GREIT_desired_img_sigmoid.html" class="code" title="function PSF = GREIT_desired_img_sigmoid(xyz,radius, opt)">GREIT_desired_img_sigmoid</a>
0448     v = linspace(-1,1,32);
0449     mdl= <a href="../../../eidors/models/mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>([],v,v,[0 .7 1:.2:2 2.3 3]);
0450     opt.rec_model = mdl;
0451     opt.steepness = @(xyz) 50./xyz(3,:);
0452     opt.desired_img_radius = @(xyz) xyz(3,:)/5;
0453 <span class="comment">%     xyzr = zeros(5,4);</span>
0454     xyzr(:,3) = .5:.5:2.5;
0455     xyzr(:,4) = .25;
0456     sol = <a href="GREIT_desired_img_sigmoid.html" class="code" title="function PSF = GREIT_desired_img_sigmoid(xyz,radius, opt)">GREIT_desired_img_sigmoid</a>(xyzr',[],opt);
0457     img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(mdl,0);
0458     <span class="keyword">for</span> i = 1:5
0459         subplot(2,3,i)
0460         img.elem_data= sol(:,i);
0461         <a href="../../../eidors/graphics/matlab/show_3d_slices.html" class="code" title="function h = show_3d_slices(img, varargin);">show_3d_slices</a>(img,xyzr(i,3),xyzr(i,2),xyzr(i,1));
0462     <span class="keyword">end</span>
0463     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'UNIT_TEST: Showed %d images to verify'</span>,i,0);
0464     <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a> on <a href="GREIT_desired_img_sigmoid.html" class="code" title="function PSF = GREIT_desired_img_sigmoid(xyz,radius, opt)">GREIT_desired_img_sigmoid</a>
0465 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 01-Jun-2018 15:59:55 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>