<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of jacobian_adjoint_2p5d_1st_order</title>
  <meta name="keywords" content="jacobian_adjoint_2p5d_1st_order">
  <meta name="description" content="JACOBIAN_ADJOINT_2P5D: J= jacobian_adjoint_2p5d_1st_order( img )">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">forward</a> &gt; jacobian_adjoint_2p5d_1st_order.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/solvers/forward&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>jacobian_adjoint_2p5d_1st_order
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>JACOBIAN_ADJOINT_2P5D: J= jacobian_adjoint_2p5d_1st_order( img )</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function J= jacobian_adjoint_2p5d_1st_order( fwd_model, img) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> JACOBIAN_ADJOINT_2P5D: J= jacobian_adjoint_2p5d_1st_order( img )
 Calculate Jacobian Matrix for current stimulation EIT
 J         = Jacobian matrix
 img.fwd_model = forward model
 img.elem_data = background for jacobian calculations

 fwd_model.normalize_measurements if param exists, calculate
                                  a Jacobian for normalized
                                  difference measurements

    img.fwd_solve_2p5d_1st_order.k = [ a .. b ]
        solve, integrating over the range k = a .. b      (default: [0 Inf])
        - provide a single k to get a point solution
        - solve over a reduced range a=0, b=3 for a faster solution
    img.fwd_solve_2p5d_1st_order.method = 'name'
        perform numerical integration using the selected method (default: 'quadv')
        'trapz' - trapezoidal integration across the listed points k
        'quadv' - adaptive quadrature (vectorized), from a to b
        'integral' - adaptive quadrature (matlab2012+), from a to b</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/algorithms/left_divide.html" class="code" title="function [V] = left_divide(E,I,tol,~,V)">left_divide</a>	[V] = LEFT_DIVIDE(E,I,tol,pp,V);</li><li><a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="../../../eidors/models/convert_img_units.html" class="code" title="function y = convert_img_units(img,arg1,arg2)">convert_img_units</a>	CONVERT_IMG_UNITS change image data units</li><li><a href="../../../eidors/models/data_mapper.html" class="code" title="function img = data_mapper(img, reverse)">data_mapper</a>	DATA_MAPPER maps img.params data to elem or node data</li><li><a href="../../../eidors/models/mk_approx_c2f.html" class="code" title="function [mapping, outside] = mk_approx_c2f( f_mdl, c_mdl );">mk_approx_c2f</a>	MK_APPROX_C2F: create a mapping matrix from coarse to fine FEM</li><li><a href="../../../eidors/models/mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>	imdl = mk_geophysics_model(str, ne, [option])</li><li><a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="../../../eidors/models/num_elems.html" class="code" title="function num = num_elems( mdl );">num_elems</a>	NUM_ELEMS: number of elemnts in a (fwd or inv model or image)</li><li><a href="../../../eidors/models/supported_params.html" class="code" title="function list = supported_params">supported_params</a>	</li><li><a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>	CALC_JACOBIAN: calculate jacobian from an inv_model</li><li><a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>	FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</li><li><a href="jacobian_adjoint_2p5d_1st_order.html" class="code" title="function J= jacobian_adjoint_2p5d_1st_order( fwd_model, img)">jacobian_adjoint_2p5d_1st_order</a>	JACOBIAN_ADJOINT_2P5D: J= jacobian_adjoint_2p5d_1st_order( img )</li><li><a href="system_mat_2p5d_1st_order.html" class="code" title="function s_mat= system_mat_2p5d_1st_order( fwd_model, img)">system_mat_2p5d_1st_order</a>	SYSTEM_MAT_2P5D_1ST_ORDER: 2.5D system matrix</li><li><a href="system_mat_2p5d_fields.html" class="code" title="function FT= system_mat_2p5d_fields( fwd_model )">system_mat_2p5d_fields</a>	SYSTEM_MAT_2P5D_FIELDS: fields (elem to nodes) fraction of system mat</li><li><a href="system_mat_fields.html" class="code" title="function FC= system_mat_fields( fwd_model )">system_mat_fields</a>	SYSTEM_MAT_FIELDS: fields (elem to nodes) fraction of system mat</li><li><a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>	FWD_SOLVE: calculate data from a fwd_model object and an image</li><li><a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/models/mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>	imdl = mk_geophysics_model(str, ne, [option])</li><li><a href="jacobian_adjoint_2p5d_1st_order.html" class="code" title="function J= jacobian_adjoint_2p5d_1st_order( fwd_model, img)">jacobian_adjoint_2p5d_1st_order</a>	JACOBIAN_ADJOINT_2P5D: J= jacobian_adjoint_2p5d_1st_order( img )</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function J = jacobian_k(k, pp, gnd, stim, c2f)</a></li><li><a href="#_sub2" class="code">function v = potential_k(S, pp, gnd)</a></li><li><a href="#_sub3" class="code">function DE = jacobian_calc(pp, zi2E, FC, FT, sv, c2f)</a></li><li><a href="#_sub4" class="code">function J = apply_chain_rule(J, img, org_params)</a></li><li><a href="#_sub5" class="code">function elem_data = check_elem_data(img)</a></li><li><a href="#_sub6" class="code">function str = supported_params</a></li><li><a href="#_sub7" class="code">function do_unit_test()</a></li><li><a href="#_sub8" class="code">function S = sens(J)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function J= jacobian_adjoint_2p5d_1st_order( fwd_model, img)</a>
0002 <span class="comment">% JACOBIAN_ADJOINT_2P5D: J= jacobian_adjoint_2p5d_1st_order( img )</span>
0003 <span class="comment">% Calculate Jacobian Matrix for current stimulation EIT</span>
0004 <span class="comment">% J         = Jacobian matrix</span>
0005 <span class="comment">% img.fwd_model = forward model</span>
0006 <span class="comment">% img.elem_data = background for jacobian calculations</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% fwd_model.normalize_measurements if param exists, calculate</span>
0009 <span class="comment">%                                  a Jacobian for normalized</span>
0010 <span class="comment">%                                  difference measurements</span>
0011 <span class="comment">%</span>
0012 <span class="comment">%    img.fwd_solve_2p5d_1st_order.k = [ a .. b ]</span>
0013 <span class="comment">%        solve, integrating over the range k = a .. b      (default: [0 Inf])</span>
0014 <span class="comment">%        - provide a single k to get a point solution</span>
0015 <span class="comment">%        - solve over a reduced range a=0, b=3 for a faster solution</span>
0016 <span class="comment">%    img.fwd_solve_2p5d_1st_order.method = 'name'</span>
0017 <span class="comment">%        perform numerical integration using the selected method (default: 'quadv')</span>
0018 <span class="comment">%        'trapz' - trapezoidal integration across the listed points k</span>
0019 <span class="comment">%        'quadv' - adaptive quadrature (vectorized), from a to b</span>
0020 <span class="comment">%        'integral' - adaptive quadrature (matlab2012+), from a to b</span>
0021 
0022 
0023 <span class="comment">% (C) 2016 A Boyle</span>
0024 <span class="comment">% License: GPL version 2 or version 3</span>
0025 
0026 <span class="comment">% correct input paralemeters if function was called with only img</span>
0027 <span class="keyword">if</span> ischar(fwd_model) &amp;&amp; strcmp(fwd_model,<span class="string">'UNIT_TEST'</span>); <a href="#_sub7" class="code" title="subfunction do_unit_test()">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0028 
0029 <span class="keyword">if</span> nargin == 1
0030    img= fwd_model;
0031 <span class="keyword">elseif</span>  strcmp(getfield(warning(<span class="string">'query'</span>,<span class="string">'EIDORS:DeprecatedInterface'</span>),<span class="string">'state'</span>),<span class="string">'on'</span>)
0032    warning(<span class="string">'EIDORS:DeprecatedInterface'</span>, <span class="keyword">...</span>
0033       [<span class="string">'Calling JACOBIAN_ADJOINT with two arguments is deprecated and will cause'</span> <span class="keyword">...</span>
0034        <span class="string">' an error in a future version. First argument ignored.'</span>]);
0035 <span class="keyword">end</span>
0036 
0037 img = <a href="../../../eidors/models/data_mapper.html" class="code" title="function img = data_mapper(img, reverse)">data_mapper</a>(img);
0038 <span class="keyword">if</span> ~ismember(img.current_params, <a href="../../../eidors/models/supported_params.html" class="code" title="function list = supported_params">supported_params</a>)
0039     error(<span class="string">'EIDORS:PhysicsNotSupported'</span>, <span class="string">'%s does not support %s'</span>, <span class="keyword">...</span>
0040     <span class="string">'JACOBIAN_ADJOINT'</span>,img.current_params);
0041 <span class="keyword">end</span>
0042 
0043 org_params = img.current_params;
0044 <span class="comment">% all calcs use conductivity</span>
0045 img = <a href="../../../eidors/models/convert_img_units.html" class="code" title="function y = convert_img_units(img,arg1,arg2)">convert_img_units</a>(img, <span class="string">'conductivity'</span>);
0046 
0047 img.elem_data = <a href="#_sub5" class="code" title="subfunction elem_data = check_elem_data(img)">check_elem_data</a>(img);
0048 
0049 fwd_model= img.fwd_model;
0050 
0051 pp= <a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>( fwd_model, <span class="string">'skip_VOLUME'</span> );
0052 gnd = img.fwd_model.gnd_node;
0053 
0054 img.fwd_model.system_mat = @<a href="system_mat_2p5d_1st_order.html" class="code" title="function s_mat= system_mat_2p5d_1st_order( fwd_model, img)">system_mat_2p5d_1st_order</a>;
0055 gnd = fwd_model.gnd_node;
0056 img.fwd_model.system_mat_2p5d_1st_order.k = 0;
0057 img.fwd_model.system_mat_2p5d_1st_order.factory = 1;
0058 
0059 pp.Sf = <a href="system_mat_2p5d_1st_order.html" class="code" title="function s_mat= system_mat_2p5d_1st_order( fwd_model, img)">system_mat_2p5d_1st_order</a>( img ); <span class="comment">% returns a function Sf(k) that builds a system matrix for 'k'</span>
0060 pp.FC= <a href="system_mat_fields.html" class="code" title="function FC= system_mat_fields( fwd_model )">system_mat_fields</a>( fwd_model );
0061 pp.FT= <a href="system_mat_2p5d_fields.html" class="code" title="function FT= system_mat_2p5d_fields( fwd_model )">system_mat_2p5d_fields</a>( fwd_model );
0062 
0063 c2f = speye(pp.n_elem); <span class="keyword">try</span> c2f = img.fwd_model.coarse2fine; <span class="keyword">end</span> <span class="comment">% make code uniform by assigning 1:1 c2f if no c2f provided</span>
0064 k = [0 Inf]; <span class="keyword">try</span> k = img.fwd_model.jacobian_adjoint_2p5d_1st_order.k; <span class="keyword">end</span>
0065 method = <span class="string">'quadv'</span>; <span class="keyword">try</span> method = img.fwd_model.jacobian_adjoint_2p5d_1st_order.method; <span class="keyword">end</span>
0066 
0067 <span class="keyword">if</span> length(k) == 1 <span class="comment">% singleton k</span>
0068    J = 2*<a href="#_sub1" class="code" title="subfunction J = jacobian_k(k, pp, gnd, stim, c2f)">jacobian_k</a>(k, pp, gnd, img.fwd_model.stimulation, c2f);
0069 <span class="keyword">else</span>
0070    <span class="keyword">switch</span> method
0071       <span class="keyword">case</span> <span class="string">'trapz'</span>
0072          <span class="comment">% less accurate: trapz</span>
0073          trace = 0;
0074          <span class="keyword">if</span> trace; fprintf(<span class="string">'%8s %12s %16s %16s\n'</span>,<span class="string">'fcnt'</span>,<span class="string">'a'</span>,<span class="string">'b-a'</span>,<span class="string">'||Q||'</span>); <span class="keyword">end</span>
0075          n = 0; kil = k(1);
0076          tol = 1e-8;
0077          k(isinf(k)) = tol^(-1/6);
0078          Jf = zeros(pp.n_meas, size(c2f,2), length(k)); <span class="comment">% voltages under electrodes elec x stim, frequency domain</span>
0079          <span class="keyword">for</span> ki = k
0080             n = n + 1;
0081             Jf(:,:,n) = <a href="#_sub1" class="code" title="subfunction J = jacobian_k(k, pp, gnd, stim, c2f)">jacobian_k</a>(ki, pp, gnd, img.fwd_model.stimulation, c2f);
0082             <span class="keyword">if</span> trace; fprintf(<span class="string">'%8d     %12e %16e %16e\n'</span>,n,ki,ki-kil,norm(Jf(1,1,n))); kil = ki; <span class="keyword">end</span>
0083          <span class="keyword">end</span>
0084          J=2/pi*trapz(k,Jf,3);
0085          <span class="comment">% check</span>
0086          Jff = squeeze(reshape(Jf,pp.n_meas*size(c2f,2),1,length(k)));
0087          assert(max(abs(Jff(:,end)) &lt; tol), sprintf(<span class="string">'trapz k=%e truncated too early as k-&gt;Inf'</span>,k(end)));
0088          slope = (Jff(:,3)-Jff(:,2))./Jff(:,2); slope(Jff(:,2) == 0) = nan;
0089          <span class="comment">%clf; plot(slope); drawnow;</span>
0090          <span class="comment">%[idx]=find(abs(slope) &gt; median(abs(slope))+sqrt(tol)); clf;semilogx(k,Jff(idx,:)); drawnow;</span>
0091          assert(median(abs(slope)) &lt; sqrt(tol)*10, sprintf(<span class="string">'trapz k-&gt;0 (tol=%e), slope=%e != 0'</span>,tol,median(abs(slope))));
0092          <span class="keyword">if</span> 0 <span class="comment">% draw J(k) to check we are integrating over a large enough range</span>
0093             clf;semilogx(repmat(k,pp.n_meas*size(c2f,2),1)',Jff');
0094             xlabel(<span class="string">'k'</span>); ylabel(<span class="string">'J_k'</span>); title(<span class="string">'J_k'</span>)
0095             drawnow; pause(1);
0096          <span class="keyword">end</span>
0097          clear Jff;
0098          clear slope;
0099       <span class="keyword">case</span> <span class="string">'quadv'</span>
0100          <span class="comment">% more accurate: adaptive gaussian quadrature</span>
0101          trace = 0;
0102          tol = norm(<a href="#_sub1" class="code" title="subfunction J = jacobian_k(k, pp, gnd, stim, c2f)">jacobian_k</a>(0, pp, gnd, img.fwd_model.stimulation, 1))*1e-2;
0103          kend = min(tol^(-1/6), max(k)); <span class="comment">% don't go too far... k=Inf is a singular matrix, stop adjacent to numeric singularity</span>
0104          <span class="comment">% quadv is scheduled to be removed from matlab eventually... but it is</span>
0105          <span class="comment">% WAY faster than integral with any tolerance configuration I could identify</span>
0106          <span class="keyword">if</span> trace; fprintf(<span class="string">'%8s %12s %16s %16s\n'</span>,<span class="string">'fcnt'</span>,<span class="string">'a'</span>,<span class="string">'b-a'</span>,<span class="string">'Q(1)'</span>); <span class="keyword">end</span>
0107          J=2/pi*quadv(@(kk) <a href="#_sub1" class="code" title="subfunction J = jacobian_k(k, pp, gnd, stim, c2f)">jacobian_k</a>(kk, pp, gnd, img.fwd_model.stimulation, c2f), k(1), kend, tol, trace);
0108       <span class="keyword">case</span> <span class="string">'integral'</span>
0109          reltol = 1e-8;
0110          tol = norm(<a href="#_sub1" class="code" title="subfunction J = jacobian_k(k, pp, gnd, stim, c2f)">jacobian_k</a>(0, pp, gnd, img.fwd_model.stimulation, 1))*reltol;
0111          kend = min(tol^(-1/6), max(k)); <span class="comment">% don't go too far... k=Inf is a singular matrix, stop adjacent to numeric singularity</span>
0112          opts = {<span class="string">'ArrayValued'</span>, true,
0113                  <span class="string">'AbsTol'</span>, tol, <span class="comment">% default: 1e-10</span>
0114                  <span class="string">'RelTol'</span>,reltol}; <span class="comment">% default:  1e-6</span>
0115          opts = opts';
0116          <span class="comment">% the integral solution is about 10x slower (5.47 seconds vs. 0.60 seconds for UNIT_TEST)</span>
0117          <span class="comment">% ... I played with AbsTol and RelTol but wasn't able to affect the outcome</span>
0118          J=2/pi*integral(@(kk) <a href="#_sub1" class="code" title="subfunction J = jacobian_k(k, pp, gnd, stim, c2f)">jacobian_k</a>(kk, pp, gnd, img.fwd_model.stimulation, c2f), k(1), kend, <span class="string">'ArrayVAlued'</span>, true);
0119       <span class="keyword">otherwise</span>
0120          error([<span class="string">'unrecognized method: '</span> method]);
0121    <span class="keyword">end</span>
0122 <span class="keyword">end</span>
0123 
0124 <span class="keyword">if</span> ~strcmp(org_params,<span class="string">'conductivity'</span>)
0125     J = <a href="#_sub4" class="code" title="subfunction J = apply_chain_rule(J, img, org_params)">apply_chain_rule</a>(J, img, org_params);
0126     <span class="keyword">if</span> isfield(fwd_model, <span class="string">'coarse2fine'</span>) &amp;&amp; <span class="keyword">...</span>
0127           size(img.elem_data,1)==size(fwd_model.coarse2fine,1)
0128             J=J*fwd_model.coarse2fine;
0129             nparam = size(fwd_model.coarse2fine,2);
0130     <span class="keyword">end</span>
0131 <span class="keyword">end</span>
0132 
0133 <span class="comment">%restore img to original condition</span>
0134 <span class="keyword">if</span> ~strcmp(org_params,<span class="string">'conductivity'</span>) || isfield(img, org_params)
0135     img = rmfield(img,<span class="string">'elem_data'</span>);
0136     img.current_params = [];
0137 <span class="keyword">end</span>
0138 
0139 <span class="comment">% calculate normalized Jacobian</span>
0140 <span class="keyword">if</span> pp.normalize
0141    data= <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>( img );
0142    J= J ./ (data.meas(:)*ones(1,nparam));
0143 
0144 <span class="keyword">end</span>
0145 
0146 <a name="_sub1" href="#_subfunctions" class="code">function J = jacobian_k(k, pp, gnd, stim, c2f)</a>
0147    SS = pp.Sf(k);
0148    idx = 1:size(SS,1);
0149    idx( gnd ) = [];
0150    
0151    sv = <a href="#_sub2" class="code" title="subfunction v = potential_k(S, pp, gnd)">potential_k</a>(SS, pp, gnd);
0152    
0153    zi2E= zeros(pp.n_elec, pp.n_node);
0154    zi2E(:, idx)= -pp.N2E(:,idx)/ SS(idx,idx);
0155    
0156    <span class="comment">% NOTE: this is k*FT here, not k^2*FT: FT is squared in jacobian_calc (FT*DE*FT)</span>
0157    DE = <a href="#_sub3" class="code" title="subfunction DE = jacobian_calc(pp, zi2E, FC, FT, sv, c2f)">jacobian_calc</a>(pp, zi2E, pp.FC, k*pp.FT, sv, c2f);
0158    
0159    J = zeros( pp.n_meas, size(c2f,2) );
0160    idx=0;
0161    <span class="keyword">for</span> j= 1:pp.n_stim
0162       meas_pat= stim(j).meas_pattern;
0163       n_meas  = size(meas_pat,1);
0164       DEj = reshape( DE(:,j,:), pp.n_elec, size(c2f,2) );
0165       J( idx+(1:n_meas),: ) = meas_pat*DEj;
0166       idx= idx+ n_meas;
0167    <span class="keyword">end</span>
0168 
0169 <a name="_sub2" href="#_subfunctions" class="code">function v = potential_k(S, pp, gnd)</a>
0170    idx = 1:size(S,1);
0171    idx( gnd ) = [];
0172    idx2 = find(any(pp.N2E));
0173    v = zeros(pp.n_node, pp.n_stim); <span class="comment">% voltages at all nodes x number of stim, frequency domain</span>
0174    v(idx,:) = <a href="../../../eidors/algorithms/left_divide.html" class="code" title="function [V] = left_divide(E,I,tol,~,V)">left_divide</a>( S(idx,idx), 1/2*pp.QQ(idx,:) );
0175 
0176 <span class="comment">% DE_{i,j,k} is dV_i,j / dS_k</span>
0177 <span class="comment">%  where V_i is change in voltage on electrode i for</span>
0178 <span class="comment">%        stimulation pattern j</span>
0179 <span class="comment">%        S_k is change in conductivity on element k</span>
0180 <a name="_sub3" href="#_subfunctions" class="code">function DE = jacobian_calc(pp, zi2E, FC, FT, sv, c2f)</a>
0181    d0 = pp.n_dims + 0;
0182    d1 = pp.n_dims + 1;
0183    
0184    zi2E_FCt = zi2E * FC';
0185    zi2E_FTt = zi2E * FT';
0186    
0187    FC_sv = FC * sv;
0188    FT_sv = FT * sv;
0189 
0190    DE= zeros(pp.n_elec, pp.n_stim, size(c2f,2) );
0191    de0= pp.n_elem * d0;
0192    de1= pp.n_elem * d1;
0193    <span class="keyword">if</span> all(all(speye(size(c2f)) == c2f))
0194       <span class="keyword">for</span> k= 1:size(c2f,2);
0195          idx = d0*(k-1)+1 : d0*k;
0196          dq1= zi2E_FCt(:,idx) * FC_sv(idx,:);
0197          dq2= zi2E_FTt(:,idx) * FT_sv(idx,:);
0198          DE(:,:,k)= dq1 + dq2;
0199       <span class="keyword">end</span>
0200    <span class="keyword">elseif</span> 0 <span class="comment">% Code is slower</span>
0201       <span class="keyword">for</span> k= 1:size(c2f,2);
0202          chg_col = kron( c2f(:,k), ones(d0,1));
0203          dDD_dEj = spdiags(chg_col, 0, de0, de0);
0204          dq1 = zi2E_FCt * dDD_dEj * FC_sv;
0205          chg_col = kron( c2f(:,k), ones(d1,1));
0206          dDD_dEj = spdiags(chg_col, 0, de1, de1);
0207          dq2 = zi2E_FTt * dDD_dEj * FT_sv;
0208          DE(:,:,k)= dq1 + dq2;
0209       <span class="keyword">end</span>
0210    <span class="keyword">else</span>
0211       <span class="keyword">for</span> k= 1:size(c2f,2);
0212          ff = find( c2f(:,k) &gt; 1e-8 );
0213          lff= length(ff)*d0;
0214          ff1= ones(d0,1) * ff(:)';
0215          ffd= d0*ff1 + (-(d0-1):0)'*ones(1,length(ff));
0216          dDD_dEj = spdiags(c2f(ff1,k), 0, lff, lff);
0217          dq1= zi2E_FCt(:,ffd) * dDD_dEj * FC_sv(ffd,:);
0218          lff= length(ff)*d1;
0219          ff1= ones(d1,1) * ff(:)';
0220          ffd= d1*ff1 + (-(d1-1):0)'*ones(1,length(ff));
0221          dDD_dEj = spdiags(c2f(ff1,k), 0, lff, lff);
0222          dq2= zi2E_FTt(:,ffd) * dDD_dEj * FT_sv(ffd,:);
0223          DE(:,:,k)= dq1 + dq2;
0224       <span class="keyword">end</span>
0225    <span class="keyword">end</span>
0226 
0227 <a name="_sub4" href="#_subfunctions" class="code">function J = apply_chain_rule(J, img, org_params)</a>
0228    <span class="keyword">switch</span>(org_params)
0229       <span class="keyword">case</span> <span class="string">'resistivity'</span>
0230          dCond_dPhys = -img.elem_data.^2;
0231       <span class="keyword">case</span> <span class="string">'log_resistivity'</span>
0232          dCond_dPhys = -img.elem_data;
0233       <span class="keyword">case</span> <span class="string">'log_conductivity'</span>
0234          dCond_dPhys = img.elem_data;
0235       <span class="keyword">otherwise</span>
0236          error(<span class="string">'not implemented yet'</span>)
0237    <span class="keyword">end</span>
0238    J = J.*repmat(dCond_dPhys ,1,size(J,1))';
0239 
0240 <a name="_sub5" href="#_subfunctions" class="code">function elem_data = check_elem_data(img)</a>
0241    elem_data = img.elem_data;
0242    sz_elem_data = size(elem_data);
0243    <span class="keyword">if</span> sz_elem_data(2) ~= 1;
0244       error(<span class="string">'jacobian_adjoin: can only solve one image (sz_elem_data=%)'</span>, <span class="keyword">...</span>
0245             sz_elem_data);
0246    <span class="keyword">end</span>
0247 
0248    <span class="keyword">if</span> isfield(img.fwd_model, <span class="string">'coarse2fine'</span>);
0249       c2f = img.fwd_model.coarse2fine;
0250       sz_c2f = size(c2f);
0251       <span class="keyword">switch</span> sz_elem_data(1)
0252          <span class="keyword">case</span> sz_c2f(1); <span class="comment">% Ok</span>
0253          <span class="keyword">case</span> sz_c2f(2); elem_data = c2f * elem_data;
0254          <span class="keyword">otherwise</span>; error([<span class="string">'jacobian_adjoint: provided elem_data '</span> <span class="keyword">...</span>
0255               <span class="string">' (sz=%d) does not match c2f (sz=%d %d)'</span>], sz_elem_data(1), sz_c2f);
0256       <span class="keyword">end</span>
0257    <span class="keyword">else</span>
0258       <span class="keyword">if</span> sz_elem_data(1) ~= <a href="../../../eidors/models/num_elems.html" class="code" title="function num = num_elems( mdl );">num_elems</a>(img.fwd_model)
0259          error([<span class="string">'jacobian_adjoint: provided elem_data (sz=%d) does '</span> <span class="keyword">...</span>
0260             <span class="string">' not match fwd_model (sz=%d)'</span>], sz_elem_data(1), <a href="../../../eidors/models/num_elems.html" class="code" title="function num = num_elems( mdl );">num_elems</a>(sz_c2f));
0261       <span class="keyword">end</span>
0262    <span class="keyword">end</span>
0263 
0264 <a name="_sub6" href="#_subfunctions" class="code">function str = supported_params</a>
0265     str = {<span class="string">'conductivity'</span>
0266            <span class="string">'resistivity'</span>
0267            <span class="string">'log_conductivity'</span>
0268            <span class="string">'log_resistivity'</span>};
0269 
0270 <a name="_sub7" href="#_subfunctions" class="code">function do_unit_test()</a>
0271    imdl2 = <a href="../../../eidors/models/mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'h22c'</span>,16);
0272    assert(length(imdl2.rec_model.elems) &gt; 20, <span class="string">'expect sufficient rec_model density'</span>);
0273    img2 = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl2,1);
0274    <span class="keyword">if</span> 0 <span class="comment">% check model c2f</span>
0275       clf; subplot(121); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imdl2.fwd_model); subplot(122); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imdl2.rec_model);
0276       c2f=imdl2.fwd_model.coarse2fine; img2r = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl2); img2r.fwd_model = imdl2.rec_model; img2r.elem_data = zeros(size(c2f,2),1);
0277       <span class="keyword">for</span> i=1:size(c2f,2)
0278          subplot(121);
0279          img2.elem_data = c2f(:,i); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img2); title(sprintf(<span class="string">'%d'</span>,i));
0280          subplot(122);
0281          img2r.elem_data(:) = 0; img2r.elem_data(i)=1; <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img2r);  title(sprintf(<span class="string">'%d'</span>,i));
0282          drawnow; pause(0.25);
0283       <span class="keyword">end</span>
0284    <span class="keyword">end</span>
0285 
0286    <span class="comment">% for the 3d model, we throw out the rec_model and inject the</span>
0287    <span class="comment">% imdl2.rec_model, then recalculate the c2f so that we can compare apples to</span>
0288    <span class="comment">% apples when we take ||Jxxx - J3||</span>
0289    imdl3 = <a href="../../../eidors/models/mk_geophysics_model.html" class="code" title="function imdl = mk_geophysics_model(str, ne, opt);">mk_geophysics_model</a>(<span class="string">'h32c'</span>,16);
0290    <span class="keyword">for</span> s = {<span class="string">'nodes'</span>, <span class="string">'elems'</span>, <span class="string">'boundary'</span>, <span class="string">'name'</span>,<span class="string">'electrode'</span>}
0291       imdl3.rec_model.(s{:}) = imdl2.rec_model.(s{:});
0292    <span class="keyword">end</span>
0293    disp(<span class="string">'recalculating 3D c2f, so that coarse meshes agree (2D vs 3D)'</span>);
0294    [c2f,bkgnd] = <a href="../../../eidors/models/mk_approx_c2f.html" class="code" title="function [mapping, outside] = mk_approx_c2f( f_mdl, c_mdl );">mk_approx_c2f</a>(imdl3.fwd_model, imdl3.rec_model);
0295    imdl3.fwd_model.coarse2fine = c2f;
0296    imdl3.fwd_model.background = bkgnd;
0297    img3 = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl3,1);
0298    <span class="keyword">if</span> 0 <span class="comment">% check model c2f</span>
0299       clf; subplot(121); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imdl3.fwd_model); subplot(122); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imdl3.rec_model);
0300       c2f=imdl3.fwd_model.coarse2fine; img3r = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl3); img3r.fwd_model = imdl3.rec_model; img3r.elem_data = zeros(size(c2f,2),1);
0301       <span class="keyword">for</span> i=1:size(c2f,2)
0302          subplot(121);
0303          img3.elem_data = c2f(:,i); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img3); title(sprintf(<span class="string">'%d'</span>,i));
0304          subplot(122);
0305          img3r.elem_data(:) = 0; img3r.elem_data(i)=1; <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img3r);  title(sprintf(<span class="string">'%d'</span>,i));
0306          drawnow; pause(0.25);
0307       <span class="keyword">end</span>
0308    <span class="keyword">end</span>
0309 
0310    t = tic;
0311    img2.fwd_model.nodes(1,:) = img2.fwd_model.nodes(1,:) + rand(1,2)*1e-8; <span class="comment">% defeat cache</span>
0312    J2 = <a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>(img2);
0313    fprintf(<span class="string">' 2D                         = %.2f sec\n'</span>, toc(t));
0314 
0315    t = tic;
0316    img2.fwd_model.nodes(1,:) = img2.fwd_model.nodes(1,:) + rand(1,2)*1e-8; <span class="comment">% defeat cache</span>
0317    img2.fwd_model.jacobian = @<a href="jacobian_adjoint_2p5d_1st_order.html" class="code" title="function J= jacobian_adjoint_2p5d_1st_order( fwd_model, img)">jacobian_adjoint_2p5d_1st_order</a>;
0318    img2.fwd_model.jacobian_adjoint_2p5d_1st_order.k = 0;
0319    J2p50 = <a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>(img2);
0320    fprintf(<span class="string">' 2.5D (k=0)                 = %.2f sec\n'</span>, toc(t));
0321 
0322    ke = [0 0 0];
0323    t = tic;
0324    img2.fwd_model.nodes(1,:) = img2.fwd_model.nodes(1,:) + rand(1,2)*1e-8; <span class="comment">% defeat cache</span>
0325    img2.fwd_model.jacobian = @<a href="jacobian_adjoint_2p5d_1st_order.html" class="code" title="function J= jacobian_adjoint_2p5d_1st_order( fwd_model, img)">jacobian_adjoint_2p5d_1st_order</a>;
0326    img2.fwd_model.jacobian_adjoint_2p5d_1st_order.k = [0 logspace(-4,1,100)]; <span class="comment">% capture all the effects to (k^2 T)!</span>
0327    img2.fwd_model.jacobian_adjoint_2p5d_1st_order.method = <span class="string">'trapz'</span>;
0328    J2p5kt = <a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>(img2);
0329    ke(1) = img2.fwd_model.jacobian_adjoint_2p5d_1st_order.k(end);
0330    fprintf(<span class="string">' 2.5D (k=0..%.1f, trapz)    = %.2f sec\n'</span>, ke(1), toc(t));
0331    t = tic;
0332    img2.fwd_model.nodes(1,:) = img2.fwd_model.nodes(1,:) + rand(1,2)*1e-8; <span class="comment">% defeat cache</span>
0333    img2.fwd_model.jacobian = @<a href="jacobian_adjoint_2p5d_1st_order.html" class="code" title="function J= jacobian_adjoint_2p5d_1st_order( fwd_model, img)">jacobian_adjoint_2p5d_1st_order</a>;
0334    img2.fwd_model.jacobian_adjoint_2p5d_1st_order.k = [0 Inf];
0335    img2.fwd_model.jacobian_adjoint_2p5d_1st_order.method = <span class="string">'quadv'</span>;
0336    J2p5kq = <a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>(img2);
0337    ke(2) = img2.fwd_model.jacobian_adjoint_2p5d_1st_order.k(end);
0338    fprintf(<span class="string">' 2.5D (k=0..%.1f, quadv)    = %.2f sec\n'</span>, ke(2), toc(t));
0339    t = tic;
0340    img2.fwd_model.nodes(1,:) = img2.fwd_model.nodes(1,:) + rand(1,2)*1e-8; <span class="comment">% defeat cache</span>
0341    img2.fwd_model.jacobian = @<a href="jacobian_adjoint_2p5d_1st_order.html" class="code" title="function J= jacobian_adjoint_2p5d_1st_order( fwd_model, img)">jacobian_adjoint_2p5d_1st_order</a>;
0342    img2.fwd_model.jacobian_adjoint_2p5d_1st_order.k = [0 Inf];
0343    img2.fwd_model.jacobian_adjoint_2p5d_1st_order.method = <span class="string">'integral'</span>;
0344    J2p5ki = <a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>(img2);
0345    ke(3) = img2.fwd_model.jacobian_adjoint_2p5d_1st_order.k(end);
0346    fprintf(<span class="string">' 2.5D (k=0..%.1f, integral) = %.2f sec\n'</span>, ke(3), toc(t));
0347 
0348    t = tic;
0349    img3.fwd_model.nodes(1,:) = img3.fwd_model.nodes(1,:) + rand(1,3)*1e-8; <span class="comment">% defeat cache</span>
0350    J3 = <a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>(img3);
0351    fprintf(<span class="string">' 3D                         = %.2f sec\n'</span>, toc(t));
0352 
0353 
0354    tol = 1e-8;
0355    reltol = norm(J3)*2e-2;
0356    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2D                          vs 3D'</span>, J2, J3, -tol);
0357    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2.5D (k=0)                  vs 2D'</span>, J2p50, J2, tol);
0358    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(sprintf(<span class="string">'2.5D (k=0..%-4.1f) (trapz)    vs 3D'</span>,ke(1)), J2p5kt, J3, 2*reltol);
0359    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(sprintf(<span class="string">'2.5D (k=0..%-4.1f) (quadv)    vs 3D'</span>,ke(2)), J2p5kq, J3, reltol);
0360    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(sprintf(<span class="string">'2.5D (k=0..%-4.1f) (integral) vs 3D'</span>,ke(3)), J2p5ki, J3, reltol);
0361 
0362    imgr = img2;
0363    imgr.fwd_model = imdl2.rec_model;
0364    clf; subplot(221); imgr.elem_data = <a href="#_sub8" class="code" title="subfunction S = sens(J)">sens</a>(J3); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgr,1); title(<span class="string">'3D [log_{10}]'</span>);
0365         subplot(222); imgr.elem_data = <a href="#_sub8" class="code" title="subfunction S = sens(J)">sens</a>(J2); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgr,1); title(<span class="string">'2D [log_{10}]'</span>);
0366         subplot(223); imgr.elem_data = <a href="#_sub8" class="code" title="subfunction S = sens(J)">sens</a>(J2p5kq); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgr,1); title(<span class="string">'2.5D (k=0..3.0) [log_{10}]'</span>);
0367         subplot(224); imgr.elem_data = <a href="#_sub8" class="code" title="subfunction S = sens(J)">sens</a>(J2p50); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgr,1); title(<span class="string">'2.5D (k=0) [log_{10}]'</span>);
0368    <span class="keyword">if</span> 1
0369         subplot(222); imgr.elem_data = <a href="#_sub8" class="code" title="subfunction S = sens(J)">sens</a>(J2p5kt); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgr,1); title(<span class="string">'2.5D (k=0..3.0) trapz [log_{10}]'</span>);
0370         subplot(223); imgr.elem_data = <a href="#_sub8" class="code" title="subfunction S = sens(J)">sens</a>(J2p5kq); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgr,1); title(<span class="string">'2.5D (k=0..Inf) quadv [log_{10}]'</span>);
0371         subplot(224); imgr.elem_data = <a href="#_sub8" class="code" title="subfunction S = sens(J)">sens</a>(J2p5ki); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgr,1); title(<span class="string">'2.5D (k=0..Inf) integral [log_{10}]'</span>);
0372    <span class="keyword">end</span>
0373 
0374 <a name="_sub8" href="#_subfunctions" class="code">function S = sens(J)</a>
0375    S = log10(sum(J.^2,1));</pre></div>
<hr><address>Generated on Fri 01-Jun-2018 15:59:55 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>