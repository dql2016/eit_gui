<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of mk_circ_tank</title>
  <meta name="keywords" content="mk_circ_tank">
  <meta name="description" content="MK_CIRC_TANK: make a cylindrical tank FEM geometry in 2D or 3D">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">eidors</a> &gt; <a href="index.html">models</a> &gt; mk_circ_tank.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/models&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>mk_circ_tank
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>MK_CIRC_TANK: make a cylindrical tank FEM geometry in 2D or 3D</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function param= mk_circ_tank(rings, levels, elec_spec ); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">MK_CIRC_TANK: make a cylindrical tank FEM geometry in 2D or 3D
 param= mk_circ_tank(rings, levels, elec_spec );
 
 rings:  number of horizontal plane rings (divisible by 4)
 levels: vector of vertical placement of levels
     for 2D mesh, levels = []
 
 elec_spec: parameter to specify number of electrodes
        specified as { 'opt1', val11, val12 , 'opt2', val21, val22 }

 elec_spec = scalar (divisible by 4)
      - puts a single plane of electrodes in centre of cylinder
 eg. elec_spec  = 16

 elec_spec = { 'planes', n_elecs, elec_planes }
      - puts plane each of n_elecs at planes specified by elec_planes
 eg. elec_spec  =  {'planes', 16, [2,6,8]}

 elec_spec = { 'zigzag', n_elecs, elec_planes }
      - puts plane of n_elecs 'zigzagged' electrodes onto planes specified
        1st elec on plane 2, 2nd elec on plane 6, 3rd on plane 2, etc 
 eg. elec_spec  =  {'zigzag', 16, [2,6]}
      - Note, based on the restults of Graham et al (2006), zigzag
        electrode placement is not recommended
      - In order to implement the 'planar3d' pattern from this paper,
        puts 2d electrodes onto rings ie [ ...  7  8  1  2  ...
                                           ... 15 16  9 10  ... ]
      -&gt;use  elec_spec = { 'planes', n_elecs/2, elec_planes }

 mk_circ_tank creates simple, point electrodes. Improved models
  may be created with ng_mk_cyl_models

 output:
  param.name        Model name (if known) 
  param.nodes       position of FEM nodes (Nodes x Dims) 
  param.elems       definition of FEM elements (Elems x Dims+1) 
  param.boundary    nodes of element faces on the medium surface 
  param.gnd_node    Number of node connected to ground 
  param.electrode   Vector (Num_elecs x 1) of electrode models (elec_model)</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="mk_circ_tank.html" class="code" title="function param= mk_circ_tank(rings, levels, elec_spec );">mk_circ_tank</a>	MK_CIRC_TANK: make a cylindrical tank FEM geometry in 2D or 3D</li><li><a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/deprecated/iso_f_smooth.html" class="code" title="function [Reg] = iso_f_smooth(simp,vtx,deg,w);">iso_f_smooth</a>	function [Reg] = iso_f_smooth(simp,vtx,deg,w);</li><li><a href="../../eidors/examples/cheating_2d.html" class="code" title="function out=cheating_2d( figno, rand_seed )">cheating_2d</a>	code to simulate inverse crimes in EIT</li><li><a href="../../eidors/examples/demo_2d_simdata.html" class="code" title="">demo_2d_simdata</a>	Example of using EIDORS to simulate 2D data and to</li><li><a href="../../eidors/examples/demo_3d_simdata.html" class="code" title="">demo_3d_simdata</a>	How to make simulation data using EIDORS3D</li><li><a href="mk_analytic_c2f.html" class="code" title="function [mapping, outside] = mk_analytic_c2f( f_mdl, c_mdl, opt)">mk_analytic_c2f</a>	MK_ANALYTIC_C2F: create a mapping matrix from coarse to fine FEM</li><li><a href="mk_approx_c2f.html" class="code" title="function [mapping, outside] = mk_approx_c2f( f_mdl, c_mdl );">mk_approx_c2f</a>	MK_APPROX_C2F: create a mapping matrix from coarse to fine FEM</li><li><a href="mk_circ_tank.html" class="code" title="function param= mk_circ_tank(rings, levels, elec_spec );">mk_circ_tank</a>	MK_CIRC_TANK: make a cylindrical tank FEM geometry in 2D or 3D</li><li><a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="simulate_2d_movement.html" class="code" title="function [vh,vi,xyr_pt]= simulate_2d_movement( n_sims, fmdl, rad_pr, movefcn )">simulate_2d_movement</a>	SIMULATE_2D_MOVEMENT simulate rotational movement in 2D</li><li><a href="../../eidors/solvers/forward/system_mat_1st_order.html" class="code" title="function s_mat= system_mat_1st_order( fwd_model, img)">system_mat_1st_order</a>	SYSTEM_MAT_1ST_ORDER: SS= system_mat_1st_order( fwd_model, img)</li><li><a href="../../eidors/solvers/inverse/prior_laplace.html" class="code" title="function Reg= prior_laplace( inv_model )">prior_laplace</a>	PRIOR_LAPLACE calculate image prior</li><li><a href="../../eidors/solvers/inverse/prior_laplace_old.html" class="code" title="function Reg= prior_laplace_old( inv_model );">prior_laplace_old</a>	PRIOR_LAPLACE calculate image prior</li><li><a href="../../eidors/tests/calc_data_prior_test.html" class="code" title="function ok= calc_data_prior_test">calc_data_prior_test</a>	Verify dataprior:</li><li><a href="../../eidors/tests/calc_jacobian_test.html" class="code" title="function ok= calc_jacobian_test">calc_jacobian_test</a>	Verify Jacobian Calculation by small derivative from forward problem</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function elec_nodes= electrode_pattern( point_elec_nodes, elec_spec )</a></li><li><a href="#_sub2" class="code">function [ELEM, NODE, bdy_nodes, point_elec_nodes, NODE_order] =</a></li><li><a href="#_sub3" class="code">function [ELEM, NODE, BDY, elec_nodes] = mk_3D_model(</a></li><li><a href="#_sub4" class="code">function elec_struct = mk_electrodes( elec_nodes)</a></li><li><a href="#_sub5" class="code">function elem=  node_reorder( elem0, node_order);</a></li><li><a href="#_sub6" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function param= mk_circ_tank(rings, levels, elec_spec );</a>
0002 <span class="comment">%MK_CIRC_TANK: make a cylindrical tank FEM geometry in 2D or 3D</span>
0003 <span class="comment">% param= mk_circ_tank(rings, levels, elec_spec );</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% rings:  number of horizontal plane rings (divisible by 4)</span>
0006 <span class="comment">% levels: vector of vertical placement of levels</span>
0007 <span class="comment">%     for 2D mesh, levels = []</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% elec_spec: parameter to specify number of electrodes</span>
0010 <span class="comment">%        specified as { 'opt1', val11, val12 , 'opt2', val21, val22 }</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% elec_spec = scalar (divisible by 4)</span>
0013 <span class="comment">%      - puts a single plane of electrodes in centre of cylinder</span>
0014 <span class="comment">% eg. elec_spec  = 16</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% elec_spec = { 'planes', n_elecs, elec_planes }</span>
0017 <span class="comment">%      - puts plane each of n_elecs at planes specified by elec_planes</span>
0018 <span class="comment">% eg. elec_spec  =  {'planes', 16, [2,6,8]}</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% elec_spec = { 'zigzag', n_elecs, elec_planes }</span>
0021 <span class="comment">%      - puts plane of n_elecs 'zigzagged' electrodes onto planes specified</span>
0022 <span class="comment">%        1st elec on plane 2, 2nd elec on plane 6, 3rd on plane 2, etc</span>
0023 <span class="comment">% eg. elec_spec  =  {'zigzag', 16, [2,6]}</span>
0024 <span class="comment">%      - Note, based on the restults of Graham et al (2006), zigzag</span>
0025 <span class="comment">%        electrode placement is not recommended</span>
0026 <span class="comment">%      - In order to implement the 'planar3d' pattern from this paper,</span>
0027 <span class="comment">%        puts 2d electrodes onto rings ie [ ...  7  8  1  2  ...</span>
0028 <span class="comment">%                                           ... 15 16  9 10  ... ]</span>
0029 <span class="comment">%      -&gt;use  elec_spec = { 'planes', n_elecs/2, elec_planes }</span>
0030 <span class="comment">%</span>
0031 <span class="comment">% mk_circ_tank creates simple, point electrodes. Improved models</span>
0032 <span class="comment">%  may be created with ng_mk_cyl_models</span>
0033 <span class="comment">%</span>
0034 <span class="comment">% output:</span>
0035 <span class="comment">%  param.name        Model name (if known)</span>
0036 <span class="comment">%  param.nodes       position of FEM nodes (Nodes x Dims)</span>
0037 <span class="comment">%  param.elems       definition of FEM elements (Elems x Dims+1)</span>
0038 <span class="comment">%  param.boundary    nodes of element faces on the medium surface</span>
0039 <span class="comment">%  param.gnd_node    Number of node connected to ground</span>
0040 <span class="comment">%  param.electrode   Vector (Num_elecs x 1) of electrode models (elec_model)</span>
0041 
0042 <span class="comment">% (C) 2005 Andy Adler. License: GPL version 2 or version 3</span>
0043 <span class="comment">% $Id: mk_circ_tank.m 5112 2015-06-14 13:00:41Z aadler $</span>
0044 
0045 <span class="keyword">if</span> ischar(rings) &amp;&amp; strcmp(rings,<span class="string">'UNIT_TEST'</span>); <a href="#_sub6" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0046 
0047 
0048 <span class="comment">% parse easy case of electrode specifications</span>
0049 n_elec= [];
0050 <span class="keyword">if</span> size(elec_spec) == [1,1] <span class="keyword">if</span> isnumeric(elec_spec)
0051    n_elec= elec_spec;
0052 <span class="keyword">end</span>; <span class="keyword">end</span>
0053 
0054 [elem, node, bdy, point_elec_nodes, node_order] = mk_2D_model( rings );
0055 
0056 <span class="keyword">if</span> isempty( levels ) <span class="comment">% 2D</span>
0057    
0058    <span class="keyword">if</span> n_elec==0
0059       elec_nodes= [];
0060    <span class="keyword">elseif</span> ~isempty( n_elec )
0061       idx= (0:n_elec-1)*length(point_elec_nodes)/n_elec + 1;
0062       <span class="keyword">if</span> any(rem(idx,1) ~= 0);
0063          error(<span class="string">'The requested number of electrodes (%d) is not compatible with this FEM mesh'</span>, n_elec)
0064       <span class="keyword">end</span>
0065       elec_nodes= point_elec_nodes( idx );
0066    <span class="keyword">else</span>
0067       error(<span class="string">'2D models only support scalar electrode patterns'</span>);
0068    <span class="keyword">end</span>
0069 <span class="keyword">else</span>  <span class="comment">%3D</span>
0070    [elem, node, bdy, point_elec_nodes] = <a href="#_sub3" class="code" title="subfunction [ELEM, NODE, BDY, elec_nodes] = mk_3D_model( ">mk_3D_model</a>( elem, node, <span class="keyword">...</span>
0071                   levels, bdy, point_elec_nodes, node_order );
0072 
0073    <span class="keyword">if</span> n_elec==0
0074       elec_nodes= [];
0075    <span class="keyword">elseif</span> ~isempty( n_elec )
0076       idx= (0:n_elec-1)*length(point_elec_nodes)/n_elec + 1;
0077       half_lev = ceil( length(levels)/2 );
0078       elec_nodes= point_elec_nodes( half_lev, idx );
0079    <span class="keyword">else</span>
0080       elec_nodes= <a href="#_sub1" class="code" title="subfunction elec_nodes= electrode_pattern( point_elec_nodes, elec_spec )">electrode_pattern</a>( point_elec_nodes, elec_spec );
0081    <span class="keyword">end</span>
0082 
0083 <span class="keyword">end</span>
0084 
0085 param.name= sprintf(<span class="string">'EIT FEM by mk_circ_tank with N=%d levs=%d'</span>, <span class="keyword">...</span>
0086                     rings, length(levels) );
0087 param.nodes = node';
0088 param.elems = elem';
0089 param.boundary = bdy';
0090 param.gnd_node = 1; <span class="comment">% node at bottom and center of the tank</span>
0091 <span class="keyword">if</span> ~isempty( elec_nodes)
0092    param.electrode =  <a href="#_sub4" class="code" title="subfunction elec_struct = mk_electrodes( elec_nodes)">mk_electrodes</a>( elec_nodes );
0093 <span class="keyword">end</span>
0094 param.type = <span class="string">'fwd_model'</span>;
0095 
0096 param.normalize_measurements = 0; <span class="comment">% default</span>
0097 
0098 <span class="keyword">return</span>;
0099 
0100 <span class="comment">% parse the elec_spec parameter</span>
0101 <span class="comment">% elec_spec = { 'planes', n_elecs, elec_planes }</span>
0102 <span class="comment">%      - puts plane each of n_elecs at planes specified by elec_planes</span>
0103 <span class="comment">% eg. elec_spec  =  {'planes', 16, [2,6,8]}</span>
0104 <span class="comment">%</span>
0105 <span class="comment">% elec_spec = { 'zigzag', n_elecs, elec_planes }</span>
0106 <span class="comment">%      - puts plane of n_elecs 'zigzagged' electrodes onto planes specified</span>
0107 <span class="comment">%        1st elec on plane 2, 2nd elec on plane 6, 3rd on plane 2, etc</span>
0108 <span class="comment">% eg. elec_spec  =  {'zigzag', 16, [2,6]}</span>
0109 <a name="_sub1" href="#_subfunctions" class="code">function elec_nodes= electrode_pattern( point_elec_nodes, elec_spec )</a>
0110    elec_nodes= [];
0111    lpe = size(point_elec_nodes,2);
0112    nlev= size(point_elec_nodes,1);
0113    <span class="keyword">for</span> i=1:3:length(elec_spec)-2
0114       spec = elec_spec{i};
0115       <span class="keyword">if</span>      strcmp( spec,<span class="string">'planes'</span> )
0116           n_elec= elec_spec{i+1};
0117           levs =  elec_spec{i+2};
0118 
0119           eidx= (0:n_elec-1);
0120           idx= round(eidx*lpe/n_elec) + 1;
0121           nodes= point_elec_nodes( levs, idx )';
0122           elec_nodes= [ elec_nodes; nodes(:) ];
0123       <span class="keyword">elseif</span>  strcmp( spec,<span class="string">'zigzag'</span> )
0124           n_elec= elec_spec{i+1};
0125           levs =  elec_spec{i+2};
0126           <span class="keyword">if</span> any(levs &gt; size(point_elec_nodes,1))
0127              error(<span class="string">'requested electrode plane larger than FEModel'</span>);
0128           <span class="keyword">end</span>
0129 
0130           eidx= (0:n_elec-1);
0131           idx= round(eidx*lpe/n_elec)*nlev + <span class="keyword">...</span>
0132                levs( rem( eidx, length(levs))+1);
0133           nodes= point_elec_nodes( idx );
0134           elec_nodes= [ elec_nodes; nodes(:) ];
0135       <span class="keyword">else</span>
0136         error(<span class="string">'elec_spec parameter not understood'</span>);
0137       <span class="keyword">end</span>
0138    <span class="keyword">end</span>
0139 
0140 <span class="comment">% Create a simple 2D regular mesh, based on N circular rings</span>
0141 <span class="comment">%   and n_elec electrodes</span>
0142 <a name="_sub2" href="#_subfunctions" class="code">function [ELEM, NODE, bdy_nodes, point_elec_nodes, NODE_order] =  </a><span class="keyword">...</span>
0143           mk_2D_model( N );
0144   ELEM=[];
0145   NODE= [0;0];
0146   NODE_order= [1];
0147   int=1;
0148   <span class="keyword">for</span> k=1:N
0149     phi= (0:4*k-1)*pi/2/k;
0150     NODE= [NODE k/N*[sin(phi);cos(phi)]];
0151 
0152 <span class="comment">% NODE_order for extruded 3D model      3 1 2 3 1</span>
0153 <span class="comment">%                                     1 2 3 1 2 3</span>
0154     NOq= rem(k+(0:k),3)+1;
0155     NODE_order= [NODE_order, NOq([1:k, k+1:-1:2, 1:k, k+1:-1:2])];
0156 
0157     ext= 2*(k*k-k+1);
0158     idxe=[0:k-1; 1:k];
0159     idxi=[0:k-1]; 
0160     elem= [ ext+idxe, ext+2*k+[-idxe idxe], <span class="keyword">...</span>
0161                      ext+rem(4*k-idxe,4*k), <span class="keyword">...</span>
0162             ext+idxe, ext+2*k+[-idxe idxe], <span class="keyword">...</span>
0163                      ext+rem(4*k-idxe,4*k);
0164             int+idxi, int+2*(k-1)+[-idxi, idxi], <span class="keyword">...</span><span class="comment"> </span>
0165             int+rem(4*(k-1)-idxi, 4*(k-1)+(k==1) ) <span class="keyword">...</span>
0166             ext+4*k+1+idxi, <span class="keyword">...</span>
0167             ext+6*k+ [1-idxi 3+idxi], <span class="keyword">...</span>
0168             ext+8*k+3-idxi ];
0169     <span class="keyword">for</span> j=1:k
0170       r1= rem(j+k-1,3)+1;
0171       r2= rem(j+k,3)+1;
0172       r3= 6-r1-r2;
0173       elem([r1 r2 r3],j+k*(0:7) )= elem(:,j+k*(0:7));
0174     <span class="keyword">end</span>
0175 
0176     ELEM=[ ELEM elem(:,1:(8-4*(k==N))*k) ];
0177     int=ext;
0178   <span class="keyword">end</span> <span class="comment">%for k=1:N</span>
0179 
0180   bdy_nodes= [ (ext  :ext+N*4-1) ; <span class="keyword">...</span>
0181                (ext+1:ext+N*4-1), ext ];
0182   point_elec_nodes= (ext):(ext+N*4-1) ;
0183  
0184 
0185 <span class="comment">% 'extrude' a 2D model defined by ELEM and NODE into a 3D model</span>
0186 <span class="comment">% levels are defined by 'niveaux',</span>
0187 <span class="comment">% 2D parameters are ELEM, NODE, and bdy</span>
0188 <span class="comment">%</span>
0189 <span class="comment">% FIXME: The boundary calculated in 3D is no good. Instead</span>
0190 <span class="comment">%   it needs to be fixed using find_boundary, later</span>
0191 <a name="_sub3" href="#_subfunctions" class="code">function [ELEM, NODE, BDY, elec_nodes] = mk_3D_model( </a><span class="keyword">...</span>
0192      elem0, node0, niveaux, bdy, elec_nodes0, node_order );
0193 
0194   elem0= <a href="#_sub5" class="code" title="subfunction elem=  node_reorder( elem0, node_order);">node_reorder</a>( elem0, node_order);
0195 
0196   d= size(elem0,1);       <span class="comment">%dimentions+1</span>
0197   n= size(node0,2);       <span class="comment">%NODEs</span>
0198   e= size(elem0,2);       <span class="comment">%ELEMents</span>
0199 
0200 <span class="comment">%                   D     U</span>
0201   elem_odd= [elem0([3,2,1,1],:), <span class="keyword">...</span><span class="comment"> % 1 up 1 2 3 down</span>
0202              elem0([3,2,2,1],:), <span class="keyword">...</span><span class="comment"> % 1 2 up 2 3 down </span>
0203              elem0([3,3,2,1],:)];    <span class="comment">% 1 2 3 up 3 down</span>
0204   elem_even=[elem0([1,2,3,3],:), <span class="keyword">...</span><span class="comment"> % 3 up 1 2 3 down</span>
0205              elem0([1,2,2,3],:), <span class="keyword">...</span><span class="comment"> % 3 2 up 2 1 down </span>
0206              elem0([1,1,2,3],:)];    <span class="comment">% 3 2 1 up 1 down</span>
0207 
0208   NODE= [node0; niveaux(1)*ones(1,n) ];
0209   ELEM= [];
0210   bl= size(bdy,2);
0211 <span class="comment">% Interlaced bdy idx</span>
0212 
0213   bdy_order =node_order(bdy);
0214   bdy_up= find(bdy_order&gt;[1;1]*min(bdy_order));
0215   bdy_dn= find(bdy_order&lt;[1;1]*max(bdy_order));
0216   
0217   bdy_odd = [bdy; bdy(bdy_up')];
0218   bdy_even= [bdy; bdy(bdy_dn')];
0219   BDY = [];
0220  
0221   ln= length(niveaux);
0222   <span class="keyword">for</span> k=2:ln
0223     NODE=[NODE  [node0; niveaux(k)*ones(1,n)] ];
0224     <span class="keyword">if</span> rem(k,2)==1
0225         elem= elem_odd;
0226         bdy_e0= bdy_even;
0227         bdy_e1= bdy_odd;
0228     <span class="keyword">else</span>
0229         elem= elem_even;
0230         bdy_e1= bdy_even;
0231         bdy_e0= bdy_odd;
0232     <span class="keyword">end</span>
0233     el_add = (k-2)*n+[[zeros(3,e);n*ones(1,e)], <span class="keyword">...</span>
0234                       [zeros(2,e);n*ones(2,e)], <span class="keyword">...</span>
0235                       [zeros(1,e);n*ones(3,e)]];
0236     ELEM= [ELEM,elem + el_add];
0237     BDY= [BDY, bdy_e0+(k-2)*n+[zeros(2,bl);n*ones(1,bl)], <span class="keyword">...</span>
0238                bdy_e1+(k-2)*n+[n*ones(2,bl);zeros(1,bl)] ];
0239   <span class="keyword">end</span> <span class="comment">%for k</span>
0240 
0241   <span class="comment">% Now add top and bottom boundary</span>
0242   BDY= [elem0, BDY, elem0+n*(ln-1) ];
0243 
0244   <span class="comment">% elec_nodes is all nodes for all layers</span>
0245   elec_nodes= ones(ln,1) * elec_nodes0 + <span class="keyword">...</span>
0246               (0:ln-1)'  * n*ones(1, length(elec_nodes0) );
0247 
0248 
0249 <span class="comment">%param.electrode = mk_electrodes( elec_nodes );</span>
0250 <span class="comment">% Create the electrode structure from elec_nodes</span>
0251 <span class="comment">% Currently implements point electrodes with</span>
0252 <span class="comment">%   contact impedance of near zero.</span>
0253 <a name="_sub4" href="#_subfunctions" class="code">function elec_struct = mk_electrodes( elec_nodes)</a>
0254    <span class="keyword">for</span> i= 1:length( elec_nodes )
0255       elec_struct(i).nodes     = elec_nodes(i);
0256       elec_struct(i).z_contact = 0.001; <span class="comment">% corresponds to 1 ohm</span>
0257    <span class="keyword">end</span>
0258    <span class="comment">% Need to do it this way to be compatible accross versions</span>
0259    <span class="keyword">if</span> ~exist(<span class="string">'elec_struct'</span>);
0260        elec_struct= [];
0261    <span class="keyword">end</span>
0262 
0263 <a name="_sub5" href="#_subfunctions" class="code">function elem=  node_reorder( elem0, node_order);</a>
0264   e= size(elem0,2);       <span class="comment">%ELEMents</span>
0265 
0266   no_test=  node_order(elem0);
0267   no_test=  (0:e-1)'*[3,3,3]+no_test';
0268   elem=     elem0(no_test');
0269 
0270   no_test = node_order(elem);
0271   ok= ~norm(no_test - [1;2;3]*ones(1,e));
0272 
0273   <span class="keyword">if</span> ~ok; error(<span class="string">'test_node_order fails - cant do 3D meshes'</span>); <span class="keyword">end</span>
0274 
0275 <a name="_sub6" href="#_subfunctions" class="code">function do_unit_test</a>
0276   subplot(3,3,1)
0277   mdl= <a href="mk_circ_tank.html" class="code" title="function param= mk_circ_tank(rings, levels, elec_spec );">mk_circ_tank</a>(2, [], 2 );
0278   <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(mdl, [0,1,1]);
0279   <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2D mdl'</span>, length(mdl.elems), 16);
0280 
0281   subplot(3,3,2)
0282   mdl= <a href="mk_circ_tank.html" class="code" title="function param= mk_circ_tank(rings, levels, elec_spec );">mk_circ_tank</a>(4, [], 16 );
0283   <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(mdl);
0284   <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2D mdl'</span>, length(mdl.nodes), 41);
0285 
0286   subplot(3,3,3)
0287   mdl= <a href="mk_circ_tank.html" class="code" title="function param= mk_circ_tank(rings, levels, elec_spec );">mk_circ_tank</a>(4, linspace(-1,1,3), {<span class="string">'planes'</span>, 8, 2} );
0288   <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(mdl);
0289   <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2D mdl'</span>, length(mdl.elems), 384);
0290 
0291   subplot(3,3,4)
0292   mdl= <a href="mk_circ_tank.html" class="code" title="function param= mk_circ_tank(rings, levels, elec_spec );">mk_circ_tank</a>(4, linspace(-1,1,5), {<span class="string">'zigzag'</span>, 4, [2,4]} );
0293   <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(mdl);
0294   <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2D mdl'</span>, length(mdl.elems), 768);
0295 
0296   <span class="keyword">try</span> 
0297      mdl=  <a href="mk_circ_tank.html" class="code" title="function param= mk_circ_tank(rings, levels, elec_spec );">mk_circ_tank</a>(2, [], 18 );  error
0298      <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'test for error'</span>, 1,0);
0299   <span class="keyword">catch</span>
0300      <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'test for error'</span>, 1,1);
0301   <span class="keyword">end</span>
0302 
0303   subplot(3,3,5)
0304   mdl= <a href="mk_circ_tank.html" class="code" title="function param= mk_circ_tank(rings, levels, elec_spec );">mk_circ_tank</a>(4, [], 0);
0305   <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(mdl);
0306   title <span class="string">'no electodes'</span>
0307 
0308   subplot(3,3,6)
0309   mdl= <a href="mk_circ_tank.html" class="code" title="function param= mk_circ_tank(rings, levels, elec_spec );">mk_circ_tank</a>(4, linspace(-1,1,5), 0);
0310   <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(mdl);
0311   title <span class="string">'no electodes'</span></pre></div>
<hr><address>Generated on Fri 01-Jun-2018 15:59:55 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>